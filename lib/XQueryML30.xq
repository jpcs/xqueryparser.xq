xquery version "1.0" encoding "UTF-8";

(: This file was generated on Tue Mar 8, 2016 16:41 (UTC+01) by REx v5.35 which is Copyright (c) 1979-2015 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryML30.ebnf -xquery -tree -backtrack :)

(:~
 : The parser that was generated for the XQueryML30 grammar.
 :)
module namespace p="XQueryML30";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 14;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 15;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 37, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 37,
  37
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 324, 370,
  386, 422, 422, 422, 414, 354, 346, 354, 346, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 439, 439, 439, 439, 439, 439, 439, 339, 354, 354, 354, 354, 354, 354, 354, 354, 400, 422, 422, 423, 421,
  422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 353, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
  39, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 40, 41, 42, 43, 44, 45, 46, 47, 48, 30,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
  37, 37, 39, 39, 37, 37, 37, 37, 37, 37, 37, 68, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 68,
  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 37, 39, 37, 39, 39, 37
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 16386, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
  230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 18964, 17932, 17971, 17971, 17971, 17968, 17971, 17971, 17971, 17971, 17920, 17971, 17971, 17971, 17954, 17938,
  27849, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810,
  24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 18064, 18077, 18090, 18106,
  25433, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 19653, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  34810, 24789, 18124, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 18595, 18148, 24789, 24789, 24789, 18169, 24789, 24789, 25220, 19088, 18237, 22383, 24789, 24789,
  30312, 18190, 24165, 24789, 24789, 24789, 21780, 24789, 25755, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 18620, 24789, 18222, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 22336, 24789, 24789, 24789, 18283, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 18301, 18415, 24789, 24789, 24789, 18338, 24789, 24789, 18417, 24789, 18030, 18375, 35576,
  18361, 18411, 25501, 27142, 24789, 24789, 24789, 18433, 24789, 23819, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 34810, 24789, 18455, 18485, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 23934, 24789, 24789, 24789, 18503, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 18202, 21473, 24789, 24789, 24789, 18523, 24789, 24789, 34268, 28208, 18558, 24789,
  26401, 21476, 26402, 18583, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 26318, 26303, 18611,
  26313, 24789, 26727, 31438, 23444, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789,
  18636, 24789, 24789, 24789, 24789, 18814, 27589, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 18645, 24789, 18661, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18764, 18685, 24789, 24789, 24789, 18706, 24789, 24789, 18810,
  19524, 18727, 29143, 24789, 24789, 32048, 18752, 24410, 24789, 24789, 24789, 21780, 24789, 24789, 18780, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 37526, 24789, 18799, 29148, 24789, 19285, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 25884, 24789, 24789, 24789, 29421, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 18842, 18851, 18851, 18851, 18830, 18851, 18851,
  18882, 18893, 18870, 18936, 18854, 18909, 18924, 18952, 27142, 24789, 24789, 24789, 18980, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 38453, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 26550, 24789, 24789, 24789, 19001, 24789,
  24789, 34081, 24789, 18030, 19029, 19042, 19042, 19013, 19058, 19074, 24789, 24789, 24789, 19125, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 18487, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 30413, 24789, 24789, 24789, 18011,
  24789, 24789, 24789, 24789, 18030, 19175, 30820, 19146, 19161, 19204, 27142, 24789, 24789, 24789, 21780, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34876, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34878, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789,
  18011, 24789, 24789, 24789, 24789, 18030, 19232, 33554, 19269, 19283, 33561, 27142, 24789, 24789, 24789, 21780, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789,
  24789, 19301, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 32938, 24789, 24789,
  24789, 19321, 24789, 24789, 32940, 24789, 19367, 19400, 19410, 19410, 19382, 19820, 27142, 24789, 24789, 24789, 21780,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19426, 24789, 24789,
  24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 19449, 33773, 19478, 19492, 33780, 19510, 24789, 24789, 24789,
  21780, 24789, 24789, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22143, 24789, 19560,
  19285, 26888, 24789, 19301, 26851, 24789, 27107, 32236, 23737, 24789, 19838, 19839, 19839, 21080, 19616, 19616, 19616,
  26847, 24789, 24789, 24789, 24789, 24789, 19578, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 21078, 19615,
  19616, 19616, 19616, 32147, 27747, 24789, 24789, 24789, 18395, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232,
  19616, 19616, 19616, 23593, 24789, 24789, 24789, 19633, 24764, 37917, 23313, 19839, 29016, 32566, 19616, 32620, 24789,
  24789, 19650, 31997, 32402, 19839, 34432, 19616, 37722, 24789, 36071, 31996, 21812, 19839, 34440, 33254, 37242, 31997,
  35676, 34573, 19669, 38192, 19686, 26835, 25040, 19714, 21349, 19749, 26226, 34487, 27950, 32411, 32412, 22500, 23588,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789,
  24789, 24789, 24789, 18011, 24789, 24789, 24789, 20593, 18030, 24789, 24789, 24789, 24789, 19770, 19798, 24789, 24789,
  24789, 21780, 24789, 21428, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 24578, 24789,
  24789, 19285, 24789, 24789, 24789, 24789, 24789, 27107, 32236, 23737, 24789, 19838, 19839, 19839, 21080, 19616, 19616,
  19616, 23593, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 21078,
  19615, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083,
  30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620,
  24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789,
  31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500,
  23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202,
  19727, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 19870, 35987, 19856, 19920, 19943, 27142, 24789,
  24789, 24789, 21780, 24789, 24789, 37602, 24789, 36941, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987,
  24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  18202, 19976, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 36565, 18030, 24789, 24789, 24789, 24789, 19995, 20028,
  24789, 24789, 24789, 21780, 24789, 26017, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616,
  37097, 24789, 24789, 19285, 24789, 24789, 20084, 24789, 24789, 27107, 32236, 23737, 24789, 19838, 19839, 19839, 21080,
  19616, 19616, 19616, 29055, 24789, 24789, 24789, 24789, 20706, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839,
  19839, 38116, 19615, 19616, 19616, 19616, 30394, 24789, 24789, 24789, 30497, 24789, 31996, 32236, 23736, 32846, 19839,
  19839, 23146, 20108, 19616, 19616, 19616, 30692, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 27611, 19616,
  19616, 33651, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440,
  32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411,
  32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 19955, 19305, 24789, 24789, 24789, 20131, 20151, 24789, 20135, 24789, 18030, 24789, 24789, 18542, 20169, 19733,
  20186, 24789, 24789, 24789, 20202, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 20247, 20224,
  30003, 20294, 24789, 24789, 38545, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 20263, 20264, 20264,
  20280, 30003, 30003, 30003, 20328, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 31820, 20264,
  20264, 20264, 20349, 30002, 30003, 30003, 30003, 20521, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 20246,
  20264, 20264, 20371, 29996, 30003, 30003, 30003, 20521, 24789, 24789, 24789, 24789, 24789, 23491, 20264, 20264, 20375,
  30003, 30003, 20391, 24789, 24789, 24789, 24789, 23492, 20264, 20408, 30003, 20392, 24789, 24789, 24789, 23493, 20264,
  20425, 20391, 24789, 24789, 31820, 20409, 20428, 24789, 20247, 20429, 31817, 20445, 31819, 20447, 20463, 20237, 20469,
  20485, 20486, 20502, 20516, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 18202, 27441, 24789, 24789, 24789, 20538, 20559, 24789, 24789, 24789, 20579, 20614, 20624, 20624, 20561,
  20543, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 26008, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 21543, 24789, 24789, 24789, 24789, 31417, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 35746, 24789, 24789, 24789, 24789, 20640, 24789, 24789, 24789, 31417, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 20851, 20675, 24789, 24789, 24789, 20697, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  34808, 24789, 24789, 19130, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 25999, 20722, 20732, 20732,
  20748, 20766, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 35075, 24789, 24789, 24789, 24789, 24789,
  24789, 34810, 24789, 20782, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 19782, 38280, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 20806, 20816,
  20816, 20832, 36155, 27142, 20850, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 20867, 24789, 24789, 24789, 24789,
  24789, 24789, 34810, 24789, 20890, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 19216, 34802, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 20914,
  20924, 20924, 20940, 27519, 35459, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 34766, 24789, 24789, 24789,
  24789, 24789, 24789, 34810, 24789, 20963, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 29263, 24789, 24789, 24789, 24789, 21007, 24789, 24789, 24789, 24789, 18030,
  24789, 38373, 21012, 24789, 29251, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 37741, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 34810, 24789, 21028, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789,
  18030, 24789, 24789, 24789, 24789, 21052, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789,
  24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789, 24789,
  27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789, 24789, 22961, 24789, 24789,
  27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789, 24789, 30496,
  24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616, 28704, 24789, 24789,
  24789, 30497, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616, 19616, 25990, 24789, 24789,
  35968, 24789, 24764, 37917, 19839, 19839, 27611, 19616, 19616, 33651, 24789, 24789, 24789, 31997, 32402, 19839, 36264,
  19616, 32621, 24789, 20898, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670,
  26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789, 24789,
  24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789,
  24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789, 24789, 22961, 24789,
  24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789, 24789,
  30496, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616, 28704, 24789,
  24789, 24789, 30497, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616, 19616, 25990, 24789,
  24789, 24789, 24789, 24764, 37917, 19839, 19839, 27611, 19616, 19616, 33651, 24789, 24789, 24789, 31997, 32402, 19839,
  36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836,
  19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789,
  24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789,
  24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789, 24789, 22961,
  24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789,
  24789, 30496, 21137, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616, 28704,
  24789, 24789, 24789, 30497, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616, 19616, 25990,
  24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 27611, 19616, 19616, 33651, 24789, 24789, 24789, 31997, 32402,
  19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192,
  19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011,
  24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24116,
  24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789, 24789,
  22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789,
  24789, 24789, 30496, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616,
  28704, 24789, 24789, 24789, 30497, 21157, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616, 19616,
  25990, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 27611, 19616, 19616, 33651, 24789, 24789, 24789, 31997,
  32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745,
  38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789,
  18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789,
  30520, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789,
  24789, 30527, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789,
  24789, 24789, 24789, 30496, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616,
  19616, 28704, 24789, 24789, 24789, 30497, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616,
  19616, 25990, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 27611, 19616, 19616, 33651, 24789, 24789, 24789,
  31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265,
  26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789,
  24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780,
  24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285,
  24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616,
  19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616,
  19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 24789,
  24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844,
  36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789,
  24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789,
  21780, 24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 21920, 21096, 24789,
  19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616,
  29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615,
  19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232,
  19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789,
  24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997,
  32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789,
  24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 21174, 24789, 24789,
  24789, 21780, 24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096,
  24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616,
  19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304,
  19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083,
  30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620,
  24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789,
  31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500,
  23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955,
  24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 21204, 35612, 24789, 38192, 21068, 30239, 19798, 24789,
  24789, 24789, 21780, 24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322,
  21096, 24789, 19285, 24789, 24789, 22961, 21239, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616,
  19616, 19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839,
  29304, 19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839,
  22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616,
  32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620,
  24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412,
  22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  19955, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798,
  24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616,
  22322, 21096, 24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876,
  19616, 19616, 19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839,
  19839, 29304, 19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839,
  19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616,
  19616, 32620, 24789, 24789, 24157, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440,
  32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411,
  32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 20007, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239,
  19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357,
  19616, 22322, 21096, 24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839,
  21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839,
  19839, 19839, 29304, 19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846,
  19839, 19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016,
  19616, 19616, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839,
  34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631,
  32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 21273, 38472, 21259, 21302,
  25409, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 21320, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 18267, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 24789, 24789, 24789,
  24789, 18814, 27142, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 34810, 24789, 17987, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 21338, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 21373, 21386,
  21386, 21402, 25142, 28717, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 34810, 24789, 21420, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612,
  24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 27105, 23999, 24789,
  24789, 24789, 32847, 21357, 19616, 22143, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 27107, 32236, 23737,
  24789, 33461, 19839, 19839, 19698, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764,
  32236, 24788, 33456, 19839, 19839, 19839, 24896, 19615, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24789,
  31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764,
  37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789,
  24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805,
  36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 21444, 24789, 24789, 21462, 21492, 24789, 29823, 26261, 21516,
  21559, 21572, 21580, 21596, 21612, 19798, 32283, 20598, 24789, 27547, 22374, 21188, 21286, 21658, 21628, 28983, 21644,
  24308, 30440, 24345, 21687, 21723, 21752, 22322, 21096, 23039, 21768, 24789, 29206, 22453, 29971, 35202, 27107, 32237,
  27908, 26419, 33461, 19839, 36729, 21876, 19616, 19616, 34664, 29407, 24587, 36323, 29636, 35646, 30496, 24789, 24789,
  21801, 21835, 19351, 21864, 29010, 26783, 21892, 29304, 21971, 21994, 26110, 24532, 28704, 22011, 26936, 24789, 22028,
  24789, 31484, 22056, 29134, 23516, 22081, 22099, 22083, 22129, 22177, 22198, 22227, 26292, 22244, 22290, 31011, 27135,
  24764, 37917, 19839, 19839, 22308, 19616, 19616, 22361, 22407, 22433, 24789, 22469, 22489, 30883, 36264, 36854, 32621,
  35361, 24789, 31996, 21812, 22516, 25804, 29771, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 37898,
  22551, 22826, 22574, 35782, 27631, 22599, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 22634, 24789, 24789, 18011, 28632, 24789, 24789, 24789,
  22655, 22692, 22705, 22706, 22722, 22738, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789, 24789, 27105,
  23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107,
  32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789, 29109, 30496, 24622,
  24614, 24764, 28069, 24788, 33456, 19839, 19839, 22558, 29304, 19615, 19616, 19616, 37995, 28704, 24789, 24789, 24789,
  30497, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 21114, 19616, 19616, 19616, 25990, 24789, 24789, 32999,
  21446, 22754, 21848, 22776, 19839, 27611, 22795, 19616, 33651, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616,
  32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803,
  36909, 26805, 36911, 22815, 22842, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 19883, 24789, 24789, 18011, 24789, 24789, 24790,
  24790, 22864, 22880, 22893, 22906, 22922, 22938, 19798, 24789, 24789, 36687, 21780, 24789, 22954, 24789, 24789, 24789,
  27105, 23999, 23064, 24789, 24789, 32847, 22977, 22799, 22322, 23013, 24789, 19285, 23061, 32539, 22961, 26378, 23080,
  27898, 23096, 29280, 20834, 23115, 23144, 19839, 23472, 23162, 19616, 19616, 29407, 23213, 24789, 27341, 24789, 23231,
  26972, 23260, 19904, 32236, 24788, 33917, 28125, 23280, 23329, 29304, 23347, 23380, 36387, 19616, 28704, 24789, 26629,
  24789, 18322, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 24888, 21114, 19616, 19616, 35549, 25990, 24789, 24789,
  24789, 18533, 24764, 37917, 19839, 33462, 27611, 19616, 19616, 23408, 24789, 33304, 24789, 20092, 23460, 36472, 35391,
  21978, 27233, 23488, 24789, 30635, 23509, 35819, 35399, 23532, 24789, 35606, 32844, 36451, 37474, 38192, 19836, 19670,
  26803, 36909, 26805, 27371, 23558, 25859, 27631, 32411, 32412, 23574, 23588, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 21141, 24789, 24789, 18011, 26532, 24789,
  23610, 23594, 23626, 23662, 23675, 23683, 23699, 23715, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789,
  28253, 27105, 23731, 24789, 28256, 23753, 28533, 21357, 29084, 22322, 21096, 23788, 19285, 20563, 23818, 22961, 24789,
  35017, 23835, 23860, 32968, 24147, 23887, 32017, 23903, 26578, 37864, 25289, 19616, 29407, 24789, 24789, 24981, 30476,
  30496, 24789, 24789, 24764, 32236, 23921, 33456, 19839, 19839, 19839, 37502, 19615, 19616, 19616, 22228, 29377, 24789,
  32757, 28759, 30497, 24789, 31996, 32236, 22065, 36122, 19839, 19839, 31278, 23979, 19616, 19616, 31551, 25990, 24789,
  24789, 24789, 32177, 23995, 20068, 19839, 36606, 33989, 19616, 36300, 33651, 23646, 20874, 24789, 21947, 24015, 34635,
  36264, 37083, 32621, 20790, 24789, 31996, 21812, 19839, 34440, 32620, 34773, 31997, 32844, 37004, 35890, 38192, 19836,
  19670, 26803, 36909, 38106, 37334, 24040, 24082, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 18108, 24115, 24789, 18011, 24132,
  24789, 20208, 20355, 24181, 24197, 24212, 24220, 24236, 24252, 19798, 18783, 31693, 24268, 23433, 24294, 30520, 23772,
  24331, 33199, 37304, 24361, 24426, 24461, 19101, 24496, 24548, 24564, 22322, 24639, 24475, 24682, 18736, 24789, 24710,
  24743, 24789, 24760, 32236, 24783, 24789, 24806, 24849, 24875, 24912, 31922, 25543, 30576, 23177, 24968, 25005, 24596,
  25032, 25056, 21322, 25092, 25108, 25158, 25205, 25240, 30553, 34017, 25669, 31235, 25281, 25305, 25321, 25354, 25388,
  25425, 37106, 36971, 26383, 22667, 25449, 25477, 25493, 25517, 35689, 31173, 25559, 21114, 25598, 37052, 35430, 25990,
  24403, 37844, 18439, 36641, 25624, 25645, 25685, 37965, 31086, 25718, 22211, 33144, 24789, 26542, 25753, 31208, 25771,
  31754, 25796, 25820, 25855, 37354, 25875, 25900, 25944, 25959, 25975, 24833, 26033, 26055, 31891, 26079, 26126, 24278,
  26150, 29658, 26181, 35775, 26221, 26242, 26277, 21736, 26334, 32411, 26364, 22500, 23588, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 26399, 24789, 18011,
  35081, 26418, 32977, 31702, 26435, 26450, 26465, 26473, 26489, 26505, 19798, 24789, 25224, 24789, 21780, 24789, 24116,
  24789, 27669, 24789, 32291, 31723, 24789, 27674, 26521, 26566, 28133, 27980, 22322, 26594, 24789, 19285, 26605, 24789,
  22961, 34073, 26624, 37583, 32236, 26645, 24789, 26668, 19839, 19839, 21876, 26701, 19616, 19616, 29407, 24789, 24789,
  24789, 24789, 30496, 24789, 24789, 24764, 32236, 26725, 33456, 19839, 19839, 37268, 29304, 19615, 19616, 19616, 26743,
  28704, 24789, 24789, 24789, 30497, 24789, 26761, 38022, 23736, 32846, 19839, 26780, 22083, 21114, 19616, 35865, 19616,
  25990, 24789, 24789, 24789, 32449, 24764, 26799, 19839, 19839, 26821, 19616, 19616, 26869, 24789, 24789, 24789, 31997,
  32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 38000, 24789, 31997, 32844, 36265, 26745,
  38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 26904, 26952, 23588, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789,
  18011, 24789, 26988, 24789, 26989, 27006, 27021, 27034, 27035, 27051, 27067, 19798, 24789, 24789, 24789, 21780, 24789,
  24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285, 24789,
  24789, 22961, 23766, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789,
  24789, 24789, 24789, 24789, 31839, 24789, 24764, 32236, 25123, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616,
  19616, 22613, 24789, 24315, 32376, 24789, 24789, 31996, 37938, 23736, 27083, 19839, 31271, 22083, 30232, 19616, 35144,
  19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 33888, 24789,
  27103, 32402, 19839, 36264, 19616, 32621, 27123, 24654, 27158, 21812, 19839, 34440, 32620, 24789, 27175, 35331, 27221,
  27249, 29322, 27284, 27322, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 27357, 23588, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789,
  24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 23045, 21780,
  24789, 24116, 36764, 24789, 27420, 27105, 22760, 27410, 27400, 27439, 27457, 28441, 27480, 27497, 21096, 24789, 27535,
  34723, 33163, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 26679, 21876, 19616, 19616, 27563, 29407,
  24789, 24789, 24789, 24789, 24789, 24789, 22274, 24764, 37543, 27582, 33456, 19839, 19839, 19839, 33375, 19615, 19616,
  19616, 32430, 26348, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 18048, 21819, 19839, 19839, 22083, 36413, 19616,
  19616, 19616, 23593, 24789, 18132, 24789, 24789, 24764, 37917, 19839, 19839, 26205, 19616, 19616, 29045, 22292, 24789,
  24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 23197, 27159, 27605,
  27627, 24926, 38192, 27647, 38069, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789,
  27663, 24789, 18011, 19812, 27690, 27713, 27717, 27733, 27768, 27781, 27789, 27805, 27821, 19798, 24789, 24789, 24623,
  27837, 24789, 24116, 24789, 27865, 27888, 21500, 28047, 23026, 27924, 36760, 27940, 22113, 27966, 28002, 21096, 24789,
  34319, 24789, 27384, 22961, 24789, 24789, 28040, 28063, 28085, 24789, 28116, 29710, 28149, 21876, 37046, 28180, 36499,
  29407, 36147, 24439, 24789, 28196, 38096, 27511, 25401, 24764, 28224, 28249, 33456, 19839, 31035, 36259, 28272, 19615,
  19616, 28288, 30614, 22613, 24789, 26882, 28304, 37115, 24789, 31996, 32236, 23736, 24091, 19839, 19839, 22083, 23945,
  19616, 19616, 19616, 23593, 17995, 31684, 28320, 28336, 28352, 34386, 32476, 19839, 29016, 25832, 28376, 22182, 22417,
  24789, 35248, 34947, 28393, 28431, 28457, 33408, 28473, 24789, 33481, 28500, 28525, 28549, 34467, 28577, 28615, 28648,
  32844, 36265, 29799, 28668, 19836, 19670, 20303, 36909, 22848, 29456, 26226, 25859, 27631, 28690, 32412, 22500, 28733,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789,
  24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789,
  24789, 21780, 24789, 22446, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096,
  24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616,
  19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304,
  19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083,
  30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620,
  24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789,
  31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500,
  23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955,
  24789, 24789, 25134, 24789, 18011, 20170, 28754, 24789, 28775, 28802, 28817, 28830, 28831, 28847, 28863, 19798, 21158,
  24789, 24789, 21780, 36946, 28879, 24789, 20153, 24789, 26764, 37144, 20153, 28906, 28895, 27196, 21357, 28931, 21920,
  28950, 24789, 19960, 33344, 22618, 22961, 28955, 31124, 28652, 34167, 23737, 28974, 28999, 25928, 29743, 21876, 26102,
  29032, 29071, 29407, 29106, 26990, 33217, 21098, 24789, 24789, 24789, 29125, 32236, 24788, 33616, 32076, 19839, 29167,
  29304, 29186, 35179, 28934, 19616, 22613, 31960, 29202, 24789, 29222, 24789, 31996, 32236, 29279, 32846, 19839, 22531,
  29296, 30232, 19616, 25730, 36294, 23593, 29320, 24789, 38398, 24789, 29338, 37917, 37217, 19839, 29016, 24066, 19616,
  32620, 32596, 24789, 24666, 32187, 32818, 19839, 34978, 19616, 32621, 34275, 37182, 31996, 21812, 19839, 34440, 32620,
  36519, 31997, 32844, 36902, 25839, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 29363, 29393, 32412,
  29442, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  19955, 24789, 24789, 24727, 24789, 18011, 24789, 29489, 24789, 29483, 29510, 29558, 29571, 29579, 29595, 29611, 21174,
  24789, 29635, 24789, 21780, 19562, 24116, 24789, 19384, 24789, 28674, 36007, 19384, 29627, 27752, 34396, 21357, 29652,
  22322, 21096, 34190, 19285, 24789, 32103, 22961, 24789, 24789, 27107, 32236, 29674, 22266, 29700, 22779, 31900, 21876,
  23956, 30919, 35540, 29407, 19544, 28958, 24789, 24789, 23641, 24789, 24789, 24764, 32236, 24788, 33456, 29733, 36997,
  19839, 29304, 29759, 36226, 29797, 19616, 22613, 33157, 28016, 24789, 29868, 29815, 31996, 32236, 23736, 32846, 33983,
  22535, 29839, 30232, 20991, 27481, 29889, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616,
  19616, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 34670, 24789, 24789, 31996, 21812, 19839, 34440,
  32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 36117, 29909, 29944, 36911, 26226, 25859, 27631, 32411,
  32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 19955, 24789, 24789, 20681, 24789, 29967, 24789, 29987, 25574, 29854, 30019, 30080, 30093, 30109, 30124, 30140,
  19798, 24789, 30185, 24789, 30156, 28624, 24116, 24789, 30172, 30281, 30207, 30255, 30297, 30270, 30328, 30363, 25265,
  30379, 22322, 30429, 24789, 30456, 30472, 30492, 32503, 22161, 27423, 35275, 24767, 25170, 30513, 30543, 34973, 28407,
  21876, 30569, 30592, 30610, 34700, 24789, 24789, 30630, 24789, 21304, 24789, 24789, 30651, 32236, 33335, 33456, 23309,
  19839, 19839, 29304, 30677, 19616, 19616, 19616, 22613, 37422, 24789, 27335, 24789, 31308, 20947, 32236, 30726, 36721,
  19839, 33052, 34128, 19589, 19616, 21121, 31057, 29781, 30748, 30775, 30791, 30808, 30836, 30852, 25253, 30880, 30899,
  37033, 30935, 30955, 34039, 30982, 30998, 37124, 32402, 31027, 36264, 31051, 32621, 21785, 24789, 20055, 31073, 25658,
  21906, 31102, 31148, 30710, 34961, 26165, 25608, 19927, 31165, 31189, 24989, 22583, 31224, 33712, 33526, 31251, 27631,
  32411, 31294, 22500, 26966, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 19955, 24789, 24789, 21243, 24789, 18011, 24789, 26652, 19634, 19634, 31324, 31340, 31356, 31364, 31380,
  31396, 19798, 21934, 27872, 18711, 31412, 31433, 24116, 21671, 28915, 18567, 31454, 31470, 32514, 31500, 31516, 31532,
  31567, 31604, 31640, 21096, 24789, 24940, 24789, 31670, 23244, 29535, 24789, 27107, 31718, 30661, 24789, 33461, 25696,
  31739, 21876, 19616, 31783, 35480, 29407, 35366, 24789, 35948, 30792, 31799, 24480, 31836, 31855, 31877, 30732, 33972,
  19839, 36600, 19840, 29304, 31916, 30594, 31938, 20115, 22613, 31977, 32338, 24789, 24789, 24789, 31996, 32236, 23844,
  32846, 34239, 19839, 22083, 30232, 31940, 19616, 19616, 23593, 24789, 25182, 22391, 24789, 24764, 37917, 19839, 19839,
  29016, 19616, 19616, 32620, 24789, 31956, 24789, 31997, 25461, 34341, 21707, 35557, 29090, 31976, 24789, 33745, 23871,
  19839, 24524, 32620, 24789, 31997, 32844, 36265, 26745, 31993, 32013, 32033, 32064, 36052, 29684, 32092, 26226, 25859,
  27631, 24024, 32126, 22500, 32142, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789, 28484, 24719, 30034, 32163, 20042, 29467, 30049,
  30064, 32203, 19798, 24789, 19494, 24789, 21780, 24789, 24116, 24789, 25189, 24789, 18039, 23999, 32110, 24789, 24789,
  32847, 21357, 19616, 22322, 32219, 24789, 19285, 24789, 22152, 22345, 24744, 24789, 27107, 32235, 35722, 24789, 32253,
  35828, 34220, 21876, 32318, 33646, 32307, 29407, 24789, 33943, 24789, 32334, 37416, 24789, 24789, 24764, 32236, 24788,
  33456, 19839, 19839, 32354, 29304, 19615, 19616, 35871, 19616, 22613, 37796, 24789, 38298, 38491, 32372, 19895, 32392,
  23736, 32846, 37275, 19839, 22083, 30232, 30939, 32428, 19616, 23593, 37379, 24789, 24789, 24789, 24764, 37917, 19839,
  38156, 29016, 19616, 20983, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 32446, 31996,
  32465, 29717, 34440, 32492, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 34443, 33043, 36909, 36443, 36911, 26226,
  25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789,
  38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789, 36876, 19336, 25629, 32775, 32530,
  36875, 37208, 20312, 32563, 32582, 21096, 24789, 19285, 24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789,
  33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236,
  24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996,
  32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917,
  19839, 19839, 29016, 19616, 19616, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789,
  31996, 21812, 19839, 34440, 32620, 24789, 31997, 25914, 36265, 32617, 38192, 19836, 19670, 26803, 36909, 26805, 36911,
  26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 32637, 32655, 24789, 18285, 32658, 24789, 32674, 32689,
  32702, 32708, 32724, 32740, 19798, 24789, 22012, 32756, 24694, 33285, 33682, 29542, 32773, 32791, 32808, 32834, 32863,
  21223, 36672, 32879, 32895, 33130, 22322, 21096, 24789, 26608, 25070, 32933, 33030, 30191, 24789, 27107, 32956, 32993,
  33015, 33461, 33076, 33096, 33116, 19617, 33179, 21995, 29407, 24789, 25578, 24789, 24605, 24789, 33215, 25582, 24764,
  31861, 30222, 34110, 27087, 19839, 35696, 33233, 33249, 24058, 19616, 35112, 22613, 24789, 33270, 29524, 33301, 25076,
  33320, 28360, 28233, 38146, 23905, 33360, 29170, 25016, 19616, 33391, 33424, 33443, 24789, 29494, 33478, 33497, 26063,
  33515, 34120, 35836, 29016, 33400, 22997, 36231, 32792, 33542, 24789, 31997, 32402, 19839, 27464, 19616, 31588, 23215,
  24789, 31996, 36182, 19839, 31547, 32620, 21036, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 33577, 33603, 26805,
  27306, 33632, 19754, 27631, 32411, 33667, 33698, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 33728, 18011, 36691, 28100, 28588, 33761, 33796,
  33812, 33825, 33838, 33854, 33870, 19798, 33886, 24789, 29151, 21780, 24789, 27268, 24789, 29928, 18174, 32547, 33904,
  33941, 33933, 33959, 34005, 24099, 30913, 22322, 34033, 34055, 19285, 31810, 24789, 22961, 24789, 34097, 34144, 34160,
  34183, 20012, 34206, 37225, 19839, 21876, 35126, 31580, 19616, 29407, 34608, 22639, 34255, 27263, 24789, 24789, 24789,
  24764, 32236, 34604, 33456, 23331, 19839, 19839, 29304, 19615, 35913, 19616, 19616, 22613, 21404, 18507, 21534, 24789,
  30341, 34291, 23099, 34312, 34335, 19839, 23128, 28561, 20974, 19616, 25330, 34357, 23593, 31654, 24789, 24789, 24789,
  34373, 34412, 19839, 24511, 29016, 19616, 35526, 32620, 24789, 31115, 29873, 31997, 32402, 38164, 34459, 25364, 34483,
  24789, 26253, 34503, 21812, 34519, 24049, 32620, 19188, 34540, 34567, 27297, 23364, 34589, 34624, 19599, 19109, 35062,
  26805, 36911, 34651, 25859, 28164, 34686, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 37387, 18011, 24789, 20522, 34716, 28599,
  34739, 34789, 28786, 34826, 34841, 34857, 19798, 34873, 34894, 22257, 21780, 26039, 34917, 34754, 24789, 34933, 27105,
  34994, 35033, 19979, 35006, 35049, 35097, 35160, 22322, 35195, 35218, 19285, 35247, 24789, 37819, 34901, 35264, 35291,
  35317, 35347, 35231, 35382, 28415, 34234, 35415, 35475, 32908, 35496, 29407, 26918, 35573, 35592, 35628, 24789, 20659,
  18345, 35662, 35712, 35738, 35762, 35798, 35810, 27205, 29304, 35852, 23392, 35887, 35906, 22613, 35929, 19537, 35964,
  22040, 35984, 38406, 36003, 36023, 32846, 36039, 19839, 32268, 30232, 36087, 19616, 26092, 23542, 36103, 24789, 36138,
  24789, 36171, 36198, 23295, 36247, 26685, 35511, 36281, 32620, 36316, 35941, 30347, 36339, 27187, 36355, 25532, 36380,
  36403, 36429, 24789, 31996, 34551, 36467, 36488, 25338, 36515, 19433, 36535, 37891, 36551, 24376, 36586, 36622, 26803,
  36909, 26805, 36911, 26226, 26134, 38049, 36657, 36707, 30864, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 23264, 18011, 24789, 18985, 24789,
  24789, 36745, 36780, 36794, 36802, 36818, 36834, 19798, 24789, 24789, 24789, 24952, 27694, 24116, 24789, 24789, 24789,
  27105, 23999, 18246, 24789, 27697, 25780, 21357, 36850, 22322, 36870, 24789, 19285, 24789, 24789, 18255, 18264, 24789,
  34296, 32236, 23737, 18264, 36892, 19839, 19839, 36212, 35137, 19616, 19616, 36927, 24789, 36962, 24789, 35639, 31149,
  18313, 24789, 21955, 29347, 24391, 33456, 33060, 36987, 21702, 29304, 19615, 37020, 37068, 19616, 22613, 20652, 24789,
  24789, 24789, 32601, 31996, 37140, 23736, 32846, 37160, 19839, 22083, 30232, 35173, 19616, 19616, 37344, 24789, 37181,
  24789, 24789, 24764, 37198, 19839, 19839, 29016, 19616, 19616, 32620, 37241, 24789, 31202, 31997, 35301, 19839, 34524,
  19616, 32621, 30701, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192, 37258, 37291,
  26803, 36909, 26805, 36911, 26226, 25859, 31767, 32411, 32412, 37320, 23588, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789, 18011, 29426, 33736,
  24789, 22676, 37370, 37403, 24789, 33742, 37438, 37454, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789, 24789,
  24789, 27105, 23999, 24789, 24789, 24789, 31261, 21357, 37470, 22322, 21096, 30759, 19285, 24789, 24789, 22961, 24789,
  32639, 22473, 32236, 23737, 24789, 37490, 19839, 19839, 21876, 25372, 19616, 19616, 29407, 24789, 24789, 24789, 24789,
  37518, 24789, 18206, 24764, 37542, 24788, 33456, 19839, 37559, 19839, 29304, 19615, 33427, 31624, 19616, 22613, 24789,
  24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789,
  24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 18669, 24789, 31997, 32402, 19839,
  36264, 19616, 32621, 36065, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 37575, 19836,
  19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 18014, 37599, 24789,
  30407, 24789, 29237, 37618, 37634, 37648, 37661, 37677, 37693, 19798, 24789, 24789, 24789, 21780, 24789, 24116, 24789,
  24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 37709, 29893, 22322, 21096, 24789, 19285, 24789, 24789, 22961,
  20750, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616, 19616, 19616, 22613,
  24789, 24789, 24789, 29922, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616, 19616, 19616, 23593,
  24789, 37738, 24789, 24789, 24764, 37917, 32356, 19839, 33587, 28377, 19616, 32917, 24789, 24789, 24789, 31997, 32402,
  19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745, 38192,
  19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 20007, 24789, 24789, 24789, 24789, 18011,
  24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 37757, 37773, 19798, 24789, 24789, 24789, 37789, 24789, 37812,
  24789, 24789, 24445, 23802, 23999, 26853, 37835, 36570, 34422, 21357, 37860, 22322, 21096, 24789, 30966, 20333, 33499,
  34064, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 25702, 21876, 19616, 19616, 23356, 35445, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 24859, 19615, 19616, 19616, 19616,
  33194, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616, 19616, 19616,
  28738, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 24789, 24789, 31997,
  32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844, 36265, 26745,
  38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789, 24789,
  18011, 24789, 24789, 24789, 24789, 18030, 35612, 24789, 38192, 21068, 30239, 19798, 36635, 24789, 24789, 21780, 24789,
  24116, 21218, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 37880, 24820, 27566, 22322, 21096, 24789, 23421, 24789,
  24789, 22961, 24789, 24789, 27107, 32236, 37914, 31132, 33461, 19839, 33100, 21876, 19616, 19616, 26709, 29407, 26929,
  24789, 24789, 24789, 24789, 24789, 18388, 24764, 37933, 24788, 33456, 37954, 37165, 19839, 29304, 37981, 19616, 22990,
  19616, 22613, 21525, 24789, 24789, 24789, 24789, 31996, 38016, 23736, 32846, 36364, 19839, 22083, 30232, 25737, 19616,
  19616, 23593, 24789, 24789, 24789, 18690, 28509, 37917, 38038, 26194, 29951, 38065, 31618, 23963, 24789, 24789, 23192,
  31997, 32402, 19839, 36264, 19616, 27986, 24789, 18153, 31996, 21812, 33080, 34440, 38085, 24789, 31997, 32844, 36265,
  26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 19955, 24789, 24789, 24789,
  24789, 18011, 24789, 24789, 24789, 24789, 38132, 35612, 24789, 38192, 21068, 30239, 19798, 24789, 24789, 24789, 21780,
  24789, 24116, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616, 22322, 21096, 24789, 19285,
  24789, 24789, 22961, 24789, 24789, 27107, 32236, 23737, 24789, 33461, 19839, 19839, 21876, 19616, 19616, 19616, 29407,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839, 19839, 29304, 19615, 19616,
  19616, 19616, 22613, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839, 19839, 22083, 30232, 19616,
  19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616, 19616, 32620, 24789, 24789,
  24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440, 32620, 24789, 31997, 32844,
  36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411, 32412, 22500, 23588, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789, 24789,
  24789, 24789, 38180, 38327, 38208, 38233, 38335, 38254, 38263, 38191, 38238, 38217, 18469, 27142, 24789, 24789, 24789,
  21780, 24789, 24789, 38279, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789, 24789,
  19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202, 24789,
  24789, 24789, 24789, 18011, 24789, 38353, 38296, 24789, 18030, 38314, 19245, 19253, 38351, 28024, 27142, 24789, 24789,
  24789, 21780, 24789, 24789, 24789, 24789, 24789, 38369, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987, 24789,
  24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 18202,
  24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 38389, 38422, 38435, 38435, 38451, 19462, 27142, 24789,
  24789, 24789, 21780, 24789, 24789, 38469, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 34810, 24789, 17987,
  24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  18202, 24789, 24789, 24789, 24789, 18011, 24789, 24789, 24789, 24789, 18030, 24789, 24789, 24789, 24789, 18814, 19798,
  24789, 24789, 24789, 21780, 24789, 24789, 24789, 24789, 24789, 27105, 23999, 24789, 24789, 24789, 32847, 21357, 19616,
  22143, 24789, 24789, 19285, 24789, 24789, 24789, 24789, 24789, 27107, 32236, 23737, 24789, 19838, 19839, 19839, 21080,
  19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24764, 32236, 24788, 33456, 19839, 19839,
  19839, 21078, 19615, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24789, 31996, 32236, 23736, 32846, 19839,
  19839, 22083, 30232, 19616, 19616, 19616, 23593, 24789, 24789, 24789, 24789, 24764, 37917, 19839, 19839, 29016, 19616,
  19616, 32620, 24789, 24789, 24789, 31997, 32402, 19839, 36264, 19616, 32621, 24789, 24789, 31996, 21812, 19839, 34440,
  32620, 24789, 31997, 32844, 36265, 26745, 38192, 19836, 19670, 26803, 36909, 26805, 36911, 26226, 25859, 27631, 32411,
  32412, 22500, 23588, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 38544, 24789, 24789, 24789, 24789, 24789, 24789, 38488, 24789, 24789, 38507, 38517, 38517, 38543, 38533,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789, 24789,
  24789, 24789, 102664, 73728, 77824, 102664, 102664, 102664, 102664, 102664, 69632, 102664, 102664, 102664, 102664,
  102664, 102664, 102664, 98567, 98567, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664,
  102664, 102664, 1, 16386, 3, 4, 102664, 102664, 0, 0, 98567, 102664, 98567, 102664, 102664, 102664, 102664, 102664,
  102664, 102664, 102664, 102664, 323, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664, 102664,
  102664, 102664, 102664, 102664, 102664, 102664, 0, 0, 547, 548, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1675, 0, 1676,
  0, 0, 1678, 0, 0, 0, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 319, 320, 321, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632,
  0, 0, 0, 0, 0, 0, 0, 0, 588, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 1560, 0, 0, 0, 110996,
  110996, 110996, 110996, 0, 0, 0, 0, 0, 404, 404, 110996, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404,
  404, 110996, 110996, 110996, 110996, 110996, 110996, 110996, 110996, 404, 110996, 110996, 404, 110996, 110996, 404,
  110996, 110996, 110996, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288, 289, 0, 0, 547, 548, 0, 870, 870, 4, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1688, 0, 0, 0, 0, 0, 0, 0, 266, 0, 269, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 610304, 0, 0, 0,
  0, 0, 323, 266, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 638976, 0, 0, 0, 547, 547, 547, 547, 547, 547, 547, 547, 547,
  521, 521, 547, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593920, 0, 0, 0, 0, 54114, 548, 0, 0, 0, 4, 0,
  0, 0, 266, 0, 0, 0, 269, 119151, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 612, 0, 0, 0, 0, 0, 0, 0, 0,
  649, 0, 0, 959, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 0, 0, 547, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  306, 0, 2109693, 16386, 3, 4, 0, 259, 0, 0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 1268, 0, 1270, 0, 0, 0, 0, 0, 0, 0, 1513,
  0, 0, 0, 1260, 0, 0, 0, 0, 0, 0, 323, 0, 0, 122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 365829, 1286, 0, 0, 1288, 0,
  122880, 122880, 122880, 0, 122880, 122880, 0, 0, 0, 122880, 0, 0, 122880, 122880, 0, 122880, 122880, 122880, 122880,
  0, 0, 0, 122880, 122880, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 753664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1525, 0, 0, 0, 0, 0, 0,
  122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 323, 147456, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 905216, 0, 0, 0, 0, 0, 0, 547, 548, 0, 0, 0, 4, 0, 0, 0, 0, 871, 873, 0, 0, 0, 0, 0, 1056768,
  0, 1056768, 0, 1056768, 1056768, 0, 1, 16386, 3, 4, 875, 877, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 0, 0, 0,
  1186, 1188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1044480, 0, 0, 0, 0, 323, 0, 0, 0, 0, 131072, 131072, 131072, 0, 0,
  0, 0, 0, 0, 0, 1715, 1716, 0, 0, 0, 0, 0, 0, 0, 272, 273, 0, 272, 273, 272, 0, 273, 0, 0, 73728, 77824, 131072, 0, 0,
  0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 686, 0, 0, 0, 0, 0, 691, 0, 131072, 131072, 131072, 131072, 131072, 131072,
  131072, 131072, 131072, 0, 0, 131072, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 73728, 77824, 0,
  135168, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 805, 522, 809, 524, 0, 0, 0, 0, 0, 368, 368, 0, 0, 0, 0, 0, 368, 0, 0,
  0, 0, 0, 0, 0, 0, 806, 807, 810, 811, 0, 0, 0, 0, 0, 0, 867, 868, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1825, 0, 0,
  0, 0, 0, 0, 0, 267, 0, 270, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 692224, 0, 0, 0, 0, 0, 323, 267, 267, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 954368, 0, 0, 0, 270, 73728, 139635, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 928, 0,
  0, 0, 0, 933, 0, 0, 548, 548, 548, 548, 548, 548, 548, 548, 548, 522, 522, 548, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 139264, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 573, 574, 0, 0, 0, 547, 54117, 0, 0, 0, 4, 0,
  0, 0, 0, 0, 0, 267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 16386, 3, 4, 265, 265, 324, 265, 265, 143625, 265, 265,
  265, 265, 143625, 326, 265, 265, 265, 265, 0, 0, 265, 265, 143625, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265,
  265, 265, 265, 265, 265, 265, 143625, 143625, 143625, 143686, 73728, 77824, 265, 265, 265, 265, 265, 69632, 265, 265,
  265, 265, 265, 265, 265, 143625, 265, 265, 265, 143625, 265, 265, 265, 265, 265, 265, 265, 143686, 265, 265, 265, 265,
  265, 265, 143686, 265, 143625, 265, 143625, 143625, 143625, 265, 143625, 265, 143625, 265, 265, 143625, 143625,
  143625, 143625, 143625, 265, 143625, 143625, 0, 0, 0, 265, 0, 265, 265, 143625, 265, 143625, 265, 143625, 143625,
  143625, 143625, 265, 265, 265, 265, 143625, 265, 265, 143625, 265, 265, 265, 143625, 143686, 143686, 143686, 143686,
  143686, 143686, 143686, 143686, 143625, 143625, 143625, 1, 16386, 3, 4, 0, 0, 0, 0, 0, 0, 0, 98567, 98567, 98567,
  98567, 0, 0, 0, 2204255, 2204255, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0, 0, 323, 0, 0, 0, 0,
  155648, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 155648, 155648, 155648, 0, 0, 0, 0, 0, 0,
  155648, 0, 0, 155648, 155648, 0, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648,
  155648, 155648, 155648, 155648, 155648, 155648, 0, 0, 0, 155648, 0, 0, 0, 0, 155648, 155648, 155648, 155648, 0, 16386,
  3, 4, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 266, 267, 0, 269, 270, 0, 0, 0, 0, 269, 269, 0, 0, 0, 0, 0, 0, 269, 0, 0, 0, 0,
  0, 0, 712704, 712704, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 96300, 94708, 96302, 0, 0, 323, 323,
  204800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 548, 0, 0, 0, 159744, 159744, 159744, 159744, 159744, 159744, 159744,
  159744, 163840, 159744, 159744, 163840, 159744, 159744, 163840, 159744, 159744, 0, 0, 0, 0, 0, 29197, 0, 29197, 0, 0,
  159744, 0, 0, 159744, 159744, 159744, 159744, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 0, 0, 0, 0, 0, 946176, 1024000, 0, 0, 0,
  0, 0, 0, 2009, 0, 29197, 29197, 29197, 29197, 29197, 29197, 29197, 29197, 29197, 159744, 159744, 29197, 1, 16386, 3,
  4, 0, 0, 0, 0, 253952, 0, 0, 0, 0, 253952, 0, 0, 0, 167936, 167936, 167936, 167936, 0, 0, 0, 0, 0, 0, 0, 167936, 0, 0,
  0, 0, 0, 0, 1065380, 0, 1065380, 1065380, 1065380, 1065380, 1065380, 1065380, 1065380, 1065380, 1065380, 1065380,
  1065380, 1065380, 1065380, 1065380, 1065380, 1065380, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 0,
  0, 0, 953, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 273, 0, 0, 0, 0, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 0,
  172032, 0, 0, 0, 0, 507904, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 508330, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1328, 0, 1329, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 172032, 172032, 0, 172032, 0, 0, 172032, 172032, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 576, 0, 172032, 172032, 172032, 172032, 172032, 0, 0, 0, 0, 0, 172032, 172032,
  172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 1,
  254, 3, 4, 0, 0, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 630784, 90538, 90538, 90538, 631210, 90538, 0, 176128, 176128,
  176128, 176128, 0, 0, 0, 0, 0, 0, 0, 176128, 0, 0, 0, 0, 0, 0, 1073152, 0, 0, 1073152, 1073152, 1073152, 1, 16386, 3,
  4, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128,
  176128, 176128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 82177, 82177, 0, 554, 0, 0, 0, 0, 0, 266, 267, 0,
  269, 270, 0, 0, 0, 0, 270, 270, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 909312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1208, 0,
  0, 0, 0, 643072, 0, 0, 892, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 633, 0, 0, 0, 225280, 0, 0, 0, 0, 0, 0, 0, 1272,
  0, 0, 0, 0, 0, 0, 0, 94734, 94734, 95824, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 782862, 94734, 94734,
  94734, 94734, 94734, 0, 0, 0, 29793, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 95354, 1708, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 304, 0, 0, 1830, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 658, 0, 0, 96244, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 0, 0, 0, 90538, 0, 0, 94708, 94708, 94708, 94708, 94708, 96270, 96271, 94708, 96272, 94708,
  94708, 94708, 94708, 0, 0, 0, 0, 0, 0, 0, 0, 29793, 95254, 94734, 94734, 96303, 94708, 94708, 94734, 96307, 94734,
  94734, 94734, 94734, 94734, 96313, 94734, 94734, 0, 0, 0, 0, 0, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 1, 16386,
  3, 4, 94708, 96333, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 2162, 0, 94708,
  94708, 94708, 184869, 184869, 184869, 184869, 184869, 184869, 184869, 184869, 184869, 0, 0, 184869, 1, 16386, 3, 4, 0,
  0, 0, 249856, 0, 0, 0, 0, 249856, 0, 0, 0, 82177, 82177, 0, 0, 0, 0, 0, 0, 0, 266, 267, 0, 269, 270, 0, 0, 0, 0, 292,
  0, 0, 292, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 172032, 172032, 1, 16386, 3, 4, 90538, 0, 0, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95593, 192917, 192917, 192917,
  192917, 192917, 192917, 192917, 192917, 0, 192917, 192917, 0, 192917, 192917, 0, 192917, 192917, 192917, 192917, 0, 0,
  0, 0, 0, 0, 0, 192917, 0, 0, 0, 0, 0, 279, 280, 281, 282, 283, 284, 285, 0, 0, 0, 0, 0, 0, 1537, 0, 0, 0, 0, 0, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 91413, 90538, 90538, 90538, 90538, 192917, 192917, 0, 0, 0, 0, 271,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 684032, 0, 0, 0, 0, 90538, 0, 192917, 192917, 192917, 192917, 192917, 192917, 192917,
  192917, 192917, 192917, 0, 1, 16386, 3, 4, 82177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 918, 0, 0, 323, 323, 0, 0, 41228,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 41322, 41322, 41322, 41322, 41322, 41322, 41322, 41322, 41322, 0, 0,
  41322, 1, 16386, 3, 4, 82178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 1044, 1045, 0, 0, 82177, 82177, 0, 0, 0, 0, 0, 0,
  0, 266, 267, 41228, 269, 270, 0, 0, 0, 0, 352, 90551, 90551, 90551, 90551, 90551, 0, 0, 352, 0, 0, 0, 0, 0, 1944, 0,
  0, 0, 0, 0, 0, 92060, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94708, 95950, 94708, 0, 0, 45699, 50105, 0,
  0, 0, 956, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1851, 0, 90538, 90538, 90538, 90538, 90538, 1611, 1394, 1612, 1396, 1613, 1398,
  1614, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95660, 94734, 94734, 94734, 94734, 94734,
  0, 0, 325, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 273, 0, 0, 0, 0, 273, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  678, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 333, 82177, 82177, 0, 0, 0, 0, 0, 0, 151552, 266, 267, 0,
  269, 270, 0, 208896, 0, 0, 2204256, 151552, 2204256, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288, 327, 0, 327, 355, 0,
  753, 753, 753, 753, 753, 753, 753, 753, 521, 522, 523, 524, 813, 814, 814, 814, 814, 814, 814, 0, 0, 0, 0, 0, 0, 0,
  753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 0, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753,
  753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 1111, 0, 0, 1111, 1116, 0, 0, 1116, 0, 0, 814, 814, 547, 548, 0, 0,
  0, 4, 82177, 0, 0, 0, 0, 0, 0, 0, 0, 2087, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95012, 521, 522, 523, 524,
  0, 94734, 94734, 94734, 814, 1116, 0, 0, 1116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 931, 0, 0, 0, 0, 753, 753, 753, 753,
  753, 753, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 288, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753,
  753, 753, 753, 0, 0, 0, 0, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 0, 0, 0, 0, 0, 0, 753,
  753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 814, 814, 814, 814, 814, 814, 753, 753, 753, 814, 814, 814, 814,
  814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 0, 0, 0, 753, 753, 753, 814, 814, 814, 814, 814, 814, 814, 814, 814,
  814, 0, 0, 0, 0, 0, 0, 0, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 814, 814, 814, 814, 814, 814, 814, 814,
  814, 0, 0, 0, 0, 753, 753, 753, 753, 753, 753, 814, 814, 814, 814, 814, 814, 0, 0, 0, 753, 753, 753, 753, 814, 814,
  814, 814, 0, 753, 753, 814, 814, 753, 814, 753, 814, 753, 814, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 349, 0, 0,
  323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088, 217088, 217088, 1, 16386, 3, 4, 0, 0, 217088, 217088, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 934, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 217088, 0, 0, 0, 0, 361, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 586, 0, 0, 0, 0, 217088, 217088, 217088, 217088, 217088, 0, 0, 0, 0, 0, 217088, 217088,
  217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 0, 0,
  547, 0, 548, 266, 0, 267, 0, 269, 0, 270, 0, 0, 0, 0, 0, 0, 1474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1271, 0, 0, 0, 0, 0, 0,
  0, 522, 0, 523, 0, 524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 300, 301, 0, 0, 0, 0, 0, 547, 0, 548, 0, 266, 267, 269, 270, 0,
  0, 0, 0, 0, 0, 0, 0, 50105, 0, 0, 956, 1260, 0, 0, 0, 0, 221590, 221590, 221590, 221590, 0, 0, 0, 0, 0, 221590,
  221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590, 221590,
  221590, 221590, 221590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 975, 0, 221734, 221734, 221734, 221734, 221734,
  221734, 221734, 221734, 221734, 221590, 221590, 221735, 1, 16386, 3, 4, 0, 0, 547, 548, 0, 0, 237568, 4, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1928, 0, 0, 0, 0, 0, 0, 0, 249856, 249856, 249856, 249856, 0, 0, 0, 0, 0, 249856, 249856, 249856,
  249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856, 249856,
  249856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 989, 0, 212992, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0,
  0, 0, 114688, 0, 241664, 258048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770048, 0, 0, 0, 0, 0, 0, 0, 547, 548, 0, 0, 241664, 4,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1934, 0, 0, 0, 0, 0, 0, 0, 254359, 254359, 254359, 254359, 0, 0, 0, 0, 0, 254359, 254359,
  254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359, 254359,
  254359, 254359, 0, 0, 0, 0, 253952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978944, 0, 90538, 91652, 90538, 90538, 0, 0, 547,
  548, 0, 0, 0, 0, 0, 180224, 290816, 0, 0, 0, 0, 0, 0, 0, 94734, 95823, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 95997, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95836, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 0, 0, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 0, 0, 266240, 0, 0, 266240, 0, 0, 0, 547, 548, 0, 245760,
  245760, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2007, 0, 0, 0, 0, 0, 0, 274432, 274432, 274432, 274432, 274432, 274432, 274432,
  274432, 274432, 0, 0, 274432, 1, 16386, 3, 4, 90538, 0, 94708, 94708, 94708, 94708, 94708, 94734, 94708, 94734, 94708,
  94708, 94708, 94708, 94708, 94708, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94734, 94734, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1250, 0, 1611, 0, 1612, 0, 1613, 0, 1614, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 95851, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 1265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 287, 0, 0,
  1517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 575, 82177, 82473, 0, 0, 0, 0, 0, 0, 0, 266, 267, 0, 269, 270, 0,
  0, 0, 0, 639, 0, 0, 0, 0, 0, 645, 0, 0, 0, 0, 649, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 384, 0, 0, 0, 0,
  650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 762445, 0, 0, 0, 0, 0, 0, 0, 278528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302,
  303, 304, 305, 282624, 282624, 282624, 282624, 282624, 282624, 282624, 282624, 0, 282624, 282624, 0, 282624, 282624,
  0, 282624, 282624, 282624, 282624, 0, 0, 0, 0, 0, 0, 0, 282624, 0, 0, 0, 0, 0, 564, 0, 0, 0, 0, 0, 0, 0, 0, 0, 660,
  282624, 282624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1261, 0, 0, 964, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1277, 1278, 1, 16386, 3, 256, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 0, 0, 0, 96323, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 94734, 94734, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286720, 286720, 0,
  286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720,
  286720, 286720, 286720, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1480, 0, 0, 0, 547, 548, 0, 0, 0, 4219432,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 45699, 0, 0, 0, 0, 0, 0, 274, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1720, 0, 0, 0,
  323, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 0, 275, 0, 274, 274,
  275, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90815, 90538, 90538, 0, 73728, 77824, 275, 0, 274, 0,
  0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 487424, 0, 0, 0, 0, 0, 0, 0, 0, 737280, 0, 0, 0, 0, 0, 0, 0, 266, 0, 267, 0, 269, 0,
  270, 0, 0, 395, 408, 408, 408, 408, 90539, 90539, 90539, 90539, 90539, 445, 445, 408, 445, 445, 445, 445, 445, 445,
  470, 481, 470, 470, 470, 470, 470, 470, 470, 470, 491, 470, 470, 491, 470, 470, 491, 90539, 90539, 470, 94709, 94709,
  94709, 94709, 94709, 94735, 94709, 94735, 94709, 94709, 94709, 94709, 94709, 94709, 94735, 94735, 94735, 94735, 94735,
  94735, 94735, 94735, 94735, 94709, 94709, 94735, 1, 16386, 3, 4, 0, 681, 0, 0, 0, 0, 0, 0, 685, 0, 0, 0, 0, 0, 0, 586,
  90538, 90538, 90538, 90538, 90538, 90538, 90828, 90538, 90830, 90538, 90538, 90538, 0, 566, 0, 0, 0, 0, 666, 0, 0,
  670, 0, 0, 0, 0, 676, 0, 0, 0, 0, 0, 565, 651, 652, 653, 0, 0, 0, 0, 0, 659, 0, 639, 681, 0, 94708, 94708, 94708,
  94968, 94708, 94708, 94708, 94708, 94708, 94987, 94708, 94990, 94708, 94708, 94708, 95583, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96100, 94734, 94734, 94734, 94734, 94994, 94708, 94997, 94708,
  94708, 95008, 94708, 94708, 521, 522, 523, 524, 0, 94734, 94734, 94734, 94734, 94734, 94734, 352256, 2160, 0, 0, 0, 0,
  0, 96372, 94708, 492020, 95029, 94734, 94734, 94734, 94734, 94734, 95048, 94734, 95051, 94734, 95055, 94734, 95058,
  94734, 94734, 95069, 0, 0, 909, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  569344, 0, 0, 0, 1290, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91412, 90538, 90538, 90538, 90538,
  90538, 90538, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 373236, 94708, 94708, 94708, 94708,
  90538, 90538, 90538, 90538, 90538, 90538, 91421, 90538, 90538, 90538, 90538, 90538, 91428, 90538, 90538, 90538, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 95951, 0, 0, 1332, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 95546, 94708,
  94708, 94708, 94708, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 94734, 94734, 94708, 95581, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95591, 94708, 94708, 94708, 94734, 96188, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 96195, 569870, 94734, 94734, 547, 548, 0, 0, 0, 4, 257, 0, 0, 0, 872, 874, 0, 0, 0,
  0, 565, 0, 0, 0, 568, 569, 570, 571, 572, 0, 0, 0, 0, 0, 1847, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 91416, 29793, 94734, 94734, 94734, 94734, 94734, 95613, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96111, 94734, 94734, 94734, 94734, 94734, 95622, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95392, 1468, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 0, 1507, 0, 1509, 0, 0, 0, 0, 0, 1515, 0, 1260, 0, 0, 0, 0, 0, 0, 1512, 0, 0, 0,
  557056, 0, 413696, 0, 0, 0, 91655, 91656, 90538, 90538, 90538, 90538, 90538, 90538, 91660, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 0, 0, 0, 0, 0, 552960, 0, 0, 0, 94708, 95783, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 34159, 0, 95795, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 95804, 94708, 94708, 94708, 95808, 94708, 94708, 94708, 95004, 94708, 94708, 95010, 94708, 521, 522, 523, 524,
  0, 94734, 94734, 95028, 1611, 0, 1612, 0, 1613, 0, 1614, 94734, 94734, 94734, 94734, 94734, 94734, 95828, 94734,
  94734, 547, 548, 0, 0, 0, 4, 82177, 0, 0, 0, 0, 0, 0, 0, 0, 944, 0, 0, 0, 0, 0, 0, 0, 0, 969, 0, 0, 0, 0, 974, 0, 0,
  95829, 94734, 95831, 94734, 95832, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0,
  0, 0, 1805, 94734, 94734, 94734, 95844, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95853, 94734, 94734,
  94734, 94734, 94734, 94734, 696846, 94734, 95998, 94734, 94734, 94734, 94734, 94734, 94734, 840206, 95857, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95664, 1669, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 864256, 0, 0, 0, 0, 0, 595, 596, 597, 598, 0, 0, 0, 0, 0, 0, 0, 1042, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1032192, 0, 0, 0, 0, 0, 0, 0, 1681, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1816, 0, 94708, 94708, 95975,
  94708, 94708, 94708, 94708, 94708, 95979, 94708, 1611, 1612, 1613, 1614, 94734, 94734, 547, 548, 0, 0, 0, 4, 82177, 0,
  0, 0, 872, 874, 0, 0, 0, 0, 521, 0, 0, 0, 523, 0, 0, 0, 0, 0, 0, 0, 0, 649, 958, 887, 0, 0, 0, 0, 0, 94734, 94734,
  94734, 96006, 94734, 94734, 94734, 94734, 94734, 96010, 94734, 1660, 1661, 0, 0, 0, 0, 0, 624, 0, 0, 627, 0, 0, 0, 0,
  0, 0, 0, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1702, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1807, 0, 0, 0, 0, 0, 1811, 0, 0, 0, 0, 0, 0,
  0, 1809, 1810, 0, 0, 0, 1814, 0, 0, 0, 0, 1819, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1827, 0, 0, 0, 0, 0, 640, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 649, 0, 0, 0, 0, 0, 0, 961, 0, 0, 1844, 1845, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 467370, 90538, 90538, 90538, 90538, 91972, 90538, 90538, 0, 0, 0, 0, 1866, 0, 94708, 94708, 94708,
  94708, 94734, 94734, 94734, 94734, 0, 94708, 94708, 94734, 94734, 94708, 94734, 94708, 96171, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96182, 94708, 94708, 94708, 95798, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95807, 94708, 94708, 94708, 0, 0, 0, 2112, 0, 2114, 0,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95587, 94708, 94708, 94708, 94708, 94708, 94708, 2140,
  0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 96311,
  94734, 94734, 94734, 94734, 0, 389120, 0, 0, 2177, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734,
  94734, 94734, 94734, 0, 1187, 0, 1189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 947, 0, 0, 0, 0, 0, 0, 276, 277, 278, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1222, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 374, 0, 69632, 0, 0, 374, 0, 0, 0, 0, 0, 0, 1522,
  0, 1524, 0, 0, 0, 0, 0, 0, 0, 363, 0, 0, 0, 0, 0, 0, 363, 0, 396, 0, 0, 0, 0, 90540, 90540, 90540, 90540, 90540, 396,
  396, 374, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 90540, 90540, 396, 94710,
  94710, 94710, 94710, 94710, 94736, 94710, 94736, 94710, 94710, 94710, 94710, 94710, 94710, 94736, 94736, 94736, 94736,
  94736, 94736, 94736, 94736, 94736, 94710, 94710, 94736, 1, 16386, 3, 4, 0, 0, 0, 90538, 90538, 91837, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90836, 0, 0, 0, 0, 94708, 94708, 95952, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95290, 94708, 94708, 95982, 94734, 94734,
  95983, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95059, 94734, 94734, 94734,
  0, 0, 94708, 94708, 94708, 94708, 96353, 94708, 96355, 94708, 96357, 94708, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 0, 0, 2137, 0, 0, 96362, 94734, 96364, 94734, 96366, 94734, 0, 0, 0, 0, 0, 0, 0, 94708,
  94708, 94708, 94708, 96327, 94708, 96329, 96330, 96331, 0, 73728, 77824, 0, 284, 0, 375, 376, 69632, 376, 383, 375,
  383, 0, 279, 383, 397, 409, 409, 409, 424, 90541, 90541, 90541, 90541, 90541, 446, 446, 455, 446, 446, 446, 446, 446,
  446, 471, 446, 471, 471, 485, 486, 485, 486, 486, 486, 486, 486, 486, 486, 486, 471, 486, 486, 471, 486, 486, 471,
  90541, 90541, 486, 94711, 94711, 94711, 94711, 94711, 94737, 94711, 94737, 94711, 94711, 94711, 94711, 94711, 94711,
  94737, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94737, 94711, 94711, 94737, 1, 16386, 3, 4, 635, 0, 0, 0, 0,
  0, 593, 0, 0, 0, 0, 0, 0, 0, 0, 649, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 94998, 94708, 94708, 94708, 94708, 94708, 521,
  522, 523, 524, 0, 94734, 94734, 94734, 94734, 94734, 94734, 754190, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95999, 94734, 94734, 94734, 94734, 96003, 94734, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 888, 0, 0, 0,
  0, 0, 731, 0, 687, 0, 0, 0, 0, 731, 0, 0, 0, 0, 0, 896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 600, 601, 0, 0, 603, 0, 0, 922,
  888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0, 978, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 989, 90538,
  90538, 91119, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91665,
  90538, 95254, 94708, 95256, 95257, 94708, 94708, 94708, 94708, 94708, 94708, 95269, 94708, 95273, 94708, 94708, 94708,
  94708, 95799, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95810, 94708, 95278, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 34159, 1392, 95332, 94734, 94734,
  94734, 94734, 94734, 94734, 95344, 94734, 95348, 94734, 94734, 94734, 94734, 95353, 94734, 0, 1187, 1189, 0, 0, 0,
  872, 0, 874, 0, 876, 0, 878, 1198, 0, 0, 0, 0, 516096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 778240, 0, 0, 0, 0, 0, 1200,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1929, 0, 0, 0, 0, 1255, 0, 0, 0, 0, 0, 0, 0, 0, 1260, 0, 0, 0, 0, 0, 911, 0,
  0, 649, 0, 0, 0, 0, 960, 0, 0, 0, 0, 0, 1282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 95565, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95577, 94708, 94708, 94708, 95953, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 520692, 94708, 94708, 94708, 95553, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95961, 94708, 94708, 94708, 95579, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95563, 94708, 29793, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 95615, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95383, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 860686, 94734, 94734, 889358, 94734, 94734, 2046, 0, 94734, 94734, 95624, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 95632, 94734, 94734, 94734, 94734, 94734, 94734, 95627, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95636, 96004, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 1660, 1661, 0, 0, 0, 0, 0, 912, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 323, 0, 0, 0, 611, 0, 613, 0, 0, 0, 0, 0, 0,
  0, 135168, 0, 0, 0, 0, 1, 16386, 3, 4, 90538, 91970, 90538, 90538, 90538, 91974, 0, 1864, 0, 0, 0, 1867, 94708, 94708,
  94708, 94708, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 94734, 95331, 0, 0, 1923, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 753, 753, 753, 753, 753, 90538, 90538, 92063, 90538, 90538, 90538, 0, 0, 0, 0, 0, 94708, 94708, 94708,
  94708, 94708, 94708, 95779, 94708, 94708, 95780, 94708, 95782, 96197, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1664, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 96352, 94708, 94708,
  94708, 94708, 94708, 94708, 94734, 94734, 94734, 96361, 0, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 0,
  94708, 96415, 94734, 96416, 94708, 94734, 94708, 94734, 94708, 94734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  286, 0, 0, 350, 287, 0, 0, 0, 0, 287, 0, 0, 0, 0, 0, 0, 286, 0, 73728, 77824, 0, 0, 0, 329, 0, 69632, 0, 0, 329, 0,
  385, 391, 0, 0, 0, 0, 544768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1813, 0, 0, 0, 0, 398, 410, 410, 410, 410, 90542,
  90542, 90542, 90542, 90542, 447, 447, 456, 447, 447, 447, 447, 447, 447, 472, 447, 472, 472, 472, 472, 472, 472, 472,
  472, 472, 472, 472, 472, 472, 472, 472, 90542, 90542, 472, 94712, 94712, 94712, 94712, 94712, 94738, 94712, 94738,
  94712, 94712, 94712, 94712, 94712, 94712, 94738, 94738, 94738, 94738, 94738, 94738, 94738, 94738, 94738, 94712, 94712,
  94738, 1, 16386, 3, 4, 90538, 90822, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 689, 0, 0, 0, 0, 0, 0, 0, 0, 0, 689, 0, 0, 0, 0, 0, 966, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0,
  0, 0, 0, 0, 499712, 0, 0, 0, 0, 0, 0, 898, 0, 0, 901, 0, 903, 904, 0, 0, 0, 0, 688, 0, 0, 0, 0, 90538, 90538, 90538,
  90538, 90538, 90819, 90538, 936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 648, 0, 0, 688128, 0, 0, 689026, 0,
  90538, 315818, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 1559, 0, 0, 0, 0, 90538, 500138, 90538,
  90538, 90538, 90538, 90538, 90538, 689140, 90538, 91126, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0,
  94708, 94708, 94708, 94708, 96170, 95254, 94708, 315892, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 500212, 95293, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 95793, 95794, 91431, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1040384, 0, 0, 0, 0, 0, 1112,
  1114, 0, 0, 1117, 1119, 0, 0, 0, 0, 0, 0, 0, 94734, 94734, 94734, 95825, 94734, 94734, 94734, 94734, 94734, 94734,
  95340, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 1049102, 0, 0, 0, 0, 0, 1611, 0, 1612, 0,
  1613, 0, 1614, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 377358, 0, 0, 0, 91836, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 91969, 90538, 90538, 90538, 90538, 90538,
  0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 2191, 0, 0,
  94708, 94708, 94708, 94708, 94708, 96354, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 393742,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 95628, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95988,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96363, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 0, 94708,
  94708, 94708, 95776, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 324401,
  94734, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 649, 0, 327, 0, 328, 0, 0, 0, 0, 0, 0, 288, 328, 290, 290,
  327, 0, 0, 0, 0, 689110, 0, 0, 0, 0, 315392, 0, 0, 0, 0, 0, 0, 0, 1834, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37420, 267, 0,
  53808, 270, 0, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 289, 0, 0, 289, 399, 411, 421, 411, 411, 90543,
  90543, 90543, 90543, 90543, 448, 448, 411, 448, 448, 448, 463, 465, 448, 448, 463, 473, 448, 473, 473, 473, 473, 473,
  473, 473, 473, 492, 473, 473, 492, 473, 473, 492, 90543, 90543, 473, 94713, 94713, 94713, 94713, 94713, 94739, 94713,
  94739, 94713, 94713, 94713, 94713, 94713, 94713, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94739, 94713,
  94713, 94739, 1, 16386, 3, 4, 0, 591, 592, 0, 594, 0, 0, 0, 0, 599, 0, 0, 0, 0, 0, 0, 0, 2053, 2054, 0, 0, 2056, 0, 0,
  0, 90538, 0, 620, 0, 0, 0, 0, 0, 0, 0, 628, 0, 0, 0, 632, 0, 0, 0, 0, 730, 0, 685, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  991232, 0, 0, 0, 0, 0, 661, 0, 0, 0, 667, 668, 0, 0, 0, 0, 0, 675, 0, 677, 0, 0, 0, 0, 749, 750, 0, 0, 681, 0, 0, 0,
  0, 0, 742, 0, 573866, 90538, 660168, 90538, 713130, 90538, 90538, 90829, 90831, 90538, 90538, 90538, 0, 0, 677, 0, 0,
  0, 0, 929792, 724992, 0, 0, 0, 0, 0, 0, 1052672, 0, 0, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1327, 0, 0, 0, 0, 0, 0,
  696320, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 37423, 0, 269, 53811, 0, 0, 573440, 0, 660111, 0, 0, 0, 0, 611, 0, 0, 0,
  712704, 735, 0, 0, 0, 0, 0, 1216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0, 735, 735, 738, 0, 0, 677, 0,
  0, 0, 0, 0, 743, 0, 0, 0, 0, 895, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1274, 0, 0, 0, 0, 660111, 743, 0, 94708, 94708,
  94966, 94708, 94971, 94708, 94708, 573940, 94708, 660236, 94708, 713204, 94708, 94708, 94708, 95965, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 95971, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 96190, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95658, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94708, 94996, 94999,
  95003, 94708, 94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 94734, 95027, 94734, 95032, 94734, 94734, 573966,
  94734, 660297, 94734, 713230, 94734, 94734, 95057, 95060, 95064, 94734, 94734, 547, 548, 188416, 0, 0, 4, 82177, 0, 0,
  0, 0, 0, 0, 0, 0, 1207, 0, 0, 0, 0, 0, 0, 0, 0, 1231, 0, 0, 0, 0, 0, 0, 0, 0, 1244, 0, 0, 0, 0, 0, 0, 0, 0, 1263, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 604, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 890, 0, 0, 0, 0, 966656,
  0, 303104, 0, 0, 0, 0, 1936, 0, 0, 0, 0, 0, 0, 1833, 0, 1835, 0, 0, 0, 0, 1840, 0, 0, 0, 0, 0, 910, 0, 0, 0, 914, 915,
  0, 917, 0, 0, 0, 323, 323, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 617, 0, 0, 952, 644, 0, 0, 910, 0, 0, 649, 0, 0, 0, 0, 0,
  0, 0, 352, 0, 0, 0, 0, 0, 0, 0, 0, 298, 299, 0, 0, 0, 0, 0, 0, 962, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 976,
  0, 0, 0, 993, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 91130, 90538, 90538, 91133, 90538, 91135, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 281,
  95254, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95274, 94708, 94708, 94708,
  95006, 94708, 94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 94734, 94734, 94734, 94734, 96201, 96203, 96204,
  94734, 96206, 995854, 0, 0, 0, 2001, 0, 95277, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95287, 94708,
  94708, 94708, 94708, 94708, 94708, 34159, 1393, 1113, 1395, 1115, 34159, 1397, 1118, 1399, 1120, 94708, 94708, 95295,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95310, 94708, 94708, 94708, 94708, 95814, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 34159, 0, 0, 0, 0, 34159, 0, 0, 0, 0, 95315, 94708, 94708, 94708, 0,
  1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 94734, 94734, 94734, 94734, 94734, 96248, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 0, 0, 0, 0, 911, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 323, 0, 0, 0, 0, 612, 0, 0, 0, 616,
  0, 0, 360448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1211, 0, 0, 0, 0, 0, 1228, 1229, 1230, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  94708, 94708, 94708, 94708, 94708, 96301, 94708, 1213, 0, 0, 1215, 733184, 0, 1217, 1218, 0, 0, 1221, 0, 0, 0, 0, 0,
  0, 0, 295438, 94734, 94734, 94734, 95826, 95827, 94734, 94734, 94734, 1237, 0, 0, 0, 0, 734425, 0, 1243, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 94708, 96297, 94708, 94708, 94708, 94708, 94708, 0, 1253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1260, 970752,
  0, 0, 0, 0, 924, 925, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1526, 0, 1528, 1529, 294912, 0, 1279, 1280, 0, 0, 483328, 0, 0, 0,
  0, 0, 0, 0, 1287, 0, 0, 1289, 0, 0, 0, 91405, 91406, 90538, 360874, 90538, 90538, 90538, 90538, 90538, 483754, 90538,
  91415, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 0, 0, 296, 297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286720, 286720,
  286720, 1, 16386, 3, 4219432, 90538, 90538, 91418, 90538, 90538, 91420, 90538, 90538, 90538, 90538, 90538, 91427,
  90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 919, 1032, 0, 0, 0, 0, 0, 0, 1685, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  672, 0, 0, 0, 0, 0, 0, 90538, 0, 0, 0, 1323, 856064, 0, 0, 0, 0, 0, 0, 0, 0, 1289, 0, 0, 0, 266, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 749568, 0, 0, 0, 1331, 0, 360448, 360448, 95254, 95541, 95542, 95543, 94708, 94708, 94708, 360948,
  94708, 94708, 94708, 94708, 95954, 94708, 94708, 94708, 94708, 95958, 94708, 95960, 94708, 94708, 94708, 94708, 95007,
  94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 95024, 94734, 29793, 95608, 95609, 95610, 94734, 94734, 94734,
  360974, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 689284, 94734, 95366, 94734, 95368, 94734,
  94734, 94734, 95623, 94734, 94734, 94734, 483854, 94734, 94734, 95629, 94734, 94734, 94734, 94734, 94734, 94734,
  95635, 95637, 94734, 94734, 94734, 95640, 733710, 94734, 95641, 95643, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 95848, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96205, 94734, 94734, 0, 0, 2000, 0, 0, 95652,
  94734, 94734, 901646, 94734, 94734, 94734, 95657, 94734, 95659, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  96108, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 467470, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 95665, 0, 1187, 0, 1189, 0, 1462, 0, 1463, 0, 1464, 0, 1465, 0, 0, 0, 0, 0, 1283, 0, 1284, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 282624, 282624, 0, 1, 16386, 3, 4, 0, 0, 1470, 1471, 0, 0, 0, 1475, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110996, 110996,
  404, 1, 16386, 3, 4, 0, 1532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1471, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0,
  1865, 0, 0, 96076, 94708, 94708, 94708, 90538, 90538, 90538, 90538, 91658, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 91666, 90538, 90538, 90538, 90538, 90538, 1020330, 90538, 1556, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  122880, 122880, 0, 2109693, 16386, 3, 4, 0, 1564, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 95781, 94708, 94708, 94708, 96093, 94708, 94708, 94708, 94708, 94708, 94708, 96099, 94734, 94734, 94734, 94734,
  94734, 94734, 95362, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95370, 94708, 95812, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 1020404, 94708, 94708, 34159, 0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1223, 0, 0, 0, 0, 0, 0, 0, 94734, 95830, 94734, 94734, 94734, 94734, 94734, 95835, 94734, 95837, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 96250, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 90538, 344490,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 507904, 90538, 90538,
  905642, 0, 0, 503808, 0, 0, 0, 0, 0, 0, 802816, 94708, 94708, 94708, 94708, 96175, 569844, 94708, 94708, 94708, 94708,
  96179, 94708, 94708, 94708, 94708, 94708, 95585, 94708, 94708, 901620, 94708, 94708, 94708, 95590, 94708, 95592,
  94708, 344564, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 434676, 94708, 95959, 94708, 94708, 94708, 94708,
  94708, 95282, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95308, 94708, 94708, 94708, 94708,
  94708, 94734, 344590, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 434702, 94734, 95990, 94734, 94734, 94734,
  94734, 94734, 94734, 95847, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 489054, 512526,
  94734, 94734, 94734, 94734, 425984, 823296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 90538, 90538, 91971,
  90538, 90538, 90538, 1863, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94981, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 823796, 94708, 94708, 844276, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734,
  94734, 94734, 94734, 96191, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 426510, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 96112, 94734, 94734, 94734, 94734, 94734, 94734, 95986, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 96252, 94734, 94734, 94734, 0, 0, 823822, 94734, 94734, 844302, 94734,
  94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 815104, 1931, 0, 884736, 0, 1933, 0, 0,
  1003520, 0, 0, 0, 0, 0, 0, 0, 522, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 647168, 0, 0, 0, 0, 1946, 368640, 0, 626688, 0,
  90538, 369066, 90538, 90538, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96232, 94708, 94708, 94708,
  95280, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95292, 90538, 627114, 90538,
  90538, 92065, 92066, 0, 462848, 0, 0, 1958, 94708, 94708, 94708, 369140, 94708, 94708, 94708, 96174, 94708, 94708,
  627188, 94708, 94708, 94708, 94708, 94708, 94708, 96181, 96183, 96184, 94708, 96186, 995828, 94734, 94734, 94734,
  369166, 94734, 94734, 94734, 94734, 96194, 94734, 94734, 627214, 94734, 0, 1660, 0, 1661, 1462, 1463, 1464, 1465, 0,
  0, 0, 0, 0, 0, 0, 0, 221566, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 45699, 41322, 0, 0, 0, 0, 0, 0, 0,
  0, 704512, 0, 880640, 2005, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 629, 0, 0, 0, 0, 0, 0, 0, 794624, 0, 0, 675840, 987136, 0,
  0, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91844, 90538, 706538, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 336398, 94734, 94734, 94734, 94734, 94734,
  94734, 909838, 94734, 94734, 958990, 94734, 94734, 94734, 94734, 94734, 94734, 95339, 95346, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 95642, 94734, 94734, 94734, 95648, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  706551, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 417792, 872448, 0, 0, 0, 94708, 94708,
  94708, 90538, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96275, 94708, 94708,
  94708, 96237, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 381454, 96242, 96243, 0, 618496, 0,
  729088, 0, 0, 2085, 0, 0, 94708, 94708, 94708, 96299, 94708, 94708, 94708, 94708, 692724, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 934388, 94708, 94708, 94708, 94708, 0, 0, 0, 0, 94734, 94734, 0, 0,
  2111, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734,
  96332, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96342, 0, 0, 0, 0, 0, 0, 0, 819200, 0, 0, 0, 0,
  0, 0, 0, 0, 364, 275, 0, 0, 0, 275, 0, 0, 0, 0, 94708, 94708, 475636, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94734, 94734, 475662, 94734, 0, 1660, 0, 1661, 1462, 1463, 1464, 1465, 0, 1663, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0,
  0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 94708, 709108, 94708, 94708, 94708, 94708,
  96378, 94734, 492046, 94734, 709134, 94734, 94734, 94734, 94734, 0, 1187, 0, 1189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  372736, 0, 0, 94708, 96402, 94708, 94708, 94708, 868852, 94734, 96406, 94734, 94734, 94734, 868878, 0, 0, 0, 0, 965,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1260, 0, 0, 0, 1019904, 0, 291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0,
  0, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 985, 366, 73728, 77824, 0, 330, 334, 0, 377, 69632, 377, 377,
  291, 377, 0, 0, 377, 0, 0, 0, 330, 90544, 90544, 90544, 90544, 90544, 377, 377, 457, 459, 459, 459, 464, 459, 459,
  459, 464, 377, 459, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 494, 90544, 90544, 496,
  94714, 94714, 94714, 94714, 94714, 94740, 94714, 94740, 94714, 94714, 94714, 94714, 94714, 94714, 94740, 94740, 94740,
  94740, 94740, 94740, 94740, 94740, 94740, 94714, 94714, 94740, 1, 16386, 3, 4, 673, 0, 0, 0, 0, 0, 0, 0, 0, 0, 673, 0,
  0, 0, 0, 0, 0, 287, 0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 1823, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 94708, 94962, 94708, 94708, 94708, 94708, 94708, 94708, 598516, 94708, 94708, 94708, 94708, 0, 1113, 1115, 0, 0,
  1118, 1120, 0, 29793, 95254, 94734, 315918, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 889, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 920, 323, 323, 0, 0, 979, 0, 889, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1490, 0, 0, 0, 0, 90538, 90538, 90538,
  90538, 90538, 90538, 1026, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 304, 343, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708,
  95259, 94708, 94708, 94708, 94708, 95270, 94708, 94708, 94708, 94708, 94708, 95302, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 0, 0, 0, 0, 95980, 94734, 94734, 94734, 95334, 94734, 94734, 94734, 94734, 95345,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 963086, 94734, 94734, 94734, 94734, 94734, 94734,
  90538, 1320, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 94734, 877070, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 1533, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90538,
  90538, 90538, 90538, 90538, 90816, 90538, 94708, 94708, 95797, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 95575, 94708, 94708, 91845, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95974, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 1611, 1612, 1613, 1614, 94734, 94734, 94734, 94734, 94734, 96280, 96281, 94734, 96282, 94734, 94734, 94734,
  94734, 0, 0, 0, 0, 963, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 637, 0, 94734, 94734, 96005, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 1660, 1661, 0, 0, 0, 0, 0, 1486, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 930, 0, 932, 0, 0,
  0, 0, 0, 311796, 94708, 94708, 94708, 94708, 94708, 311822, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 1203, 1204,
  0, 0, 0, 0, 1209, 0, 0, 0, 0, 0, 0, 1205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1489, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708,
  94708, 94734, 94734, 94734, 94734, 0, 442868, 94708, 442894, 94734, 94708, 94734, 94708, 94734, 827892, 827918, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1273, 0, 1275, 0, 0, 0, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1225, 0, 73728,
  77824, 0, 0, 0, 0, 378, 69632, 378, 378, 0, 378, 386, 0, 378, 412, 412, 412, 412, 90545, 90545, 90545, 90545, 90545,
  449, 449, 412, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 90545, 90545, 449,
  94715, 94715, 94715, 94715, 94715, 94741, 94715, 94741, 94715, 94715, 94715, 94715, 94715, 94715, 94741, 94741, 94741,
  94741, 94741, 94741, 94741, 94741, 94741, 94715, 94715, 94741, 1, 16386, 3, 4, 1563, 0, 0, 0, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95561, 94708, 94708, 94708, 0, 1843, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 774144, 0, 0, 913408, 0, 0, 0, 0,
  495616, 0, 0, 0, 0, 0, 0, 1714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 267, 0, 269, 270, 0, 0, 1940, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 90538, 90538, 90538, 90538, 92129, 2011, 0, 0, 0, 0, 0, 0, 327680, 0, 0, 0, 328106, 90538, 90538, 90538,
  90538, 90538, 90538, 0, 0, 1036288, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94974, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 95586, 94708, 94708, 95589, 938484, 94708, 94708, 94708, 94708, 94708, 94708, 808940, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94734, 328206, 94734, 94734, 94734, 94734, 94734, 94734, 96120, 94734,
  94734, 94734, 0, 0, 0, 1918, 0, 0, 94734, 94734, 534518, 94734, 94734, 94734, 808953, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 0, 0, 0, 0, 1240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323584, 0, 0, 0, 649, 90538, 0, 0, 94708,
  94708, 446964, 94708, 94708, 94708, 94708, 94708, 94708, 96273, 94708, 94708, 94708, 94708, 860660, 94708, 94708,
  889332, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 2139, 94734,
  94734, 446990, 94734, 94734, 94734, 94734, 94734, 94734, 96283, 94734, 94734, 94734, 0, 0, 0, 0, 0, 1498, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1233, 0, 0, 0, 0, 0, 0, 94708, 537076, 811508, 94708, 94734, 537102, 811534, 94734, 0, 94708, 94708,
  94734, 94734, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 2135, 2136, 0, 0, 0, 0, 0,
  941, 0, 0, 0, 945, 0, 0, 0, 0, 0, 950, 0, 0, 657, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 657, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 988, 0, 0, 0, 747, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 0, 0, 0,
  94708, 94708, 94708, 94969, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96098, 94708, 94734, 94734,
  94734, 94734, 94734, 95030, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95856, 95070, 94734, 547, 548, 0, 0, 0, 4, 82177, 0, 0, 0, 872, 874, 0, 0, 0, 0, 1266, 1267, 0, 1269, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 254359, 254359, 254359, 1, 16386, 0, 4, 907, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323,
  323, 0, 0, 0, 0, 0, 0, 0, 615, 0, 0, 0, 94734, 94734, 95377, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 95067, 94734, 94734, 90538, 0, 0, 0, 0, 0, 1033516, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557,
  558, 0, 561, 562, 0, 0, 90538, 90538, 0, 0, 2019, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 1611, 1612, 1613, 1614, 94734, 94734, 94708, 96235, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 90538, 2057, 0, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 975348, 0, 0, 292, 293, 294, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 673,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 336, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 631, 0, 0, 0, 612, 0, 616, 0, 0,
  351, 0, 0, 0, 0, 0, 0, 0, 0, 0, 292, 0, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 387, 0,
  0, 0, 0, 1472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 576, 0, 0, 0, 0, 294, 413, 413, 413, 413, 90546, 90546, 90546, 90546,
  90546, 450, 450, 413, 450, 450, 450, 450, 450, 450, 474, 450, 483, 483, 483, 483, 483, 483, 483, 483, 493, 483, 483,
  493, 483, 483, 493, 90546, 90546, 483, 94716, 94716, 94716, 94716, 94716, 94742, 94716, 94742, 94716, 94716, 94716,
  94716, 94716, 94716, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94742, 94716, 94716, 94742, 1, 16386, 3,
  4, 605, 0, 323, 323, 323, 0, 0, 0, 0, 0, 0, 614, 0, 0, 0, 0, 0, 0, 98567, 102664, 0, 266, 267, 0, 269, 270, 0, 0, 662,
  0, 0, 665, 0, 0, 669, 0, 0, 0, 0, 0, 0, 0, 0, 0, 584, 585, 0, 587, 0, 0, 0, 0, 0, 683, 0, 0, 0, 0, 0, 0, 687, 0, 0, 0,
  0, 0, 0, 0, 90538, 90538, 91109, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 1033, 0, 0, 0, 0, 0, 731,
  731, 0, 0, 0, 687, 0, 0, 0, 0, 0, 0, 744, 683, 0, 0, 744, 94708, 94708, 94967, 94708, 94972, 94708, 94979, 94708,
  94708, 94708, 94708, 94708, 94708, 94734, 96379, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 94734, 95033,
  94734, 95040, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95065, 94734, 94734, 94734, 94734, 94734,
  598542, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 1916, 0, 0, 0, 0, 95071, 94734, 547,
  548, 0, 0, 0, 4, 82177, 0, 0, 0, 872, 874, 0, 0, 0, 0, 1485, 0, 0, 1487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1065380, 1065380,
  1065380, 1, 16386, 3, 4, 990, 0, 0, 0, 994, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90833, 90538, 90837, 0, 0, 727, 0, 90538, 90538, 90538, 90538, 90538, 91121, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 91425, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91134, 90538, 90538, 90538, 0, 0,
  0, 0, 0, 0, 0, 0, 1035, 0, 0, 0, 309, 0, 0, 0, 0, 0, 0, 0, 0, 346, 347, 0, 348, 95254, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 95263, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95557, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 95023, 94734, 94708, 94708, 95296, 94708, 94708, 94708, 94708,
  94708, 94708, 95307, 94708, 94708, 94708, 94708, 95312, 94708, 94708, 94708, 96376, 94708, 94708, 94734, 94734, 94734,
  94734, 94734, 94734, 96382, 94734, 94734, 409600, 94734, 94734, 94734, 95358, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95371, 0, 1238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1247, 0, 0, 0, 0, 0, 0, 131072,
  0, 0, 0, 0, 0, 0, 131072, 0, 0, 90538, 90538, 90538, 91419, 90538, 90538, 90538, 90538, 91423, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 0, 0, 1558, 767453, 0, 0, 0, 1561, 0, 90538, 0, 0, 1322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 689, 0, 0, 0, 0, 0, 0, 94708, 95595, 94708, 94708, 94708, 94708, 34159, 0, 1113, 0, 1115, 34159, 0, 1118, 0, 1120,
  94734, 94734, 94734, 95638, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95651, 0,
  1495, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1505, 0, 1696, 0, 0, 0, 0, 1700, 0, 0, 0, 0, 0, 0, 0, 1706, 1707, 0, 0,
  1710, 0, 0, 1713, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1721, 0, 0, 0, 90538, 90538, 90538, 90538, 91839, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 91661, 90538, 766378, 90538, 91664, 90538, 90538, 95994, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95993, 90538, 90538, 90538,
  90538, 91973, 90538, 0, 0, 0, 0, 0, 0, 94708, 96077, 94708, 94708, 94708, 95298, 94708, 94708, 95304, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 95286, 94708, 94708, 668148, 94708, 94708, 94708, 94708, 96080,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96085, 94708, 94708, 94708, 94708, 94708, 94708, 95009, 94708,
  521, 522, 523, 524, 0, 94734, 94734, 94734, 96091, 94708, 94708, 94708, 94708, 96094, 94708, 94708, 96097, 94708,
  94708, 94734, 96101, 94734, 94734, 96104, 94734, 94734, 94734, 94734, 96118, 94734, 94734, 96121, 94734, 94734,
  339968, 0, 0, 0, 0, 0, 0, 340, 0, 0, 0, 0, 0, 345, 340, 0, 0, 0, 1941, 0, 0, 0, 0, 1945, 0, 0, 0, 0, 0, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 692650, 90538, 90538, 92062, 90538, 90538, 90538, 90538,
  90538, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94983, 94708, 94708, 94708, 94708,
  94708, 96172, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96180, 94708, 94708, 94708, 94708, 94708,
  950772, 94708, 95815, 94708, 94708, 94708, 94708, 1044980, 94708, 34159, 0, 94734, 94734, 94734, 96200, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 348, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 349, 0, 0, 0, 0, 316, 0, 0,
  0, 0, 0, 2003, 0, 0, 0, 0, 0, 0, 2006, 0, 0, 0, 0, 0, 0, 0, 626, 0, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 2013, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 91112, 90538, 90538, 90538, 0, 0, 0, 2051, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 90817, 90538, 0, 0, 0, 94708, 94708, 96389, 96390,
  94708, 94708, 94734, 94734, 96395, 96396, 94734, 94734, 0, 1187, 0, 1189, 0, 1462, 0, 1463, 0, 1464, 0, 1465, 0, 0, 0,
  0, 0, 555, 0, 0, 0, 266, 267, 0, 269, 270, 0, 0, 96419, 96420, 94708, 94734, 94708, 94734, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1667, 0, 0, 296, 0, 0, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1502, 0, 0, 0, 0, 296, 357, 0, 0, 0, 0, 0, 0,
  0, 0, 296, 0, 0, 0, 0, 0, 0, 479, 0, 479, 484, 484, 484, 484, 418, 418, 418, 0, 73728, 77824, 0, 0, 357, 0, 379,
  69632, 379, 379, 0, 379, 0, 392, 379, 414, 414, 414, 414, 90547, 90547, 90547, 90547, 90547, 451, 451, 414, 451, 451,
  451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 90547, 90547, 497, 94717, 94717, 94717, 94717,
  94717, 94743, 94717, 94743, 94717, 94717, 94717, 94717, 94717, 94717, 94743, 94743, 94743, 94743, 94743, 94743, 94743,
  94743, 94743, 94717, 94717, 94743, 1, 16386, 3, 4, 0, 636, 0, 0, 0, 0, 0, 0, 0, 0, 0, 636, 0, 0, 0, 649, 745, 0, 0, 0,
  0, 0, 0, 0, 630, 0, 636, 678, 0, 0, 0, 0, 0, 0, 0, 678, 0, 0, 0, 0, 0, 0, 0, 671, 720896, 0, 0, 0, 659, 0, 0, 679,
  94734, 94734, 95035, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95649,
  94734, 94734, 876, 878, 0, 0, 0, 0, 0, 883, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1224, 0, 0, 0, 1038, 883, 0, 0, 0,
  0, 0, 299008, 0, 0, 0, 0, 0, 0, 0, 685, 0, 90538, 90538, 90538, 90812, 90538, 90538, 90538, 95254, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 95264, 95271, 94708, 94708, 94708, 94708, 94708, 95555, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 0, 0, 0, 0, 94734, 94734, 95355, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95367, 94734, 94734, 94734, 94734, 94734, 94734, 934414, 94734, 94734,
  94734, 94734, 0, 0, 0, 0, 0, 1190, 0, 1192, 0, 1194, 0, 1196, 0, 0, 0, 94734, 94734, 94734, 95378, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95389, 94734, 94734, 94734, 94734, 94734, 95044, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 1917, 0, 0, 0, 0, 0, 1201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1249, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 91409, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0,
  1557, 0, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 602, 0, 0, 94708, 94708, 95582, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95818, 34159, 0, 29793, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95616, 95617, 94734, 94734, 94734, 94734, 95621, 0, 0, 0, 1484, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 948, 0, 0, 0, 1506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1516, 0, 0, 0, 319, 0, 0, 0, 0, 0,
  319, 0, 320, 0, 319, 0, 0, 0, 0, 266240, 0, 0, 0, 266240, 0, 0, 0, 1, 16386, 2117887, 4, 0, 0, 0, 0, 0, 261, 0, 0, 0,
  0, 261, 0, 91667, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1036, 94708, 94708, 95813,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 34159, 0, 1113, 0, 1115, 34159, 0, 1118,
  0, 1120, 0, 1670, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446464, 446890, 0, 0, 0, 90538, 90538, 90538, 90538,
  90538, 91840, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91422, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 96374, 94708, 96375, 94708, 94708, 94708, 94734, 94734, 94734, 96380, 94734, 96381, 94734, 94734, 94734, 0,
  1187, 0, 1189, 0, 1462, 0, 1463, 0, 1464, 0, 1465, 0, 1467, 0, 0, 0, 0, 96387, 94708, 94708, 94708, 94708, 94708,
  96393, 94734, 94734, 94734, 94734, 94734, 0, 1187, 1189, 0, 0, 0, 872, 0, 874, 0, 876, 0, 878, 0, 0, 0, 0, 548, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 331, 0, 0, 0, 0, 0, 96411, 94708, 94708, 94708, 96413, 94734, 94734, 94734, 0, 94708,
  94708, 94734, 94734, 94708, 94734, 94734, 94734, 94734, 96337, 94734, 96339, 96340, 96341, 94734, 0, 0, 0, 0, 0, 0,
  477, 482, 477, 477, 477, 477, 477, 0, 0, 0, 0, 0, 298, 0, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1690, 0, 0, 1693, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 388, 0, 0, 0, 0, 1497, 0, 1499, 0, 0, 0, 1501,
  0, 0, 0, 0, 0, 0, 967, 0, 0, 0, 0, 0, 0, 0, 0, 0, 654, 0, 0, 0, 0, 0, 0, 400, 415, 415, 423, 415, 90548, 90548, 90548,
  90548, 90548, 400, 400, 415, 400, 400, 400, 400, 400, 400, 475, 400, 475, 475, 475, 475, 475, 475, 475, 475, 475, 475,
  475, 475, 475, 475, 475, 90548, 90548, 475, 94718, 94718, 94718, 94718, 94718, 94744, 94718, 94744, 94718, 94718,
  94718, 94718, 94718, 94718, 94744, 94744, 94744, 94744, 94744, 94744, 94744, 94744, 94744, 94718, 94718, 94744, 1,
  16386, 3, 4, 576, 0, 0, 0, 0, 0, 0, 0, 576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1236, 94734, 94734, 95036,
  94734, 94734, 95045, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96285, 94734, 0, 0,
  0, 91132, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 1030, 0, 0, 0, 0, 0, 0, 0, 94708, 96324, 94708, 94708, 94708,
  96328, 94708, 94708, 94708, 95254, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95265, 94708, 94708, 94708,
  94708, 94708, 94708, 95283, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96178, 94708, 94708, 94708,
  94708, 94708, 94708, 95551, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95559, 94708, 94708, 94708, 94708,
  94708, 94708, 95303, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95314, 29793, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 95618, 94734, 94734, 94734, 94734, 94734, 94734, 96202, 94734, 94734, 94734,
  94734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1666, 0, 1668, 94734, 643598, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 2047, 0, 1518, 0, 0, 0, 0, 0, 1523, 0, 0, 0, 0, 0, 0, 0, 0,
  275, 274, 0, 274, 354, 274, 275, 0, 95811, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 34159, 0, 0, 0, 338, 0, 0, 0, 0, 0, 338, 0, 0, 0, 338, 0, 0, 0, 0, 1510, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1838, 0, 0, 0, 0, 94734, 94734, 94734, 95860, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95063, 94734, 94734, 94734, 94708, 94708, 96305, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 96315, 0, 0, 0, 0, 0, 1511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324258, 0, 0, 0, 0, 0, 2110, 0, 0, 0, 0, 0, 0,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 1049076, 0, 0, 0, 0, 94734, 94734, 0, 0, 323, 300, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 973, 0, 0, 0, 0, 0, 337, 0, 0, 338, 339, 341, 301, 0, 0, 0, 0, 0, 0, 0, 814, 814,
  814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 814, 0, 73728, 77824, 338, 0, 0, 0, 0, 69632, 0, 0,
  300, 0, 0, 393, 0, 0, 0, 360, 0, 0, 0, 352, 0, 360, 0, 0, 0, 360, 352, 0, 0, 0, 477, 0, 477, 477, 477, 477, 477, 477,
  477, 477, 477, 495, 90551, 477, 94721, 94721, 94721, 94721, 94721, 94747, 94721, 94747, 94721, 94721, 94721, 94721,
  94721, 94721, 0, 416, 422, 422, 422, 90549, 90549, 90549, 90549, 90549, 422, 422, 416, 460, 460, 460, 460, 460, 460,
  422, 460, 422, 422, 422, 422, 422, 422, 422, 487, 422, 488, 487, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 90549, 422, 94719, 94719, 94719, 94719, 94719, 94745, 94719, 94745, 94719, 94719, 94719, 94719, 94719,
  94719, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94745, 94719, 94719, 94745, 1, 16386, 3, 4, 0, 0, 323,
  323, 323, 0, 0, 610, 0, 0, 0, 0, 0, 0, 0, 618, 0, 0, 664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 577, 0, 606208, 579, 580,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 972, 0, 0, 0, 0, 0, 0, 693, 0, 610, 0, 0, 0, 0, 90538, 90809, 90538, 90538, 90538,
  90818, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 561152, 0, 0, 0, 0, 0, 0, 0, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94708, 94708, 94734, 1, 16386, 3, 4, 90538, 90823, 90538, 90538, 90538, 90826, 90538, 90538, 90538,
  90538, 90835, 90538, 684, 0, 0, 728, 693, 0, 0, 0, 684, 0, 0, 577, 740, 0, 680, 0, 0, 0, 0, 0, 0, 684, 0, 0, 0, 0,
  690, 0, 0, 0, 0, 580, 0, 680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 680, 728, 0, 0, 0, 521, 521, 521, 0, 523, 521, 523, 521, 521,
  521, 521, 521, 521, 746, 0, 748, 0, 0, 0, 0, 0, 0, 0, 684, 577, 606956, 0, 0, 0, 0, 0, 1521, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1837, 0, 0, 0, 798720, 0, 0, 0, 0, 94708, 94963, 94708, 94708, 94708, 94976, 94708, 94708, 94985, 94708, 94708,
  94708, 94992, 94734, 94734, 95037, 94734, 94734, 95046, 94734, 94734, 94734, 95053, 94734, 94734, 94734, 94734, 95068,
  94734, 1458, 0, 1460, 0, 1190, 1462, 1192, 1463, 1194, 1464, 1196, 1465, 0, 0, 0, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 159744, 0, 0, 0, 0, 0, 876, 878, 0, 0, 0, 0, 0, 0, 884, 885, 886, 0, 0, 0, 0, 0, 0, 566, 0, 0, 0, 0, 0, 742,
  681, 0, 0, 0, 908, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 919, 0, 323, 323, 0, 0, 0, 923, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1248, 0, 0, 0, 0, 0, 0, 939, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1260, 0, 0, 0, 0, 0, 0, 988, 0, 0, 0, 1041, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 644, 0, 0, 0, 0, 0, 649, 0, 0, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 95260,
  94708, 94708, 95266, 94708, 94708, 94708, 94708, 94708, 94708, 95556, 94708, 94708, 94708, 483828, 94708, 94708,
  95562, 94708, 94708, 94734, 94734, 94734, 95335, 94734, 94734, 95341, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95385, 94734, 94734, 94734, 95390, 94734, 94734, 94734, 95356, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95634, 94734, 95373, 94734, 94734, 95379, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95662, 94734, 94734, 94734, 0, 942080, 0, 1227,
  1015808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1947, 90538, 90538, 90538, 90538, 0, 0, 0, 90538, 90538, 90538, 90538,
  90538, 90538, 91411, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 1034, 0, 0, 0, 29793, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95620, 94734, 1458, 1660, 1460, 1661,
  1462, 1463, 1464, 1465, 0, 0, 0, 0, 0, 0, 0, 0, 1927, 0, 0, 0, 0, 0, 0, 0, 0, 2015, 0, 0, 90538, 381354, 92128, 90538,
  90538, 90538, 90538, 90538, 90538, 979370, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 634880, 0, 0, 0, 1671,
  0, 0, 0, 0, 0, 757760, 0, 847872, 0, 0, 0, 0, 0, 0, 897, 0, 0, 0, 0, 0, 0, 0, 0, 906, 0, 0, 0, 1682, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1694, 1695, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1251, 0, 0, 0, 1711, 0, 0, 0, 0, 0, 0, 0,
  1718, 0, 0, 0, 0, 0, 0, 159744, 0, 159744, 159744, 159744, 159744, 163840, 159744, 159744, 159744, 0, 1722, 0, 90538,
  90538, 90538, 90538, 90538, 90538, 91841, 90538, 91842, 90538, 90538, 90538, 848298, 90538, 91846, 90538, 0, 1736, 0,
  0, 0, 0, 0, 0, 1740, 0, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 0, 94708, 94708, 94734, 94734, 96417,
  96418, 94708, 94708, 95964, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  96089, 94708, 96090, 848372, 94708, 94708, 95976, 94708, 94708, 94708, 94708, 94708, 94708, 0, 0, 0, 0, 94734, 94734,
  94734, 94734, 94734, 639502, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95365, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 95995, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95839, 94734, 94734, 94734, 94734, 848398, 94734, 94734, 96007, 94734, 94734, 94734, 94734,
  94734, 94734, 0, 0, 0, 0, 0, 0, 913, 0, 0, 0, 0, 0, 0, 0, 323, 323, 0, 0, 1820, 0, 1007616, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1829, 0, 0, 0, 1831, 0, 0, 0, 0, 0, 1836, 0, 0, 1839, 0, 0, 0, 0, 0, 1699, 0, 0, 0, 0, 0, 0, 0, 1705, 0, 0, 94708,
  94708, 96081, 94708, 94708, 94708, 96083, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95571, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94734, 96105, 94734, 94734, 94734, 96107, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 979470, 94734, 94734, 94734, 94734, 90538, 90538, 90538, 90538, 90538,
  90538, 1955, 0, 1956, 0, 0, 94708, 96168, 94708, 94708, 94708, 94708, 905716, 94708, 94708, 95978, 94708, 94708, 1611,
  1612, 1613, 1614, 94734, 94734, 94734, 94734, 96199, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0,
  380928, 0, 0, 0, 0, 0, 1822, 0, 0, 1824, 0, 0, 0, 0, 0, 0, 0, 983, 0, 0, 0, 0, 0, 0, 0, 0, 0, 319488, 0, 0, 0, 0, 0,
  0, 548864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1262, 90538, 0, 0, 94708, 94708, 94708, 96268, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 95803, 94708, 95805, 95806, 94708, 94708, 94708, 94708, 94734, 94734,
  94734, 96278, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 1832, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1852, 90538, 90538, 90538, 90538, 90538, 0, 851968, 0, 0, 0, 0, 0, 94708, 94708, 94708, 96326, 94708, 94708,
  94708, 94708, 94708, 95598, 34159, 0, 1113, 0, 1115, 34159, 0, 1118, 0, 1120, 94734, 94734, 94734, 96365, 94734,
  96367, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94977, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  95801, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95816, 95817, 94708, 94708, 94708, 34159, 0, 0,
  0, 94708, 94708, 96403, 96404, 94708, 94708, 94734, 94734, 96407, 96408, 94734, 94734, 0, 0, 0, 0, 1520, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1530, 0, 73728, 77824, 0, 303, 0, 305, 304, 69632, 304, 304, 305, 304, 0, 303, 304, 401, 417, 417,
  417, 425, 90550, 90550, 90550, 90550, 90550, 452, 452, 458, 452, 452, 462, 452, 452, 452, 462, 462, 452, 476, 462,
  476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 90550, 90550, 476, 94720, 94720, 94720,
  94720, 94720, 94746, 94720, 94746, 94720, 94720, 94720, 94720, 94720, 94720, 94746, 94746, 94746, 94746, 94746, 94746,
  94746, 94746, 94746, 94720, 94720, 94746, 1, 16386, 3, 4, 0, 606, 323, 323, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  86016, 0, 0, 0, 0, 619, 0, 621, 0, 623, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 135168, 135168, 135168, 0, 954368,
  0, 0, 0, 0, 694, 695, 0, 90538, 90538, 90538, 90813, 90538, 90538, 90820, 90538, 90538, 90538, 90825, 90538, 90538,
  90538, 90538, 90538, 954794, 90538, 90838, 0, 659, 0, 0, 0, 0, 1535, 1536, 0, 1538, 0, 0, 0, 1536, 90538, 90538,
  90538, 91654, 0, 0, 737, 606, 0, 0, 739, 0, 0, 0, 741, 0, 0, 0, 954368, 606, 0, 0, 0, 954368, 739, 739, 587, 623, 0,
  954368, 0, 0, 0, 653, 0, 653, 0, 0, 954368, 94708, 94708, 94708, 94970, 94973, 94708, 94980, 94708, 94708, 94708,
  94989, 94991, 94708, 94708, 94708, 309179, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95865, 95866, 94734, 94734, 94708, 94708, 95000, 954868, 94708, 94708, 95011, 94708, 521, 522, 523, 524,
  0, 94734, 94734, 94734, 94734, 94734, 95360, 94734, 95363, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  96122, 94734, 0, 0, 0, 0, 0, 0, 95031, 95034, 94734, 95041, 94734, 94734, 94734, 95050, 95052, 94734, 94734, 94734,
  95061, 954894, 94734, 94734, 94734, 94734, 94734, 692750, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95645, 94734, 94734, 94734, 94734, 94734, 95072, 94734, 547, 548, 0, 0, 0, 4, 82177, 0, 0, 0, 872, 874,
  0, 0, 0, 0, 1673, 671744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1679, 0, 937, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 0, 0,
  1683, 1684, 0, 0, 1687, 0, 0, 0, 0, 0, 0, 0, 582, 583, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 366, 0, 330, 330, 90538,
  90538, 90538, 90538, 91120, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 673,
  0, 0, 0, 94708, 94708, 95297, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95313,
  94708, 94708, 94708, 426484, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96088, 94708, 94708, 94708,
  94708, 96377, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96383, 94734, 0, 94734, 94734, 95357, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95372, 0, 0, 1254, 0, 0, 0, 0, 0, 0, 0,
  1259, 0, 0, 0, 0, 0, 0, 926, 0, 0, 0, 0, 0, 0, 0, 0, 0, 753, 753, 753, 753, 753, 753, 753, 753, 753, 753, 0, 0, 1281,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1276, 0, 0, 0, 1291, 0, 90538, 90538, 91407, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 91426, 90538, 90538, 90538, 91430, 90538, 90538, 90538, 635306, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91429, 90538, 90538, 0, 0, 0, 0, 94708, 94708, 336372, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 95305, 94708, 94708, 94708, 95309, 94708, 94708, 94708, 94708, 29793, 94734,
  94734, 94734, 94734, 95612, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95349, 94734, 94734,
  95352, 94734, 94734, 635406, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95840, 94734, 0, 0, 0, 1821, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1478, 1479, 0, 0, 1921, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1481, 0, 2049, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538,
  90538, 90538, 0, 0, 96266, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 689209,
  94708, 95291, 94708, 96276, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0,
  2079, 0, 0, 0, 522, 522, 522, 0, 524, 522, 524, 522, 522, 522, 522, 522, 522, 0, 0, 2082, 0, 0, 0, 0, 0, 0, 94708,
  94708, 96298, 94708, 94708, 94708, 94708, 95554, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  95564, 94708, 94734, 96334, 94734, 94734, 94734, 96338, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 942, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 2193, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734,
  94734, 94734, 0, 2202, 94708, 94734, 96421, 96422, 94708, 94734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1466, 0, 0, 0,
  73728, 77824, 360, 352, 0, 0, 0, 69632, 0, 0, 0, 0, 389, 0, 0, 0, 0, 1712, 0, 0, 0, 0, 1717, 0, 0, 0, 0, 0, 0, 0,
  1849, 0, 0, 0, 90538, 91966, 90538, 90538, 90538, 94747, 94747, 94747, 94747, 94747, 94747, 94747, 94747, 94747,
  94721, 94721, 94747, 1, 16386, 3, 4, 876, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 887, 0, 0, 0, 891, 91118, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91131, 95254, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 95267, 94708, 94708, 94708, 94708, 95276, 94708, 94708, 94708,
  909812, 94708, 94708, 958964, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 34159, 0, 0, 0, 564, 0, 0, 566, 567, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 90538, 90808, 90538, 90538, 90538, 90538, 90538, 95374, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 95386, 94734, 94734, 94734, 94734, 94734, 94734, 95342, 94734, 94734, 94734, 94734, 95351,
  94734, 94734, 94734, 94734, 0, 0, 0, 1239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1491, 0, 0, 0, 95580, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95962, 94708, 0, 0, 0,
  1519, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1503, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 90538, 91659, 582058,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708,
  94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 582158, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 1032718, 94734, 0, 0, 1932, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1719, 0,
  0, 90538, 90538, 90538, 92064, 90538, 90538, 0, 0, 0, 1957, 0, 94708, 94708, 94708, 94708, 94708, 95955, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 95963, 94734, 96198, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 0, 0, 0, 0, 0, 0, 955, 0, 649, 0, 884, 0, 0, 0, 0, 0, 0, 732, 0, 0, 0, 653, 734, 0, 0, 0, 653, 507904,
  0, 0, 0, 0, 0, 0, 0, 507904, 0, 0, 0, 0, 0, 0, 0, 943, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 324282, 90538, 90538, 90538,
  90538, 90538, 94734, 94734, 508430, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 95992, 94734, 94734, 94734, 95073, 547, 548, 0, 0, 0, 4, 82177, 0, 0, 0, 872, 874, 0, 0, 0, 0, 1808, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1527, 0, 0, 0, 0, 94734, 96245, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 306, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466944, 0, 0, 0,
  323, 0, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 0, 307, 306, 69632, 306, 306, 307, 306,
  0, 0, 306, 0, 0, 0, 0, 90552, 90552, 90552, 90552, 90552, 306, 306, 307, 306, 306, 306, 306, 306, 469, 306, 306, 306,
  306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 90552, 90552, 306, 94722, 94722, 94722, 94722, 94722,
  94748, 94722, 94748, 94722, 94722, 94722, 94722, 94722, 94722, 94748, 94748, 94748, 94748, 94748, 94748, 94748, 94748,
  94748, 94722, 94722, 94748, 1, 16386, 3, 4, 590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1493, 0, 663, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 507904, 0, 589, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1817, 761856, 692, 0, 0,
  0, 0, 0, 0, 761856, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 96079,
  90821, 90538, 90538, 90538, 90538, 762571, 90538, 90538, 90538, 90834, 90538, 90538, 0, 0, 0, 0, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 654, 0, 0, 762585, 0, 0, 0, 0, 0, 762446, 0, 0,
  0, 762585, 0, 638, 0, 0, 692, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94982, 94708, 94708, 94708, 94708,
  762641, 94995, 94708, 94708, 95005, 94708, 94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 94734, 94734, 94734,
  94734, 95361, 94734, 94734, 668174, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96008, 94734, 94734, 94734, 0, 0,
  0, 0, 0, 0, 0, 938, 0, 940, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 541098,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 91127, 90538, 90538, 90538, 90538, 90538, 90538, 0, 499712, 1029, 0,
  0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 0, 0, 356, 0, 90538, 90538, 90538, 90538, 90538, 91137, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1703, 0, 0, 0, 0, 0, 1037, 0, 0, 0, 0, 1040, 0, 0, 0, 0, 1043, 0, 0, 0, 0, 951, 0, 0, 0, 954, 0, 0, 0, 649, 0, 0,
  0, 540672, 0, 0, 0, 0, 0, 2084, 0, 2086, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95802, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 95558, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95279,
  541172, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 831988, 94708, 94708,
  94708, 94708, 95294, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  963060, 94708, 94708, 94708, 94708, 94708, 95317, 94708, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 94734,
  94734, 94734, 94734, 95043, 94734, 94734, 94734, 94734, 762702, 95056, 94734, 94734, 95066, 94734, 94734, 94734,
  94734, 94734, 905742, 94734, 94734, 96009, 94734, 94734, 1660, 1661, 0, 0, 0, 0, 0, 1473, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 946, 0, 0, 0, 0, 0, 541198, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 95369, 94734, 1459, 1187, 1461, 1189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 573440, 0, 659456, 0, 712704, 0, 1264,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565248, 0, 95594, 94708, 95596, 94708, 94708, 94708, 34159, 0, 1113, 0,
  1115, 34159, 0, 1118, 0, 1120, 29793, 94734, 94734, 94734, 95611, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 1999, 0, 0, 0, 0, 765952, 1482, 1483, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1492, 0, 0, 0, 622,
  0, 0, 625, 0, 0, 0, 0, 0, 0, 0, 0, 634, 0, 0, 1508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1828, 0, 0, 1531, 0, 0, 0,
  0, 0, 0, 0, 1539, 0, 0, 0, 295338, 90538, 91653, 90538, 0, 0, 0, 0, 0, 0, 0, 1325, 0, 0, 0, 0, 0, 0, 0, 927, 0, 0, 0,
  0, 0, 0, 0, 935, 94708, 95796, 94708, 94708, 94708, 767544, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  95809, 94708, 94708, 94708, 1032692, 94708, 94708, 34159, 0, 1113, 0, 1115, 34159, 0, 1118, 0, 1120, 94734, 95842,
  95843, 94734, 95845, 94734, 94734, 94734, 767593, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95987, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 96109, 94734, 94734, 94734, 94734, 94734, 94734, 96115, 94734, 95858,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 594446, 94734,
  94734, 95867, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1665, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95973, 0, 0, 1697, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1937, 0, 0, 0, 1709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655360, 0, 90538, 90538, 90538, 1735, 0, 0, 0, 0, 0,
  0, 1739, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96356, 94708, 96358, 94734, 94734, 94734, 94734, 1818,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1826, 0, 0, 0, 0, 0, 0, 167936, 0, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 167936, 1, 16386, 3, 4, 2081, 0, 0, 0, 0, 0, 0, 0, 0, 96296, 94708, 94708, 94708,
  94708, 94708, 94708, 95977, 94708, 94708, 94708, 0, 0, 0, 0, 94734, 94734, 94708, 96304, 94708, 96306, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 96314, 94734, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 95549, 95550, 0, 2141, 94708, 96351, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734,
  96360, 94734, 94734, 94734, 94734, 95359, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  1660, 1661, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 96405, 94708, 94734, 94734, 94734, 94734, 96409, 94734, 421888,
  0, 0, 0, 638, 0, 0, 0, 642, 0, 0, 0, 0, 0, 0, 0, 649, 790528, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734,
  585728, 94708, 94708, 94734, 94734, 94708, 94734, 94734, 94734, 96336, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0,
  0, 2138, 0, 0, 0, 308, 309, 310, 311, 312, 313, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  90538, 90538, 92061, 90538, 0, 358, 359, 0, 0, 0, 348, 0, 0, 0, 310, 365, 0, 0, 0, 0, 0, 0, 176128, 0, 176128, 176128,
  176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 176128, 1, 0, 3, 4, 0, 73728, 77824, 0, 0, 372, 0,
  380, 69632, 380, 380, 0, 380, 0, 365, 380, 402, 0, 0, 359, 0, 90553, 90553, 90553, 90553, 90553, 453, 453, 0, 453,
  453, 453, 453, 453, 453, 478, 453, 478, 478, 478, 478, 478, 402, 402, 402, 478, 489, 478, 478, 478, 478, 478, 478,
  478, 478, 478, 478, 90553, 90553, 498, 94723, 94723, 94723, 94723, 94723, 94749, 94723, 94749, 94723, 94723, 94723,
  94723, 94723, 94723, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94749, 94723, 94723, 94749, 1, 16386, 3,
  4, 0, 323584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 897024, 0, 90538, 639402, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 324258, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  95548, 94708, 94708, 0, 602, 0, 0, 0, 324258, 0, 0, 0, 638976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 917504, 0,
  324258, 0, 638976, 0, 0, 0, 0, 0, 0, 0, 324258, 0, 638976, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 95545,
  94708, 94708, 94708, 94708, 94708, 95787, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 1611,
  1612, 1613, 1614, 94734, 95981, 0, 0, 0, 94708, 324340, 94708, 94708, 94708, 94708, 94708, 94708, 639476, 94708,
  94708, 94708, 94708, 95568, 95570, 94708, 94708, 94708, 95573, 733684, 94708, 95574, 95576, 94708, 94708, 876, 878, 0,
  879, 0, 881, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1812, 0, 0, 1815, 0, 0, 0, 0, 893, 0, 0, 0, 0, 0, 899, 0, 0, 0, 0, 0, 0, 0,
  957, 649, 0, 0, 0, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0, 0, 0, 881, 980, 981,
  0, 0, 0, 0, 0, 0, 987, 0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 95544, 94708, 94708, 94708, 94708, 94708, 94708,
  95956, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 979444, 94708, 94708, 94708, 94708, 94708,
  34159, 0, 0, 991, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 91111, 90538, 91116, 90538, 91117, 90538, 90538, 90538,
  90538, 90538, 90538, 91122, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91125, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 1027, 0, 0, 0, 0, 0, 0, 0, 0, 0, 900, 0, 0, 0, 0, 0, 0,
  95254, 94708, 94708, 94708, 94708, 94708, 94708, 95261, 94708, 94708, 95272, 94708, 94708, 95275, 94708, 94708, 94708,
  95299, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95311, 94708, 94708, 94708, 95300, 95301, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95791, 94708, 94708, 94708, 94708, 0, 0, 1226,
  0, 0, 0, 0, 0, 0, 0, 0, 1234, 1235, 0, 0, 0, 0, 0, 131072, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524288, 0, 0, 0, 0,
  0, 0, 0, 0, 1534, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 90538, 90538, 90538, 90538, 91114, 90538, 90538, 90538, 90538, 90538,
  950698, 90538, 90538, 90538, 1044906, 0, 0, 0, 0, 0, 0, 0, 0, 0, 916, 0, 0, 0, 0, 323, 323, 0, 0, 950272, 1565, 94708,
  95774, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96086, 94708, 94708, 94708, 94708, 94708,
  94734, 94734, 95859, 94734, 94734, 94734, 94734, 94734, 950798, 94734, 95864, 94734, 94734, 94734, 94734, 1045006, 0,
  0, 1723, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91843, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0,
  1738, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94975, 94708, 94708, 94984, 94708, 94708, 94708, 94708, 90538,
  90538, 90538, 0, 0, 0, 0, 0, 745472, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94978, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 96095, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 2078, 0, 2080, 94708, 94708, 96092, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94734, 94734, 94734, 94734, 94734, 94734, 96192, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96116, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 0, 94708, 96373, 94708, 0, 0, 0, 1942, 1943, 0, 0,
  0, 0, 393216, 0, 0, 90538, 90538, 90538, 393642, 393716, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 96102, 94734, 94734, 0, 2012, 0, 0, 0, 0, 0, 0, 0,
  860160, 0, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 94708, 94708, 96169, 94708, 94708, 860586, 889258,
  0, 2018, 0, 888832, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96241, 94734, 94734, 94734,
  94734, 94734, 2048, 0, 0, 0, 0, 0, 0, 0, 0, 2055, 0, 0, 0, 450560, 0, 90538, 0, 0, 0, 0, 0, 0, 1202, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1212, 782762, 0, 782336, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 782836, 94708, 94708, 94708,
  94708, 94708, 96082, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 770548, 94708, 0, 0, 96350, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 96359, 94734, 94734, 94734, 94734, 94734, 95381, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 1919, 0, 0, 0, 0, 94708, 96388, 94708, 94708, 94708,
  94708, 94734, 96394, 94734, 94734, 94734, 94734, 0, 1187, 1189, 0, 0, 0, 872, 0, 874, 0, 876, 0, 878, 0, 1199, 314, 0,
  0, 0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 0, 0, 929, 0, 0, 0, 0, 0, 0, 0, 73728, 77824, 0, 0, 373, 0, 0, 69632, 0, 0, 0,
  0, 0, 316, 0, 0, 0, 641, 0, 0, 0, 0, 0, 0, 0, 656, 0, 0, 0, 0, 0, 0, 262144, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983040, 0,
  0, 0, 0, 0, 0, 418, 418, 418, 418, 90554, 90554, 90554, 90554, 90554, 0, 0, 418, 0, 0, 0, 0, 0, 253952, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 521, 522, 523, 524, 0, 0, 0, 0, 418, 418, 418, 484, 490, 484, 484, 484, 479, 484, 484, 479, 484, 484,
  479, 90554, 499, 94724, 94724, 94724, 94724, 94724, 94750, 94724, 94750, 94724, 94724, 94724, 94724, 94724, 94724,
  94750, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94750, 94724, 94724, 94750, 1, 16386, 3, 4, 0, 0, 331776, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 0, 0, 0, 0, 0, 578, 0, 0, 0, 581, 0, 0, 0, 0, 0, 0, 0, 0, 0, 970, 0, 0,
  0, 0, 0, 0, 0, 331776, 0, 0, 0, 641, 598, 0, 0, 0, 0, 331776, 646, 647, 0, 649, 0, 682, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  589824, 0, 679936, 0, 0, 0, 0, 1846, 0, 1848, 0, 0, 0, 0, 91965, 90538, 91967, 90538, 90538, 0, 0, 0, 0, 94708, 94708,
  94708, 381428, 96229, 96230, 94708, 94708, 94708, 94708, 95281, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94734, 94734, 94734, 96103, 94734, 590250, 90538, 680362, 90538, 90538, 90538, 90538,
  90538, 90832, 90538, 90538, 90538, 331776, 0, 0, 0, 0, 0, 0, 0, 682, 0, 331776, 0, 0, 0, 0, 0, 0, 982, 0, 0, 0, 0,
  315392, 0, 0, 0, 0, 589824, 0, 679936, 0, 682, 0, 0, 0, 578, 0, 733, 0, 0, 0, 0, 733, 679936, 752, 0, 94708, 94965,
  94708, 94708, 94708, 94708, 94708, 590324, 94986, 680436, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 96310,
  94734, 96312, 94734, 94734, 94734, 0, 0, 0, 0, 0, 237568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 332, 94708,
  94708, 95001, 94708, 94708, 94708, 94708, 94708, 521, 522, 523, 524, 0, 94734, 95026, 94734, 94734, 94734, 94734,
  95655, 94734, 94734, 94734, 94734, 94734, 94734, 95661, 94734, 95663, 94734, 94734, 94734, 94734, 95336, 94734, 94734,
  95347, 94734, 94734, 95350, 94734, 94734, 94734, 94734, 94734, 94734, 95343, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95850, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 590350, 95047,
  680462, 94734, 94734, 94734, 94734, 94734, 95062, 94734, 94734, 94734, 94734, 94734, 95833, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 95631, 94734, 94734, 94734, 94734, 94734, 876, 878, 0, 0, 0, 0, 882,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 985, 0, 0, 0, 0, 0, 0, 0, 0, 0, 894, 0, 0, 0, 0, 0, 0, 0, 902, 0, 0, 905, 0, 1039, 0, 0, 0,
  0, 0, 0, 0, 1039, 0, 0, 921, 0, 921, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1841, 977, 0, 0, 882, 0, 0, 0, 0,
  984, 0, 986, 0, 0, 0, 0, 0, 0, 995, 90538, 90538, 90538, 90538, 90538, 91113, 90538, 90538, 90538, 0, 992, 0, 0, 0, 0,
  0, 91108, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 94708, 94708, 96078, 94708, 90538,
  90538, 90538, 90538, 90538, 90538, 91123, 668074, 90538, 90538, 90538, 90538, 91128, 91129, 90538, 90538, 0, 0, 0, 0,
  94708, 328180, 94708, 94708, 94708, 94708, 94708, 94708, 534505, 94708, 90538, 90538, 90538, 90538, 91136, 90538, 0,
  1028, 0, 984, 1031, 0, 0, 741376, 0, 0, 0, 0, 1924, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1210, 0, 634880, 0, 0, 95254,
  95255, 94708, 94708, 95258, 94708, 94708, 95262, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96096, 94708,
  94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96196, 94708, 95316,
  94708, 94708, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 95330, 94734, 94734, 94734, 94734, 95861, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 1020430, 94734, 0, 1187, 1189, 0, 0, 1191, 872, 1193, 874,
  1195, 876, 1197, 878, 0, 0, 0, 0, 270336, 0, 0, 0, 0, 266, 267, 0, 269, 270, 200704, 0, 94734, 95333, 94734, 94734,
  95337, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95388, 94734, 94734, 94734, 94734,
  95375, 95376, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95391, 94734, 94734,
  94734, 94734, 95984, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 520718, 94734, 94734, 94734,
  94734, 95996, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96002, 94734, 94734, 94734, 94734, 95380, 94734,
  94734, 94734, 95384, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95863, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 96110, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 700416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 122880, 122880, 122880, 937984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 651264, 0, 0, 0, 0, 2014, 0, 0, 0, 0, 0, 0,
  90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0, 716800, 0, 0, 0, 0, 0, 0, 0, 1246, 0, 0, 0, 0, 0, 0, 1242,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 0, 0, 0, 1292, 90538, 90538, 90538, 365840, 90538, 91410, 90538,
  90538, 90538, 90538, 91414, 90538, 90538, 0, 0, 0, 0, 96228, 94708, 94708, 94708, 94708, 94708, 96231, 94708, 94708,
  94708, 94708, 95786, 94708, 95788, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95588, 94708, 94708,
  94708, 94708, 94708, 94708, 90538, 91417, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 91424, 90538, 90538, 90538,
  90538, 90538, 90538, 0, 0, 0, 0, 0, 887, 0, 0, 0, 0, 90538, 0, 1321, 0, 0, 0, 0, 1292, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0,
  522, 0, 0, 523, 0, 524, 1330, 0, 0, 1285, 365829, 95254, 94708, 94708, 94708, 94708, 94708, 94708, 365883, 94708,
  94708, 94708, 94734, 94734, 94734, 96309, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 2161, 0, 2163, 94708,
  94708, 94708, 94708, 95552, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95560, 94708, 94708, 94708,
  94708, 95569, 94708, 94708, 651764, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96176, 96177, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 95284, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95968, 94708,
  94708, 94708, 94708, 95972, 94708, 94708, 29793, 94734, 94734, 94734, 94734, 94734, 94734, 365950, 94734, 94734,
  94734, 94734, 95619, 94734, 94734, 94734, 94734, 94734, 95846, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95647, 94734, 94734, 94734, 94734, 94734, 94734, 651790, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 983566, 0, 0, 94734, 94734, 95653, 94734, 94734, 95656,
  938510, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95630, 94734, 94734, 94734, 94734, 94734,
  94734, 0, 1469, 0, 0, 0, 0, 0, 0, 0, 0, 0, 663552, 0, 0, 0, 0, 0, 0, 614400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1232, 0, 0, 0,
  0, 0, 0, 1494, 0, 528384, 1496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1704, 0, 0, 0, 0, 0, 458752, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 192917, 192917, 192917, 90538, 90538, 414122, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 576, 90538, 909738, 90538, 958890, 90538, 90538, 90538, 0, 0, 0, 0,
  0, 0, 0, 0, 1562, 414196, 94708, 94708, 95785, 94708, 94708, 94708, 94708, 94708, 94708, 528884, 94708, 95792, 94708,
  94708, 94708, 94734, 94734, 96308, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 1925, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1935, 0, 0, 0, 1938, 0, 94734, 94734, 94734, 414222, 94734, 94734, 95834, 94734, 94734, 94734,
  94734, 94734, 94734, 528910, 94734, 95841, 0, 0, 0, 1672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1677, 0, 0, 0, 0, 2083, 0, 0, 0,
  0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 377332, 94708, 94708, 94708, 0, 0, 0, 602112, 1698, 0, 0,
  0, 921600, 0, 0, 0, 0, 0, 0, 0, 1206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249856, 249856, 249856, 1, 16386, 3, 4, 520192, 0, 0,
  90538, 90538, 90538, 91838, 90538, 90538, 90538, 520618, 90538, 90538, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0,
  309159, 94708, 94708, 94708, 94708, 90538, 90538, 90538, 0, 0, 0, 0, 1011712, 0, 0, 0, 0, 0, 95949, 94708, 94708,
  94708, 95318, 0, 1113, 1115, 0, 0, 1118, 1120, 0, 29793, 95254, 94734, 94734, 94734, 94734, 95626, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 1803, 1804, 0, 602612, 623092, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 786932, 94708, 95970, 94708, 94708, 94708, 94708, 95584, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 602638,
  623118, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 786958, 94734, 96001, 94734, 94734, 94734, 94734, 94734,
  95862, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96000, 94734, 94734, 94734, 94734,
  0, 397312, 401408, 0, 0, 430080, 479232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1220, 0, 0, 0, 0, 0, 0, 1842, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 90538, 90538, 90538, 90538, 430506, 94708, 385524, 94708, 94708, 430580, 94708, 94708, 479732, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 489005, 512500, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 385550,
  94734, 94734, 430606, 94734, 94734, 479758, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95644,
  94734, 95646, 94734, 94734, 94734, 94734, 94734, 94734, 96117, 94734, 94734, 94734, 94734, 94734, 94734, 96123, 0, 0,
  0, 0, 0, 0, 0, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 373262, 94734, 0, 1922, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 577536, 0, 0, 0, 0, 2113, 0, 835584, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96240, 94708,
  94734, 94734, 94734, 94734, 94734, 94734, 94708, 94708, 473005, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 96087, 94708, 94708, 94708, 94708, 96185, 94708, 94708, 94734, 94734, 96189,
  94734, 94734, 94734, 94734, 473025, 94734, 94734, 94734, 94734, 94734, 94734, 95382, 94734, 94734, 94734, 94734,
  95387, 94734, 94734, 94734, 94734, 0, 0, 0, 2004, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2008, 0, 0, 0, 90538, 90538,
  454656, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 631284, 94734, 94734, 94734, 631310,
  94734, 94734, 94734, 94734, 94734, 96251, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 41322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 751, 0, 0, 0, 0, 90538, 0, 0, 94708, 440331, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 96274, 94708,
  94708, 94708, 95567, 94708, 635380, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95969,
  94708, 94708, 94708, 94708, 94708, 94734, 440341, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 96284,
  94734, 94734, 0, 0, 0, 0, 0, 356352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 344064, 0, 0, 0, 0, 0, 2176, 0, 2178, 94708, 94708,
  94708, 94708, 96391, 96392, 94734, 94734, 94734, 94734, 96397, 96398, 0, 0, 0, 692, 0, 0, 0, 0, 0, 692, 0, 0, 0, 0,
  634, 0, 0, 0, 593, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 2192, 0, 94708, 94708, 94708, 94708, 94708,
  94708, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 94708, 94708, 95775, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 95306, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 0, 73728, 77824, 0, 0, 0, 0, 0,
  69632, 0, 0, 0, 0, 0, 394, 0, 0, 0, 744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 657, 0, 0, 0, 0, 419, 419, 419, 419,
  90555, 90555, 90555, 90555, 90555, 0, 0, 419, 0, 318, 318, 466, 318, 318, 318, 419, 318, 419, 419, 419, 419, 419, 419,
  419, 419, 419, 419, 419, 419, 419, 419, 419, 90555, 90555, 419, 94725, 94725, 94725, 94725, 94725, 94751, 94725,
  94751, 94725, 94725, 94725, 94725, 94725, 94725, 94751, 94751, 94751, 94751, 94751, 94751, 94751, 94751, 94751, 94725,
  94725, 94751, 1, 16386, 3, 4, 94734, 94734, 94734, 95042, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 96113, 94734, 96114, 94734, 876, 878, 0, 0, 880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 507904,
  0, 0, 0, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95268, 94708, 94708, 94708, 94708,
  94708, 94708, 96239, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0,
  0, 0, 0, 95393, 0, 1187, 1189, 0, 0, 0, 872, 0, 874, 0, 876, 0, 878, 0, 0, 0, 0, 196608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 630, 0, 0, 0, 0, 0, 1214, 0, 0, 0, 0, 0, 0, 1219, 0, 0, 0, 0, 0, 0, 0, 1500, 0, 999424, 0, 0, 0, 1504, 0, 0, 94708,
  95566, 94708, 94708, 94708, 94708, 94708, 94708, 95572, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 643572,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 983540, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 95625, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95633, 94734, 94734, 94734, 94734,
  94734, 95985, 94734, 94734, 94734, 94734, 95989, 94734, 95991, 94734, 94734, 94734, 94734, 94734, 95338, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95852, 94734, 95854, 95855, 94734, 94734, 94734, 94734,
  95639, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 95650, 94734, 94734, 94734, 94734, 96106,
  94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 770574, 94734, 94734, 547, 548, 45699, 0, 0, 4, 82177, 0, 0,
  0, 0, 0, 0, 0, 0, 1488, 0, 0, 0, 0, 0, 0, 0, 0, 1514, 0, 0, 0, 0, 0, 0, 0, 0, 1850, 0, 0, 90538, 90538, 90538, 91968,
  90538, 90538, 90538, 90538, 91657, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  0, 0, 0, 678, 94708, 94708, 95784, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 754164, 94708, 94708, 94708, 94708, 1680, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1939, 90538, 90538,
  90538, 0, 0, 0, 1737, 0, 0, 0, 0, 0, 0, 94708, 94708, 94708, 94708, 94708, 508404, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 95957, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95285, 94708, 95288, 94708, 94708, 94708,
  94708, 94708, 1806, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2010, 90538, 0, 0, 94708, 94708, 94708, 94708, 96269,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 877044, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 95790, 94708, 94708, 94708, 582132, 94708, 94708, 94734, 94734, 94734, 94734, 96279, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 712704, 0, 0, 0, 90538, 90538, 90811, 90538, 90814, 90538,
  90538, 0, 94708, 94708, 94708, 96412, 94734, 94734, 94734, 96414, 0, 94708, 94708, 94734, 94734, 94708, 94734, 94734,
  96335, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 0, 0, 0, 1662, 0, 0, 0, 0, 0, 0, 0, 1926, 0, 0,
  0, 0, 0, 0, 0, 1930, 0, 73728, 77824, 0, 363, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 1674, 0, 0, 0, 0, 0, 0, 0, 0, 314,
  315, 316, 317, 0, 0, 0, 0, 0, 0, 331, 0, 363, 90538, 90538, 90538, 90538, 90538, 0, 0, 363, 0, 0, 0, 0, 0, 892928, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1477, 0, 0, 0, 0, 0, 90538, 0, 94726, 94726, 94726, 94726, 94726, 94752, 94726, 94752,
  94726, 94726, 94726, 94726, 94726, 94726, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94752, 94726, 94726,
  94752, 1, 16386, 3, 4, 94734, 94734, 95038, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 96253, 94734, 0, 0, 95254, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708,
  467444, 94708, 94708, 94708, 94708, 95597, 94708, 34159, 0, 1113, 0, 1115, 34159, 0, 1118, 0, 1120, 1252, 0, 0, 0, 0,
  0, 0, 1257, 0, 0, 0, 0, 0, 0, 0, 0, 521, 808, 523, 812, 0, 0, 0, 0, 594346, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 1032618, 94708, 94708, 594420, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 95578, 0, 0, 2050, 0, 0, 0, 2052, 0, 0, 0, 0, 0, 0, 0,
  0, 90538, 90538, 90538, 91110, 90538, 90538, 91115, 90538, 90538, 322, 0, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  233472, 0, 0, 0, 73728, 77824, 319, 0, 0, 0, 381, 69632, 381, 381, 0, 381, 0, 320, 381, 403, 0, 0, 0, 0, 90556, 90556,
  90556, 90556, 90556, 454, 454, 0, 454, 461, 461, 461, 467, 468, 461, 480, 461, 480, 480, 480, 480, 480, 403, 403, 403,
  480, 403, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 90556, 90556, 480, 94727, 94727, 94727, 94727, 94727,
  94753, 94727, 94753, 94727, 94727, 94727, 94727, 94727, 94727, 94753, 94753, 94753, 94753, 94753, 94753, 94753, 94753,
  94753, 94727, 94727, 94753, 1, 16386, 3, 4, 94708, 94708, 95002, 94708, 94708, 94708, 94708, 94708, 521, 522, 523,
  524, 0, 94734, 94734, 94734, 94734, 94734, 96119, 94734, 94734, 94734, 94734, 0, 0, 0, 0, 0, 1920, 0, 0, 1028096, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245760, 0, 0, 90538, 0, 94728, 94728, 94728, 94728, 94728, 94754, 94728, 94754,
  94728, 94728, 94728, 94728, 94728, 94728, 94754, 94754, 94754, 94754, 94754, 94754, 94754, 94754, 94754, 94728, 94728,
  94754, 1, 16386, 3, 4, 0, 0, 323, 323, 323, 0, 609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1476, 0, 0, 0, 0, 0, 0, 0, 0, 637, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 649, 0, 0, 0, 0, 0, 667648, 0, 688, 0, 0, 0, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0,
  1686, 0, 0, 1689, 0, 1691, 1692, 0, 0, 94734, 94734, 95039, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 500238, 94734, 94734, 94734, 0, 0, 650, 94708, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 96238, 94708, 94708, 94708, 94708, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 94734, 94734, 2108, 0, 2109, 90538, 962986, 90538, 90538, 90538, 90538, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 94708, 94708, 94708, 90538, 90538, 90538, 90538, 754090, 90538, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 90538, 91663, 90538, 90538, 90538, 94708, 94708, 406004, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 696820, 94708, 95967, 94708, 94708, 94708, 94708, 94708,
  94708, 840180, 94708, 29793, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  406030, 94734, 94734, 94734, 94734, 95654, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 0, 0, 0, 0, 2002, 90538, 90538, 90538, 90538, 90538, 487850, 90538, 90538, 90538, 90538, 90538, 90538, 90538,
  90538, 90538, 90538, 91662, 90538, 90538, 90538, 90538, 90538, 94708, 348660, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 872948, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 872974, 0, 94734, 94734, 348686, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734, 94734,
  94734, 94734, 94734, 975374, 0, 0, 0, 94734, 94734, 94734, 94734, 832014, 94734, 94734, 94734, 94734, 94734, 94734, 0,
  0, 0, 0, 0, 0, 1256, 0, 0, 1258, 0, 0, 0, 0, 0, 0, 0, 94708, 94708, 96325, 94708, 94708, 94708, 94708, 94708, 94708,
  0, 1392, 0, 1394, 0, 0, 1396, 0, 1398, 0, 0, 73728, 77824, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 390, 0, 0, 0, 0, 295412,
  94708, 94708, 94708, 95777, 95778, 94708, 94708, 94708, 94708, 94708, 94708, 95966, 94708, 94708, 94708, 94708, 94708,
  94708, 94708, 94708, 94708, 96084, 94708, 94708, 94708, 94708, 94708, 94708, 94708, 0, 1056768, 323, 0, 1056768, 0,
  1056768, 0, 0, 1056768, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90538, 1056768, 0, 0, 0, 0, 0, 0, 0,
  0, 1056768, 1056768, 0, 0, 0, 0, 0, 0, 1056768, 0, 1056768, 0, 0, 0, 0, 0, 1056768, 1056768, 0, 0, 1056768, 1056768,
  0, 0, 0, 0, 0, 0, 0, 1056768, 0, 0, 1056768, 0, 1056768, 1056768, 1056768, 1056768, 1057137, 1057137, 1056768, 0,
  1056768, 0, 0, 1057137, 0, 0, 0, 0, 0, 0, 1056768, 0, 1056768, 1056768, 0, 1056768, 0, 0, 0, 0, 1060864, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249856, 0, 1064960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 925696, 0, 0, 1065380,
  1065380, 1065380, 1065380, 0, 0, 0, 0, 0, 0, 0, 1065380, 0, 0, 0, 0, 0, 1056768, 0, 0, 1056768, 0, 0, 0, 0, 1056768,
  1056768, 0, 0, 0, 0, 0, 1056768, 0, 0, 0, 1065380, 1065380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1064960, 0, 0,
  0, 0, 1069056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 0, 0, 0, 1073152, 370, 370, 0, 0, 0, 0, 0, 370, 0, 0, 0, 0,
  0, 0, 0, 1701, 0, 0, 0, 0, 0, 0, 0, 0, 0, 958464, 0, 0, 90538, 90538, 90538, 90538, 1073152, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1073152, 1073152, 0, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152,
  1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 1073152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2204255, 323, 0, 1077248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282624, 282624, 282624, 0, 0, 8192, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 581632, 0, 0, 8192, 8192, 8192, 8192, 8192, 0, 0, 0, 0, 0, 8192, 8192, 8192, 8192, 8192, 8192,
  8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 0, 0, 8192, 0, 0, 0, 0, 0, 0, 8192, 8192, 8192, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2204256
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  156, 164, 172, 212, 180, 198, 205, 1201, 220, 239, 254, 227, 262, 792, 270, 343, 278, 286, 294, 302, 461, 883, 317,
  1154, 329, 1154, 1154, 747, 1154, 571, 190, 321, 411, 1154, 1174, 351, 359, 658, 374, 382, 390, 398, 1055, 516, 671,
  406, 423, 1048, 431, 439, 447, 455, 309, 473, 488, 496, 524, 532, 1041, 540, 740, 846, 548, 771, 556, 564, 580, 588,
  596, 604, 612, 620, 628, 636, 644, 652, 246, 666, 366, 679, 1114, 701, 480, 336, 709, 717, 725, 1062, 733, 757, 765,
  779, 787, 800, 815, 415, 503, 510, 823, 1076, 831, 839, 854, 862, 1137, 873, 693, 807, 891, 899, 907, 915, 1188, 1034,
  923, 931, 939, 947, 955, 963, 971, 979, 987, 995, 1003, 1011, 1019, 1027, 686, 1070, 1084, 1092, 1100, 1108, 1122,
  1130, 1145, 1153, 1154, 1163, 1171, 1182, 1154, 231, 1154, 1155, 1154, 1154, 186, 1154, 879, 865, 749, 465, 1196, 574,
  1249, 1209, 1211, 1211, 1211, 1215, 1211, 1211, 1222, 1218, 1226, 1230, 1234, 1238, 1242, 1246, 1253, 3052, 3052,
  3052, 1262, 3052, 1301, 1267, 1409, 1309, 1277, 1281, 3052, 3059, 3052, 3052, 1295, 3052, 3052, 3052, 3052, 3052,
  2392, 3052, 3052, 3052, 1286, 3052, 3052, 2126, 2128, 1299, 3052, 1360, 1360, 1305, 1309, 1309, 1309, 1316, 3052,
  1272, 2594, 2129, 3052, 3052, 3052, 2729, 1320, 1336, 1360, 1360, 1360, 1325, 1308, 1309, 1309, 1309, 1346, 3052,
  3052, 3052, 3052, 1291, 3052, 3052, 3052, 1309, 1309, 1329, 3052, 3052, 3052, 1943, 3052, 1564, 3052, 2133, 2136,
  2112, 2175, 2716, 1268, 2128, 1333, 1359, 1360, 1360, 2730, 1340, 2127, 1334, 1360, 1360, 2731, 1309, 1309, 1342,
  1311, 3052, 3052, 1268, 1371, 1360, 1366, 1377, 1335, 1413, 2728, 1417, 1398, 1312, 1403, 1373, 1426, 1430, 1434,
  1438, 1442, 1444, 1444, 1446, 1450, 1444, 1453, 1457, 1461, 1465, 1469, 1473, 1477, 1481, 1485, 1589, 3052, 3052,
  3015, 3052, 1650, 1737, 3052, 3052, 1742, 1648, 2997, 3052, 3052, 3052, 2592, 3052, 3052, 3052, 3052, 2312, 3052,
  3052, 3052, 2318, 3052, 3052, 3052, 3052, 3052, 1718, 3052, 1864, 3104, 2683, 2163, 2185, 1697, 3052, 2125, 1397,
  1402, 1310, 2124, 1407, 1367, 3052, 3052, 2902, 1507, 3052, 1513, 1574, 1523, 1527, 1531, 1534, 1538, 1542, 1548,
  1552, 3052, 2146, 3052, 3052, 3052, 2156, 1634, 1617, 1811, 1595, 1600, 1604, 1610, 3076, 3052, 1904, 1615, 3052,
  3052, 3052, 1420, 2657, 1639, 1393, 1621, 3052, 1628, 3150, 1632, 3052, 3052, 2278, 1638, 3052, 3052, 2826, 3052,
  3052, 3052, 1282, 1686, 3052, 3052, 3052, 1693, 3052, 3052, 3052, 1496, 3052, 3052, 3052, 3052, 2358, 3052, 3052,
  2569, 1897, 3052, 3052, 1701, 2617, 1706, 2462, 1661, 1711, 2949, 3052, 2623, 3052, 3147, 3052, 1701, 1722, 1714,
  1611, 1716, 2367, 3052, 2620, 2817, 2816, 3110, 1503, 1490, 3156, 2012, 3156, 2010, 2379, 1491, 1732, 2382, 1733,
  1492, 3052, 3052, 1489, 2085, 3052, 3052, 3052, 3052, 1293, 3052, 3052, 3052, 1746, 1750, 1754, 1758, 1761, 1765,
  1766, 3052, 2302, 2094, 3052, 2174, 1790, 3052, 2179, 1997, 1770, 3052, 1846, 1890, 2781, 2055, 1775, 1779, 1689,
  1783, 1794, 1801, 2152, 2142, 3052, 2364, 3052, 2376, 2391, 2387, 2398, 3052, 2396, 3052, 3052, 3052, 2402, 3052,
  3052, 1738, 1667, 3052, 3052, 3052, 2861, 1809, 3052, 1650, 1737, 3052, 1815, 1972, 2054, 2349, 2692, 1821, 1825,
  2181, 1888, 2287, 1831, 1591, 3052, 2630, 1841, 2655, 3124, 1502, 1850, 2346, 2196, 3052, 1883, 3052, 3052, 3052,
  2236, 2197, 1935, 3052, 3052, 2268, 1502, 3052, 2028, 1894, 1901, 1844, 1908, 3028, 3052, 2427, 3052, 2543, 3052,
  3052, 3052, 3052, 3052, 3052, 1645, 1917, 2783, 1925, 1930, 1941, 1939, 3052, 1947, 1952, 1993, 3052, 1996, 1961,
  1256, 1970, 1976, 1670, 1982, 1978, 1986, 1258, 1990, 2001, 2008, 2018, 3052, 3052, 3052, 2190, 3052, 3052, 2229,
  2022, 1606, 1879, 2801, 2035, 2039, 2043, 2047, 2050, 2053, 3052, 1554, 3052, 3052, 2059, 1519, 3031, 2065, 3052,
  2077, 1380, 2360, 2083, 2089, 2576, 2098, 1509, 3052, 3052, 3098, 3052, 1422, 2104, 2109, 2437, 2175, 2414, 3054,
  3052, 2611, 2116, 1817, 2123, 3052, 3052, 1797, 3052, 3052, 1497, 2188, 1558, 2925, 1955, 1571, 1386, 3052, 2140,
  3052, 1624, 3052, 3052, 3052, 1677, 2870, 1682, 3052, 3052, 2161, 2068, 1263, 2169, 1911, 3052, 2167, 3052, 2694,
  2932, 2938, 2944, 2031, 2953, 3052, 2725, 3052, 2448, 2503, 2582, 2934, 2510, 2439, 1788, 2071, 3052, 1860, 3052,
  3052, 1853, 1863, 3104, 1933, 2194, 1567, 1566, 2324, 2201, 2215, 2330, 2217, 1832, 2206, 1833, 1663, 2213, 2209,
  2221, 2764, 2201, 3052, 3052, 3052, 2990, 2252, 2256, 2260, 2262, 3052, 3052, 2983, 3052, 2966, 3052, 3052, 3052,
  1707, 1857, 3052, 2542, 3052, 3052, 3052, 3052, 3052, 3052, 1805, 3052, 2667, 2266, 3052, 1663, 2272, 2336, 1964,
  2276, 2282, 2600, 2833, 2073, 3052, 2285, 3052, 3052, 1649, 2029, 1289, 3009, 1389, 1580, 2291, 3052, 2642, 2782,
  1662, 1886, 2868, 2301, 2963, 2307, 2311, 3052, 2100, 3052, 3052, 3052, 2125, 1357, 1360, 1364, 1309, 2579, 3052,
  3052, 2568, 2316, 2741, 2322, 3052, 3033, 2940, 3003, 2516, 2520, 2528, 2544, 1886, 2328, 3052, 2334, 2340, 3052,
  3052, 1516, 2412, 3022, 1771, 1383, 2061, 2893, 3052, 2418, 2343, 3082, 3052, 3088, 3052, 2443, 2447, 2452, 2460,
  2468, 2887, 3052, 1728, 2457, 2466, 3052, 3052, 2614, 3052, 1920, 2972, 1869, 1873, 2469, 1577, 1583, 2947, 2753,
  2354, 2353, 1926, 1391, 1596, 2754, 3052, 3052, 3052, 3052, 3052, 1649, 3052, 3052, 2481, 2485, 2489, 2493, 2497,
  2499, 3052, 3052, 1804, 3052, 3052, 3052, 3052, 3052, 2530, 3052, 3052, 3052, 2534, 3052, 3052, 2539, 3052, 2548,
  2552, 2585, 2297, 3052, 3052, 2559, 2563, 2567, 3052, 2928, 3052, 3052, 3052, 2573, 3052, 3052, 2535, 2740, 2784,
  2589, 2430, 2718, 3052, 2079, 2031, 2598, 2640, 2385, 3052, 1321, 2646, 3052, 3052, 2157, 2652, 3052, 2470, 2661,
  2408, 2824, 2666, 2671, 2675, 2170, 2680, 3052, 2157, 2689, 1921, 2698, 2703, 2710, 3047, 3052, 1586, 3052, 2722,
  2648, 2735, 2745, 3070, 2117, 2296, 2294, 2092, 2750, 2758, 2119, 2118, 2025, 1561, 2768, 1725, 2790, 2772, 2788,
  2477, 2506, 2794, 2798, 2805, 2809, 2813, 3052, 3052, 3052, 3052, 2821, 3052, 2405, 2830, 2004, 2837, 2841, 2845,
  2849, 2853, 2856, 2859, 3052, 3052, 3052, 2865, 1349, 1353, 2224, 2907, 3041, 1957, 3052, 2874, 1673, 2878, 2882,
  2105, 2886, 2149, 3052, 3052, 1707, 2891, 1913, 2897, 2906, 2031, 2914, 3052, 1966, 2911, 2705, 3052, 3052, 2918,
  3052, 3052, 3052, 2922, 3052, 3052, 2713, 2662, 2627, 2636, 2746, 3052, 3052, 2685, 1502, 3052, 3052, 1837, 3052,
  2420, 1696, 3052, 1896, 3052, 1273, 3052, 2202, 1643, 1647, 3052, 1654, 1658, 3052, 2228, 1702, 2233, 2372, 2240,
  2244, 2248, 2960, 2970, 3052, 3052, 3052, 2976, 3052, 3052, 2424, 3052, 2014, 2434, 2699, 1889, 3052, 3053, 2980,
  3052, 3052, 2987, 1352, 2994, 3040, 3001, 3064, 3007, 3052, 3052, 1948, 3013, 3052, 3052, 3052, 3019, 3052, 1827,
  3037, 3045, 3051, 3052, 3058, 3052, 3053, 3063, 3052, 3052, 2555, 3052, 3052, 2303, 2453, 2135, 3068, 2632, 2370,
  2030, 3052, 3074, 3052, 3080, 3052, 3086, 3092, 2900, 3052, 3052, 2522, 3052, 3052, 2738, 1832, 3052, 3025, 2474,
  2956, 2524, 3096, 3102, 3052, 3108, 2761, 3052, 1544, 2351, 3052, 3052, 3052, 3052, 3052, 3052, 3052, 3052, 1291,
  1876, 3120, 3114, 3118, 3122, 3128, 3132, 3136, 3140, 3144, 2775, 3052, 3052, 3052, 3052, 3052, 2778, 2676, 1501,
  3052, 3052, 3154, 2706, 3052, 1786, 3052, 3052, 2604, 3052, 3052, 3052, 1865, 2608, 1678, 3052, 3052, 3052, 3052,
  3052, 3052, 3052, 2512, 3052, 3052, 2127, 2128, 4312, 3180, 3197, 3197, 3197, 3197, 4795, 4798, 3183, 3197, 3187,
  3197, 3188, 4310, 3182, 3197, 3197, 3192, 3197, 3196, 3197, 3201, 3206, 3210, 3219, 3220, 3220, 3220, 3213, 3202,
  3215, 3224, 3228, 3231, 3235, 3239, 3242, 3248, 3246, 3252, 3160, 3257, 3565, 3171, 3256, 5078, 3338, 3347, 4218,
  3639, 4926, 3844, 3804, 4943, 4925, 4926, 4926, 3317, 3727, 4926, 4926, 4926, 3289, 4680, 4926, 4926, 4926, 3364,
  3303, 3325, 3514, 3343, 3346, 4926, 4926, 4926, 3365, 3680, 3797, 3320, 4926, 3267, 4926, 4926, 3730, 4926, 4926,
  4926, 3732, 4926, 3289, 3274, 4926, 4926, 3264, 4471, 4045, 4029, 3331, 3301, 3308, 3308, 3308, 3308, 4050, 4926,
  4044, 3304, 3337, 3344, 3347, 3275, 4926, 4926, 4926, 3455, 4045, 4027, 4030, 3331, 3304, 3342, 3345, 3348, 3289,
  3273, 4926, 4926, 4044, 4045, 4045, 4030, 3332, 3308, 3308, 3302, 3363, 3304, 3353, 3348, 4926, 3275, 4926, 3960,
  3728, 4769, 4926, 3730, 3289, 3274, 4926, 4045, 4045, 4045, 4045, 4045, 4045, 4046, 3308, 3308, 3308, 4051, 3289,
  3274, 4177, 4045, 4048, 4049, 3308, 3308, 4049, 4926, 3276, 4191, 4926, 3282, 3515, 4926, 3317, 4285, 4926, 3317,
  4926, 3673, 4926, 3671, 4951, 4926, 3274, 4043, 4045, 4045, 3308, 4045, 4045, 4047, 3308, 4049, 4042, 4045, 4045,
  4045, 4031, 3301, 4046, 3308, 3308, 4051, 4048, 3308, 4049, 4926, 3364, 4926, 4926, 3523, 4288, 4043, 4045, 3308,
  4050, 4044, 4048, 4025, 3310, 4022, 3312, 4926, 3371, 5065, 4347, 4349, 3491, 3380, 3384, 3386, 3386, 3386, 3386,
  3392, 3443, 3452, 3397, 3430, 3386, 3386, 3393, 3433, 3401, 3386, 3387, 3423, 3388, 3407, 3422, 3445, 3427, 3437,
  3440, 3449, 3463, 3461, 3461, 3467, 3469, 3479, 3482, 3476, 3473, 3486, 3280, 3490, 3404, 3495, 3502, 3498, 3506,
  4926, 3521, 3281, 4687, 4926, 4926, 4926, 3522, 4926, 4926, 4199, 4926, 4926, 4926, 3621, 3358, 3258, 4926, 4926,
  4926, 3635, 3538, 4180, 4926, 4926, 3297, 4231, 4926, 4660, 3549, 4926, 3375, 4476, 4926, 3418, 3280, 4952, 3569,
  3572, 5050, 3576, 3579, 3581, 3587, 3588, 3583, 3592, 3596, 3597, 3601, 3602, 3606, 3608, 3608, 3608, 3613, 3612,
  3617, 4926, 4926, 3319, 4926, 4419, 4926, 4926, 4662, 3357, 4009, 4926, 4926, 3326, 4821, 3628, 4926, 5048, 4926,
  3521, 4926, 4181, 4821, 4926, 4926, 3837, 4926, 4926, 3349, 4543, 3678, 4926, 3563, 3545, 4588, 3929, 3804, 5013,
  4926, 4171, 3258, 3671, 3258, 4926, 3455, 4785, 4926, 3512, 4926, 4926, 3266, 4926, 3508, 4926, 4926, 4926, 3671,
  3654, 4926, 4926, 3670, 3677, 4728, 4926, 4926, 3418, 3523, 4777, 4926, 4926, 4926, 3679, 3684, 3258, 4926, 4926,
  3418, 4926, 3260, 3692, 3316, 4926, 3623, 4271, 4295, 4926, 4927, 4926, 3314, 3713, 3717, 4926, 4926, 3526, 3275,
  3716, 4926, 4926, 4926, 3688, 4926, 4949, 4926, 3260, 3693, 4952, 4926, 4926, 4926, 3730, 3896, 4927, 4926, 4926,
  4675, 3752, 3756, 3721, 3725, 4926, 4926, 4926, 3741, 4926, 3749, 3722, 4952, 4926, 3636, 3532, 4926, 3657, 3930,
  4947, 3366, 4926, 4926, 4926, 3733, 3828, 3259, 3761, 3765, 3754, 3786, 3723, 4926, 3660, 3736, 3412, 3805, 3755,
  3787, 3724, 4926, 4926, 4926, 3745, 3365, 4926, 4926, 4926, 3734, 3763, 4926, 4926, 4926, 3738, 4604, 3726, 3764,
  4926, 3679, 4245, 4952, 4926, 4926, 3531, 4926, 3728, 3828, 3791, 4926, 3727, 4693, 3522, 4709, 4524, 3802, 4040,
  4926, 3521, 4926, 3520, 3902, 4926, 4926, 4926, 3753, 3259, 4104, 3559, 3825, 3835, 4926, 4926, 4925, 3841, 3735,
  3849, 3855, 3859, 3863, 3871, 3875, 3878, 3882, 3866, 3871, 3871, 3868, 3869, 3870, 3886, 3886, 3886, 3888, 3901,
  4926, 4926, 4926, 3802, 4806, 4926, 3320, 3943, 3920, 4926, 3926, 3925, 3416, 4926, 4926, 3280, 4926, 4926, 4926,
  4923, 4926, 4923, 4926, 3934, 4926, 3941, 4926, 3730, 4270, 4276, 3947, 4926, 3414, 4926, 3733, 4926, 4926, 4926,
  3285, 3959, 4926, 4926, 3648, 4926, 3266, 3796, 4926, 4926, 3650, 4271, 3968, 4926, 3737, 3943, 3978, 3258, 4926,
  4926, 3707, 4038, 3994, 4926, 4926, 4926, 3819, 3739, 4926, 4694, 3897, 4180, 3283, 4501, 4926, 3318, 3671, 4926,
  4926, 3794, 4926, 3816, 4037, 3736, 4926, 3742, 4307, 4925, 3999, 4003, 4008, 4926, 3743, 4068, 4926, 3745, 4926,
  4926, 4926, 4054, 3801, 3729, 4926, 3320, 3671, 4926, 3258, 3736, 4332, 4333, 4926, 3775, 4110, 3523, 3936, 4001,
  4997, 4926, 3802, 4926, 3283, 4926, 4926, 4926, 3805, 3259, 4105, 4926, 4926, 3769, 3258, 4926, 3806, 4523, 3802,
  4926, 3802, 4926, 3417, 4172, 4926, 4078, 4926, 3804, 4926, 4926, 3962, 3735, 3845, 4926, 4926, 3268, 4926, 4926,
  4926, 3820, 3317, 4926, 3348, 4926, 4926, 3672, 4926, 4078, 4926, 3816, 4926, 4926, 4000, 4058, 4926, 4926, 4953,
  4089, 4926, 4926, 3797, 4926, 3845, 4926, 4926, 4926, 3890, 3804, 3318, 3672, 3671, 3643, 4926, 4926, 3374, 3819,
  3843, 4926, 3802, 3317, 4563, 4926, 4926, 4080, 4974, 3679, 4221, 4926, 4926, 3807, 4523, 3844, 3801, 4926, 3638,
  4926, 3843, 3844, 3803, 3636, 3532, 3803, 3637, 4926, 3635, 4097, 4926, 4096, 4926, 3819, 4926, 4220, 4926, 4926,
  4926, 3895, 4442, 3520, 4926, 3522, 4926, 3730, 4846, 3803, 3521, 3635, 4926, 4926, 3521, 4926, 3635, 3815, 4926,
  4420, 3635, 4926, 4101, 3524, 5055, 4291, 4926, 3820, 3797, 3730, 3896, 3800, 4926, 4926, 4590, 4926, 4125, 4129,
  4133, 4137, 4142, 4146, 4149, 4152, 4138, 4138, 4138, 4138, 4156, 4160, 4163, 4165, 4165, 4165, 4165, 4926, 4926,
  4926, 3906, 4926, 3525, 4290, 4926, 4926, 3809, 3258, 4169, 4926, 4453, 4522, 4926, 4926, 4263, 4925, 4926, 4926,
  3970, 3974, 4106, 4176, 4926, 4926, 3816, 4747, 4205, 3321, 4926, 4926, 3821, 3296, 4216, 4926, 3176, 4926, 3820,
  4180, 4926, 3523, 4302, 4229, 3258, 4926, 4926, 3831, 4476, 4303, 4926, 4926, 4926, 3910, 4235, 3851, 4926, 3806,
  3317, 4926, 4452, 4717, 4926, 4926, 4926, 3984, 3757, 4926, 4277, 4926, 4926, 4926, 4039, 3289, 3289, 3289, 3289,
  4926, 3524, 4289, 3275, 4926, 3417, 4926, 3283, 3558, 4669, 4926, 4926, 3957, 4926, 4208, 4272, 4296, 4926, 3908,
  3912, 4926, 3916, 4926, 3410, 4828, 4926, 4926, 4926, 4052, 3806, 3319, 3816, 3800, 4523, 4926, 3623, 4066, 4924,
  4926, 4926, 4926, 4053, 4453, 4926, 4524, 4926, 4926, 3744, 4925, 4926, 4926, 3982, 4499, 4922, 4926, 4923, 4926,
  3921, 4926, 4926, 3327, 4822, 4651, 4651, 4926, 4926, 4035, 4926, 4926, 3818, 4926, 4926, 4926, 4114, 3738, 4926,
  4926, 3740, 4926, 3818, 3740, 3816, 4926, 3741, 4926, 4926, 3740, 4926, 3738, 3738, 4926, 3819, 3741, 3800, 4926,
  3527, 3521, 4926, 4926, 4926, 4116, 3541, 4322, 4572, 4926, 3937, 4002, 4008, 4842, 3816, 4337, 4857, 4344, 3552,
  3555, 4353, 4357, 4362, 4367, 4370, 4373, 4360, 4363, 4377, 4381, 4362, 4362, 4362, 4385, 4385, 4385, 4385, 4387,
  4926, 4459, 4465, 4926, 4926, 4062, 4072, 3803, 4602, 4926, 4394, 4425, 3258, 4926, 4926, 4091, 3756, 4429, 4937,
  4435, 4926, 3972, 3296, 4926, 3284, 3989, 3734, 4577, 4483, 4926, 3984, 4792, 4926, 4926, 4926, 4699, 4560, 4926,
  4926, 4926, 4181, 4180, 4926, 4965, 3797, 4041, 4193, 4926, 4926, 4926, 4199, 4481, 4822, 4926, 4926, 4177, 4926,
  4458, 4464, 4926, 4926, 4178, 4926, 3809, 3532, 4926, 4926, 4179, 3817, 4488, 3258, 4926, 4926, 4187, 4415, 4965,
  4926, 4041, 5014, 4926, 3258, 4926, 4019, 3258, 4926, 3777, 4926, 3318, 4926, 4926, 3672, 4926, 4926, 3376, 4477,
  4926, 4926, 4197, 4926, 4588, 4496, 4465, 4926, 4039, 4009, 4926, 3728, 3521, 4926, 4926, 4330, 3801, 4926, 3281,
  4926, 4039, 4926, 3520, 4926, 4926, 3635, 4265, 4926, 4926, 4505, 4926, 4587, 4926, 4926, 4926, 4201, 4510, 4531,
  4926, 4926, 4198, 3292, 3809, 4511, 4952, 4926, 4041, 4926, 4199, 4038, 4692, 4258, 3276, 4515, 4926, 4926, 4240,
  4926, 3810, 4529, 4926, 4926, 4242, 3785, 3809, 4528, 4952, 4926, 4085, 4074, 4926, 3815, 4926, 3624, 4926, 4710,
  4465, 4926, 4169, 4926, 4452, 4926, 4523, 4535, 4926, 4926, 4711, 3373, 4926, 3801, 4926, 4855, 3282, 4926, 4926,
  4926, 4300, 3280, 4926, 4926, 5014, 5012, 4926, 4926, 4243, 3781, 5013, 4926, 4926, 4859, 4926, 4926, 4926, 4338,
  4569, 4926, 4547, 3798, 3732, 4926, 4810, 4585, 3805, 4550, 4596, 4553, 4609, 4615, 4631, 4620, 4621, 4625, 4616,
  4638, 4639, 4629, 4616, 4635, 4643, 4645, 4645, 4645, 4645, 3809, 3800, 4557, 4926, 4182, 4812, 3799, 4926, 4656,
  4926, 4926, 4254, 3800, 4673, 3278, 4926, 4679, 3515, 4673, 4926, 4926, 4389, 4235, 4926, 3738, 4926, 4684, 4926,
  4926, 4431, 3519, 4686, 4926, 4926, 4926, 4340, 4338, 4324, 4952, 4926, 4200, 4926, 4926, 4926, 3534, 3803, 4199,
  4857, 4691, 4650, 3807, 3295, 4926, 4208, 4067, 4925, 4746, 4926, 4926, 4707, 4926, 4715, 4264, 3277, 4980, 4926,
  4926, 4926, 4575, 4492, 3533, 4721, 4726, 4926, 4225, 4952, 4926, 3830, 4475, 3296, 4926, 4926, 4701, 4926, 4926,
  3624, 4038, 4692, 4652, 4926, 4236, 4926, 4926, 3272, 3289, 3521, 4266, 4926, 4926, 4439, 4926, 4053, 4732, 4740,
  4726, 4733, 4741, 4700, 4926, 4262, 4668, 4926, 3895, 4013, 4926, 3773, 4605, 3820, 3820, 3815, 4926, 3679, 4245,
  3725, 4855, 3809, 3800, 3808, 4524, 4926, 4926, 3708, 4040, 4702, 4926, 4694, 3741, 4745, 3372, 4926, 4926, 4457,
  4463, 4733, 4787, 4926, 4926, 4599, 4926, 3456, 4734, 4788, 4926, 4302, 4926, 5013, 4926, 5048, 4751, 4926, 4926,
  3801, 4926, 3928, 4926, 4926, 4926, 4658, 3816, 4756, 4926, 4102, 3279, 4926, 4926, 4926, 4663, 3457, 4735, 3815,
  4926, 4316, 4926, 4926, 3988, 3993, 3456, 4734, 4757, 4926, 4318, 4926, 4926, 3700, 3164, 4752, 4926, 4926, 3803,
  4926, 4761, 4691, 3807, 4926, 3732, 4926, 4926, 4446, 4926, 3927, 4926, 4338, 4324, 4926, 4281, 4926, 4926, 3926,
  4700, 4052, 4064, 4736, 4926, 4339, 4325, 4926, 4177, 4045, 4045, 4045, 4027, 3333, 4926, 5077, 4256, 4926, 4340,
  4326, 4926, 4926, 4926, 4588, 4694, 4926, 3926, 4926, 4926, 3800, 4695, 4926, 3928, 4926, 4926, 3348, 4926, 4926,
  4802, 4104, 4926, 4389, 4926, 3739, 3816, 3739, 3739, 4811, 4926, 4926, 4810, 3800, 4816, 4252, 4926, 4397, 5069,
  4926, 4418, 3735, 4926, 3373, 4926, 4926, 4926, 3804, 4200, 4183, 3800, 4181, 4811, 4926, 4183, 3733, 4182, 4812,
  4181, 4811, 3731, 4182, 4186, 4120, 3808, 4123, 4184, 3732, 4183, 4181, 4185, 4826, 3367, 4839, 4833, 4834, 4838,
  4926, 4421, 3814, 4926, 4926, 3700, 4932, 3167, 4926, 4445, 4926, 4926, 4610, 3359, 3961, 3964, 4804, 4926, 4450,
  4926, 3630, 4853, 4863, 3800, 4865, 4869, 4870, 4874, 4878, 4881, 4885, 4892, 4889, 4896, 4907, 4910, 4904, 4899,
  4900, 4914, 4918, 4918, 4918, 4918, 4920, 4926, 4926, 4611, 4009, 3699, 4931, 3166, 4926, 4469, 4926, 4926, 4112,
  4186, 4592, 4941, 4926, 4970, 4926, 4926, 4957, 4963, 3644, 4926, 3730, 4969, 3914, 4926, 4926, 4926, 4859, 3162,
  3166, 4926, 4040, 3258, 4926, 3522, 4926, 3731, 3798, 4926, 4926, 4589, 3732, 3544, 3671, 4926, 4264, 4926, 4926,
  4926, 4979, 4015, 4926, 4521, 4926, 4841, 3276, 4985, 4990, 4531, 4984, 4989, 4530, 4926, 4537, 3634, 4926, 3534,
  4722, 4700, 4506, 4041, 4926, 4926, 4649, 4926, 3963, 4768, 4926, 4926, 4667, 4926, 4994, 3671, 4263, 4926, 4541,
  4926, 4926, 4244, 3724, 4680, 4926, 4840, 4926, 4557, 4959, 4581, 4926, 5001, 5006, 4926, 4566, 4506, 4926, 3998,
  4002, 4007, 5011, 4015, 3805, 4926, 3373, 3281, 4926, 5018, 5028, 4975, 5019, 5029, 4530, 4926, 4575, 4211, 4484,
  3706, 5023, 4039, 4926, 4576, 4212, 4822, 3950, 4926, 4104, 4926, 4586, 3515, 3953, 3364, 3819, 4926, 4926, 4716,
  4926, 3258, 4703, 4926, 3808, 4524, 3801, 5027, 5033, 4926, 4926, 4764, 4926, 3891, 5028, 5034, 4926, 4588, 4519,
  3373, 4177, 3802, 4926, 4084, 4073, 4926, 3807, 4926, 4926, 3816, 4674, 3275, 3820, 3635, 4926, 4588, 4926, 4926,
  4936, 3731, 3800, 4926, 4926, 4773, 4102, 4589, 4926, 4926, 4926, 4926, 3276, 4249, 3174, 4926, 4926, 4926, 4943,
  5039, 4926, 4926, 4926, 5002, 5038, 4952, 4926, 4926, 4773, 4103, 4702, 4926, 4926, 4926, 4775, 4779, 4389, 4235,
  4926, 4926, 4780, 5007, 4390, 4926, 4926, 4926, 4781, 3258, 3707, 4926, 3820, 3520, 3709, 3729, 4926, 4926, 4819,
  3815, 4591, 4926, 4926, 4926, 4829, 4926, 4389, 4926, 4926, 4926, 4848, 4926, 3737, 4926, 3665, 3277, 5046, 3666,
  4926, 3736, 3737, 3665, 4926, 3737, 3280, 3355, 5043, 3736, 5054, 3663, 4406, 4767, 4400, 4409, 4403, 4411, 5072,
  5072, 5071, 5072, 5059, 5061, 5063, 4926, 4332, 4926, 4610, 4009, 4926, 3697, 3704, 4092, 5076, 4926, 4926, 4926,
  4849, 4926, 4, 8, 16, 32, 64, 131072, 8388608, 33554432, 67108864, 1073741824, 0, 8388608, 8388608, 8388608,
  268435456, 4194304, 0, 0, 251723776, 0, 276824064, 8388608, 553648128, -2130706432, -2130706432, 16777216, 16777216,
  16784896, 16781312, -2130706432, 16777216, 16777216, 16781312, 269639680, 1351680, -2130706432, 1122304, 16777216,
  16777216, 16777216, 16777216, 16777218, 754974722, 754974722, 754974722, 218103810, 754974722, 18874368, 18874368,
  18878464, 555745280, 555745280, 150994946, 150994946, 754974722, -1392508926, 754974722, 218103810, 218103810,
  754974722, 150994946, 150994946, 150994946, 150994946, 150994946, 754974722, 218103810, 150994946, 754974722,
  754974722, 150994946, 757071874, 754974722, 4194304, 4194432, 12583040, 20971648, 12582912, 20971712, 20971648,
  20971712, 557842560, 20971648, -2126512000, 20971648, 20971648, -2126504256, -2126504256, -2126504256, -2126504256,
  -2126504254, -2126504256, -2126504256, 759169154, 759169154, -1992286526, 524288, 524288, 1073741824, 0, 0, 0,
  -2147483648, 128, 3072, 3584, 0, 0, -2147483648, 16777216, 0, 0, 0, 2097152, 2097152, 2097152, 0, 0, 0, 8, 0, 0, 0,
  16, 0, 0, 0, 20, 925568, 2097152, 2097152, 2097152, 2097152, 0, 1073741824, 0, -1073741824, 0, 0, 0, 1039, 64,
  4194368, 4194368, 4194368, 4288, 4288, 4288, 4194368, 4194368, 4194368, 4194368, 4194304, 4194368, 0, 0, -1879048192,
  0, 0, 0, 8192, 0, 0, 0, 344, 3072, 0, 0, 32, 524288, 4194304, 192, 192, 192, 192, 4194368, 4194368, 4288, 0, 256, 256,
  512, 4288, 256, 256, 256, 4096, 4096, 4096, 0, 0, 0, -2097152000, 4288, 256, 256, 4096, 2097152, 4194304, 8388608,
  67108864, 268435456, 1073741824, 4288, 0, 0, 0, 512, 0, 0, 32, 2048, 268435456, 536870912, 0, 0, 0, 768, 6144, 262144,
  80, 528, 262160, 524304, 1048592, 268435472, 16, 16, 16, 16, 28, 16, 131088, 16, 16, 20, 16, 1049104, 1572880, 524304,
  524304, 48, 524304, 16, 16, 21, 112, 21, 16, 28, 0, -899678208, 0, 0, 16, 135424, 1247805440, 0, 0, 0, 262144, 0, 2,
  16, 17, 16, 16, 528, 16, 528, 1048592, 1048592, 16, 16, 17, 20, 560, 16, 528, 1049136, -164575404, -164575404,
  -164575403, 16, 48, 16, 16, 165675008, 528, 16, 48, 16, 20, 24, 560, 48, 256, 512, 1024, 4096, 8192, -164625872,
  -164625872, -164625872, -164625872, -164575403, -164625872, -164624528, -164625872, -164624528, -164624528,
  -164624464, -164575372, -164313228, -164100172, -164313228, -164575372, -164313232, -164100176, -164575372,
  -164575372, -164575372, -164575372, -164575376, -164575372, -164575376, -164100175, -164575372, -164313228,
  -164575372, 536936448, 16, 16, 20, 48, 53, 117, 140521492, 140571932, 140571933, 140571964, -164575372, 140571932,
  140571964, 140571932, 140571932, -164313228, -26200268, 0, 0, -1023410176, 0, 65536, 262144, 524288, 0, 0, 256, 0,
  239075328, 0, 0, 2048, 0, 0, 0, 1024, 0, 1, 4096, 0, 4194304, 8388608, 0, 0, 0, 1840, 28672, 16384, 16384, 65536,
  65536, 0, 1026, 16384, 0, 65536, 0, 268435456, 66048, 16384, 65536, 268435456, 67108868, 0, 67108868, 268437504,
  67108868, 64, 256, 0, 0, 288, 82432, 65536, 0, 0, 0, 1082130432, 0, 16384, 1076101120, 0, 0, 268435456, 1076101120,
  344506528, -2097147888, -2097147888, -2097147888, -1819750272, -1819750272, -1819750272, 277467296, 277467296,
  -1870081888, 277475744, -1021046768, 277467296, 277467296, 277467296, 277467296, -1870081888, -1870081888,
  -1836527456, -1819750240, -1836527455, -1819750224, -1819750224, -1819750224, -1819750224, -1870015839, -1819750224,
  -1819750224, -1870015839, -1819750224, -1819750224, -1819750224, -1080370048, -1080370048, -1080370048, -1080370048,
  -1080370043, -1080370044, -1080370044, -1080370044, -1080370044, -1080370043, -1080370000, -1080370000, -1080370012,
  0, 66048, 0, 0, 1, 6, 0, 0, 2359296, 1073741824, 0, 37, 0, 343932928, 0, 0, 0, 2048, 524288, 8388608, 0, 0,
  -2097152000, 0, 0, 0, 2816, 118912, 276824064, 0, 0, 1, 14, 0, 53376, -1870659584, 0, 0, 490733568, 0, 0, 1224736768,
  0, 1, 0, 2, 2, 0, 0, 127360, 0, 0, 0, 4096, 0, 0, -1837105152, -1820327936, 0, 0, 0, 3072, 2048, 2097152, 8388608,
  67108864, 268435456, 128, 32768, 524288, 75497472, 4096, 32768, 524288, 58720256, 268435456, 256, 12288, 0, 0, 4, 16,
  32, 41943040, 58720256, 0, 0, 4, 64, 33554432, 0, 0, 131072, 524288, 1048576, 125829120, 134217728, -1342177280, 0, 0,
  58720256, 67108864, 134217728, 268435456, 536870912, -2147483648, 0, 0, 32768, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0,
  0, 0, 6, 1024, 16777216, 33554432, 131072, 524288, 1048576, 58720256, 0, 128, 3072, 32768, 131072, 524288, 1048576,
  16777216, 128, 32768, 524288, 33554432, 268435456, -2147483648, 0, 0, 0, 262144, 2097152, 268435456, 0, 32768, 524288,
  0, 16, 0, 64, 32768, 524288, 1048576, 33554432, 268435456, 131072, 524288, 1048576, 33554432, 67108864, 134217728,
  32768, 33554432, 268435456, -2147483648, 16777216, 288, 0, 0, 0, 1048576, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 256,
  512, 131072, 268435456, 0, 0, 0, 16384, 0, 0, 0, 32768, 100663296, 1048576, 16777216, 33554432, 33554432, -2147483648,
  0, 0, 4, 896, 6144, 536870912, 32, 0, 0, 6, 33554432, 0, 1048608, 0, 0, 8, 32, 0, 0, 296, 16, 0, 16, -2147483648, 0,
  16, 296, 4194320, 32832, 8192, 4194320, 39850256, 1208090624, 1224867840, 1208090624, 1208090626, 1247940880,
  241258768, 1247940880, 1247940880, -899542768, 1247940880, 1247940880, 1247940880, 1247940880, 241258768, 241258768,
  1208090922, 241258768, 241258768, 241258768, 778129680, 1315000592, 241258768, 241258768, 778129680, 1526603668,
  1526603668, 1526603668, 1526603668, 0, 0, 8, 128, 512, 1, 2, 8, 32, 256, 1048576, 256, 1048576, 4194304, 33554432, 0,
  8, 16, 0, 0, 8, 10128, 49152, 262144, 1224736768, -2147483648, 0, 0, 16, 16, 39845888, 0, 0, 0, 82432, 1207959552, 0,
  0, 0, 131072, 0, 0, 0, 147456, 86272, 241172480, 0, 0, 16, 128, 256, 10, 131360, 0, 0, 16, 4352, 778043392, 0,
  1314914304, 0, 1, 0, 1048576, -2147483648, 0, -2147483648, 20, 925568, 1525678080, 0, 0, 0, 524288, 0, 32768, 0, 2,
  131072, 1073741824, 0, 0, 37, 896, 276480, 243269632, -1073741824, 0, 131072, 2097152, 4194304, 33554432, 81920,
  100663296, 0, 0, 48, 512, 20, 8064, 131072, 786432, 3145728, 3145728, 12582912, 33554432, 268435456, 1073741824, 4,
  16, 128, 256, 512, 7168, 786432, 1048576, 2097152, 2097152, 12582912, 268435456, 1073741824, 0, 0, 256, 1048576,
  4194304, 0, 536870912, 0, 16, 256, 4096, 4194304, 4194368, 4194304, 4194368, 0, 4194304, 4194304, 128, 128, 128, 128,
  192, 192, 0, 16384, 65536, 67108864, 0, 0, 0, 2097152, 0, 0, 4194304, 4194304, 4194304, 4194304, 4194368, 4194368,
  4194368, 0, 0, 0, 48, 256, 1536, 786432, 1048576, 8388608, 1073741824, 0, 128, 256, 512, 1024, 8192, 262144, 8388608,
  16777216, 33554432, 7168, 786432, 1048576, 8388608, 0, 0, 16384, 65536, 0, 0, 128, 1536, 0, 128, 256, 7168, 786432,
  786432, 8388608, 0, 0, 128, 7168, 32768, 0, 2048, 8388608, 0, 0, 2048, 0, 2048, 0, 16777216, 0, 0, 0, 34816, 4096,
  -2147483648, 0, 0, 128, 32768, 524288, 0, 0, 524288, 128, 0, 1024, 1024, -2147483136, 0, 8200, 8200, 32, 8200,
  1064960, 536870912, 8200, 67117064, 184649728, 184649728, 184649728, 184650752, 251766792, 251766792, 251766792,
  251766792, 251766792, 251766792, 201369608, 201369608, 184650784, 201369928, 201369928, 201369928, 201369944,
  201369928, 201369928, 201369944, 234989576, 201369928, 252291080, 251766792, 251766792, 252291080, 251766792,
  251766792, 252292104, 251766792, -1895716344, 1602726927, 1602726927, 1602726927, 1602726927, 8, 8192, 0, 0, 256,
  4096, 0, 184614912, 0, 0, 0, 4194304, 0, 0, 0, 32, 512, 524288, 0, 0, 0, 33, 43008, 251723776, 0, 0, 384, 1073741824,
  43008, 201326592, 0, 0, 0, 8388608, 0, 0, 1056, 0, 328, 0, 1, 6, 1024, 2048, 262144, 4194304, 16777216, 0, 234946560,
  0, 0, 3072, 4096, 524288, 8388608, 0, 252248064, 1032, 0, 520, 0, 1039, 43008, 528941056, 1073741824, 0, 262144, 0, 0,
  0, 12582912, 65536, 50331648, 0, 0, 3072, 32768, 131072, 33554432, 268435456, 8192, 65536, 117440512, 0, 1, 2048, 0,
  0, 1048576, 0, 128, 0, 268435456, 320, 0, 0, 0, 16777216, 0, 8, 0, 14, 1024, 8192, 65536, 262144, 25165824, 262144,
  125829120, 268435456, 1073741824, 0, 0, 65536, 16777216, 33554432, 65536, 16777216, 100663296, 0, 1, 1073741824, 512,
  4096, 2097152, 4194304, 25165824, 100663296, 268435456, 1073741824, 0, 0, 1024, 0, 4096, 2097152, 0, 0, 1024, 262144,
  8388608, 16777216, 16777216, 16777218, 16777472, 16777728, 16781312, 1024, 4096, 0, 0, 4352, 2097152, 131072, 786432,
  262144, 4194304, 536870912, 1073741824, -2147483648, 0, 0, 67108864, 2, 0, 2, 0, 2, 1026, 0, 0, 16384, 32768, 262144,
  4194304, 0, 16384, 16777216, 0, 2, 16, 16, 2, 536936448, 16810000, 67108868, 75497732, 33564833, 33562785, 33563297,
  50340001, 1182802341, 246423845, 1182802341, 1182802341, 1182802341, 1182802341, 109060517, 243278117, 243278117,
  318777505, 244326693, 246423845, 244326693, 244326693, 246423845, 246423845, 244326693, 109060517, 109322661,
  109060517, 109846949, 109322661, 1182802341, 109060517, 1182802341, -830194779, -830194779, -830194779, -830194779, 0,
  0, 8192, 32768, 262144, 0, 256, 75497472, 0, 2, 32, 2, 2, 32, 34, 32, 32, 32, 24, 24, 24, 32, 32, 32, 56, 32, 128,
  10240, 33554432, 0, 2, 64, 0, 0, 2048, 32768, 37, 384, 8192, 109051904, 37, 243269632, 0, 0, 8192, 138412032, 0,
  1056768, 0, 245366784, 384, 109051904, 1073741824, 0, 8, 64, 0, 1, 2, 4, 0, 270336, 794624, 0, 0, 16384, 1048576, 0,
  65536, 16384, 131072, 0, 786432, 0, 786432, 0, 134217728, 0, 536870912, 0, 256, 8388608, 0, 0, 16384, 1056768, 6144,
  262144, 8388608, 201326592, -1073741824, 0, 1024, 2048, 262144, 16777216, 67108864, 268435456, 0, 0, 256, 8388608,
  67108864, 2048, 16777216, 67108864, 268435456, 131072, 0, 524288, 0, 10, 0, 0, 64, 32768, 256, 67108864, 1073741824,
  0, 0, 256, 512, 6144, 201326592, 1073741824, 512, 2048, 16777216, 268435456, 131072, 0, 134217728, 0, 0, 0, 536870912,
  0, 0, 512, 6144, 134217728, 1073741824, -2147483648, 0, 0, 2048, 268435456, 0, 0, 49280, 524288, 4096, 1073741824, 0,
  0, 53376, 524288, 0, 16384, 67108864, 256, 0, 32768, 268451840, 7, -1073741824, 268451840, 0, 33554432, 262144, 128,
  0, 0, 640, 0, 50331648, 0, 4, 384, 8388608, 64, 16384, 67108864, 134217728, 536870912, 0, 2, 8, 512, 1024, 2048, 0,
  128, 536870912, -1073741824, 0, 128, 256, 0, 0, 0, 65536, 0, 0, 0, 1920, 0, 268451840, 268451840, 32768, 4194304,
  1073741824, 0, 16, 32768, 0, 0, 33554432, -2147483648, 805453824, 0, 0, 262144, 2097152, 67108864, 256, 822231040,
  822231040, 822231040, 822231040, 33024, 805519360, 805519360, 805519360, 805519360, 805519360, 805521408, 822231040,
  805519368, 872562688, 822231040, 822231040, 822231040, 805519360, 805519360, 822231040, 822231040, 822231296,
  822231040, 805453824, 805453824, 805453824, 822231040, 822231040, 822231040, 960132912, 960132912, 960132912,
  960132912, 7, 0, 0, 0, 33554432, 0, 128, 0, 805437440, 0, 0, 65536, 16384, 0, 16384, 65536, 262144, 2097152,
  805502976, 0, 0, 0, 100663296, 0, 0, 822214656, 0, 0, 0, 41943040, 872546304, 0, 0, 0, 134217728, 1840, 28672,
  960102400, 0, 0, 0, 163577856, 0, 256, 1048576, 0, 0, 1, 2, 0, 131072, 805306368, 0, 0, 0, 268435456, 0, 4194304, 0,
  196608, 0, 0, 65536, 131072, 0, 0, 0, 18432, 0, 0, 0, 117440512, 28672, 131072, 1572864, 18874368, 134217728,
  134217728, 805306368, 0, 0, 119424, 0, 1536, 4096, 8192, 16384, 131072, 1572864, 16777216, 0, 131072, 1572864,
  2097152, 16777216, 134217728, 0, 16384, 131072, 16777216, 805306368, 0, 262144, 4194304, 1073741824, 0, 0, 131072,
  16777216, 268435456, 0, 0, 0, 8388608, 67108864, 0, 16, 131072, 24, 0, 2, 0, 2048, 0, 131072, 16777216, 0, 0, 187520,
  1572864, -1082130432, 0, 0, 0, 6144, 134217728, 8192, 131072, 1572864, 16777216, 268435456, 536870912, 0, 1024,
  131072, 1572864, 16777216, 16777216, 33554432, 16777472, 553648128, 553648128, -2130706432, 131072, 16777216, 0, 2048,
  16, 0, 32832, 0, 32, 512, 524288, 1048576, 0, 0, 0, 32768, 1048576, 0, 32, 4194304, 67108864, 268435456, 0, 0, 1, 0,
  0, 32, 4194304, 0, 0, 0, 512, 512, 512, 512, 512, 512, 0, 0, 512, 16384, 0, 0, 4, 8388608, 0, 0, 2097152, 1073741824,
  0, 2048, 1048576, 0, 8388608, 0, 67108864, 0, 0, 6144, 1073741824, 0, 33554496, 0, 8388608, 1048576, 4097, 0,
  16777216, 0, 16777216, 0, 33620032, 16777216, 150994944, 17152, 2114304, 17156, 1065728, 1224755072, 1224755072,
  1224755072, 1224755072, 486539264, 486539264, 1065728, 486539264, 490881024, 1027735552, 1564606464, 490864640,
  490864640, 490864640, 490864640, 1224753536, 490864640, 1224753536, 1224754048, 1224754048, 1224753536, 1224754048,
  1224754048, 151536384, 1224754048, 151014144, 1224754048, 1224754048, 1224754048, 151012096, 151012096, 151012096,
  151012096, 1224753536, 1224755072, 1224755072, 1224758145, -922425448, -922425448, -922425448, -922425448, 0, 0,
  16777216, 33554432, 0, 0, 0, 0, -1073741824, 32, 64, 256, 131072, 8388608, 150994944, 0, 0, 0, 318767104, 16384,
  1224736768, 0, 0, 33554432, 33554432, 1027604480, 1564475392, 0, 0, 50331648, -2147483648, 0, 0, 0, 7168, 384,
  1224736768, 0, 0, 67108864, 256, 0, 896, 0, 0, 201326592, 0, 4992, 0, 0, 0, 486539264, 16384, 16777216, 134217728,
  1073741824, -2147483648, 469762048, 0, 0, 0, 805306368, 8, 16, 128, 1536, 8192, 8192, 49152, 262144, 16777216,
  134217728, 1, 0, 0, 1048576, 12582912, 268435456, 1073741824, 0, 128, 512, 16384, 16777216, 16777216, 134217728,
  1073741824, 0, 0, 402653184, 0, 0, 0, 1073741824, 0, 0, 8, 16, 128, 512, 8192, 131072, 33554432, 67108864, 1073741824,
  512, 8192, 16384, 32768, 262144, 16777216, 262144, 16777216, 1073741824, -2147483648, 0, 8, 8192, 32768, 262144,
  -2147483648, 34, 70, 70, 2, 10, 0, 0, 268435456, 8, 8388608, 268435456, 70, 0, 0, 0, 1073741825, 58, 56, 56, 58, 58,
  58, 0, 0, 268435456, 536870912, 0, 58, 58, 56, 56, 56, 56, 4, 64, 0, 0, 8388608, 16777216
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "EOF",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "URIQualifiedName",
  "URILiteral",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "S",
  "S",
  "CommentContents",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'after'",
  "'all'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'any'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'binary'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'contains'",
  "'content'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'diacritics'",
  "'different'",
  "'digit'",
  "'distance'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'entire'",
  "'eq'",
  "'every'",
  "'exactly'",
  "'except'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'from'",
  "'ft-option'",
  "'ftand'",
  "'ftnot'",
  "'ftor'",
  "'full'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insensitive'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'is'",
  "'item'",
  "'language'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'levels'",
  "'lowercase'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'most'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'not'",
  "'occurs'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'paragraph'",
  "'paragraphs'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'phrase'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'private'",
  "'processing-instruction'",
  "'property'",
  "'relationship'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'same'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sensitive'",
  "'sentence'",
  "'sentences'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'stemming'",
  "'stop'",
  "'strict'",
  "'strip'",
  "'stylesheet'",
  "'switch'",
  "'text'",
  "'then'",
  "'thesaurus'",
  "'times'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'uppercase'",
  "'using'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'weight'",
  "'when'",
  "'where'",
  "'wildcards'",
  "'window'",
  "'with'",
  "'without'",
  "'word'",
  "'words'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 4096
    return
      if ($result != 0) then
      (
        $result mod 512 - 1,
        $begin,
        $end - $result idiv 512
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 8
    let $i0 := $t * 2214 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 8
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 8 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(82, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 25) then                 (: CommentContents :)
            let $state := p:shiftT(25, $input, $state)      (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(36, $input, $state)                (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:shiftT(49, $input, $state)                (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 24) then                       (: S^WS :)
      let $state := p:shiftT(24, $input, $state)            (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MainModuleSequence (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 52) then                         (: ';' :)
        let $state := p:lookahead2W(242, $input, $state)    (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 1                                 (: EOF :)
       or $state[$p:lk] = 564) then                         (: ';' EOF :)
        $state
      else
        let $state := p:shift(52, $input, $state)           (: ';' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:l1] eq 255) then                    (: 'xquery' :)
            let $state := p:lookahead2W(178, $input, $state) (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                                'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                                'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                'to' | 'treat' | 'union' | 'version' | '|' | '||' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 61695                    (: 'xquery' 'encoding' :)
                or $state[$p:lk] = 125695) then             (: 'xquery' 'version' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-VersionDecl($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-MainModule($input, $state)
        return p:parse-MainModuleSequence-1($input, $state)
};

(:~
 : Parse MainModuleSequence.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MainModule($input, $state)
  let $state := p:parse-MainModuleSequence-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModuleSequence", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:shift(184, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(244, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 200) then                        (: 'private' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 244) then                      (: 'variable' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotatedDecl", $count, $begin, $end)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDefaultValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-TransformExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TransformExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shiftT(51, $input, $state)            (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-TransformExpr-1($input, $state)
};

(:~
 : Parse TransformExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(98, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-TransformExpr-1($input, $state)
  let $state := p:shift(168, $input, $state)                (: 'modify' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TransformExpr", $count, $begin, $end)
};

(:~
 : Try parsing TransformExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(98, $input, $state)                (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shiftT(51, $input, $state)                (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-TransformExpr-1($input, $state)
  let $state := p:shiftT(168, $input, $state)               (: 'modify' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(205, $input, $state)                (: 'replace' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'value' :)
      let $state := p:shift(243, $input, $state)            (: 'value' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(182, $input, $state)            (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(251, $input, $state)                (: 'with' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReplaceExpr", $count, $begin, $end)
};

(:~
 : Try parsing ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(205, $input, $state)               (: 'replace' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'value' :)
      let $state := p:shiftT(243, $input, $state)           (: 'value' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shiftT(182, $input, $state)           (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  let $state := p:shiftT(251, $input, $state)               (: 'with' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NewNameExpr", $count, $begin, $end)
};

(:~
 : Try parsing NewNameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(204, $input, $state)                (: 'rename' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NewNameExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RenameExpr", $count, $begin, $end)
};

(:~
 : Try parsing RenameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(204, $input, $state)               (: 'rename' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(105, $input, $state)                (: 'delete' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DeleteExpr", $count, $begin, $end)
};

(:~
 : Try parsing DeleteExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(105, $input, $state)               (: 'delete' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(179, $input, $state)           (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TargetExpr", $count, $begin, $end)
};

(:~
 : Try parsing TargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:shift(78, $input, $state)         (: 'as' :)
          let $state := p:lookahead1W(111, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 128) then              (: 'first' :)
              let $state := p:shift(128, $input, $state)    (: 'first' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(158, $input, $state)    (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExprTargetChoice", $count, $begin, $end)
};

(:~
 : Try parsing InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:shiftT(78, $input, $state)        (: 'as' :)
          let $state := p:lookahead1W(111, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 128) then              (: 'first' :)
              let $state := p:shiftT(128, $input, $state)   (: 'first' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(158, $input, $state)   (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SourceExpr", $count, $begin, $end)
};

(:~
 : Try parsing SourceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(151, $input, $state)                (: 'insert' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SourceExpr($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InsertExpr", $count, $begin, $end)
};

(:~
 : Try parsing InsertExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(151, $input, $state)               (: 'insert' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(179, $input, $state)           (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SourceExpr($input, $state)
  let $state := p:try-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shift(259, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(231, $input, $state)    (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shiftT(259, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(231, $input, $state)    (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-NameTest($input, $state)
        return p:try-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorList", $count, $begin, $end)
};

(:~
 : Try parsing CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-NameTest($input, $state)
  let $state := p:try-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(90, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(233, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchClause", $count, $begin, $end)
};

(:~
 : Try parsing CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(90, $input, $state)                (: 'catch' :)
  let $state := p:lookahead1W(233, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryTargetExpr", $count, $begin, $end)
};

(:~
 : Try parsing TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(234, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryClause", $count, $begin, $end)
};

(:~
 : Try parsing TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(234, $input, $state)               (: 'try' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-TryTargetExpr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(176, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 90) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:try-CatchClause($input, $state)
    let $state := p:lookahead1W(176, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 90) then                         (: 'catch' :)
        $state
      else
        p:try-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryCatchExpr", $count, $begin, $end)
};

(:~
 : Try parsing TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-TryClause($input, $state)
  let $state := p:try-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shift(57, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Try parsing NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shiftT(57, $input, $state)            (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(63, $input, $state)            (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shift(27, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shift(58, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Try parsing GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:shiftT(60, $input, $state)            (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shiftT(27, $input, $state)            (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shiftT(53, $input, $state)            (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shiftT(58, $input, $state)            (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(62, $input, $state)            (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Try parsing ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(252, $input, $state)                (: 'without' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:shift(96, $input, $state)                 (: 'content' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-UnionExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTIgnoreOption", $count, $begin, $end)
};

(:~
 : Try parsing FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(252, $input, $state)               (: 'without' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:shiftT(96, $input, $state)                (: 'content' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-UnionExpr($input, $state)
  return $state
};

(:~
 : Parse FTContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(108, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 113232) then                   (: 'at' 'start' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:lk] = 62032) then                    (: 'at' 'end' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(122, $input, $state)            (: 'entire' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:shift(96, $input, $state)             (: 'content' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContent", $count, $begin, $end)
};

(:~
 : Try parsing FTContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(108, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 113232) then                   (: 'at' 'start' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:lk] = 62032) then                    (: 'at' 'end' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(122, $input, $state)           (: 'entire' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:shiftT(96, $input, $state)            (: 'content' :)
      return $state
  return $state
};

(:~
 : Parse FTBigUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 215) then                      (: 'sentence' :)
      let $state := p:shift(215, $input, $state)            (: 'sentence' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(189, $input, $state)            (: 'paragraph' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTBigUnit", $count, $begin, $end)
};

(:~
 : Try parsing FTBigUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 215) then                      (: 'sentence' :)
      let $state := p:shiftT(215, $input, $state)           (: 'sentence' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(189, $input, $state)           (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Parse FTScope.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:shift(208, $input, $state)            (: 'same' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(110, $input, $state)            (: 'different' :)
      return $state
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTBigUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTScope", $count, $begin, $end)
};

(:~
 : Try parsing FTScope.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:shiftT(208, $input, $state)           (: 'same' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(110, $input, $state)           (: 'different' :)
      return $state
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state := p:try-FTBigUnit($input, $state)
  return $state
};

(:~
 : Parse FTDistance.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(112, $input, $state)                (: 'distance' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTRange($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDistance", $count, $begin, $end)
};

(:~
 : Try parsing FTDistance.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(112, $input, $state)               (: 'distance' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:try-FTRange($input, $state)
  let $state := p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnit", $count, $begin, $end)
};

(:~
 : Try parsing FTUnit.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Parse FTWindow.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTUnit($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWindow", $count, $begin, $end)
};

(:~
 : Try parsing FTWindow.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-AdditiveExpr($input, $state)
  let $state := p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTOrder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(187, $input, $state)                (: 'ordered' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOrder", $count, $begin, $end)
};

(:~
 : Try parsing FTOrder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(187, $input, $state)               (: 'ordered' :)
  return $state
};

(:~
 : Parse FTPosFilter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:parse-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 250) then                      (: 'window' :)
      let $state := p:parse-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'distance' :)
      let $state := p:parse-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 110                            (: 'different' :)
          or $state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:parse-FTScope($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPosFilter", $count, $begin, $end)
};

(:~
 : Try parsing FTPosFilter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:try-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 250) then                      (: 'window' :)
      let $state := p:try-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'distance' :)
      let $state := p:try-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 110                            (: 'different' :)
          or $state[$p:l1] = 208) then                      (: 'same' :)
      let $state := p:try-FTScope($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTWeight.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(246, $input, $state)                (: 'weight' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWeight", $count, $begin, $end)
};

(:~
 : Try parsing FTWeight.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(246, $input, $state)               (: 'weight' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-FTExtensionSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:try-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-FTExtensionSelection-1($input, $state)
};

(:~
 : Parse FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTExtensionSelection-1($input, $state)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(160, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionSelection", $count, $begin, $end)
};

(:~
 : Try parsing FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTExtensionSelection-1($input, $state)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(160, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse FTRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125) then                      (: 'exactly' :)
      let $state := p:shift(125, $input, $state)            (: 'exactly' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shift(170, $input, $state)            (: 'most' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(132, $input, $state)            (: 'from' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTRange", $count, $begin, $end)
};

(:~
 : Try parsing FTRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125) then                      (: 'exactly' :)
      let $state := p:shiftT(125, $input, $state)           (: 'exactly' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shiftT(161, $input, $state)           (: 'least' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shiftT(170, $input, $state)           (: 'most' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(132, $input, $state)           (: 'from' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTTimes.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(181, $input, $state)                (: 'occurs' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTRange($input, $state)
  let $state := p:shift(231, $input, $state)                (: 'times' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTTimes", $count, $begin, $end)
};

(:~
 : Try parsing FTTimes.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(181, $input, $state)               (: 'occurs' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state := p:try-FTRange($input, $state)
  let $state := p:shiftT(231, $input, $state)               (: 'times' :)
  return $state
};

(:~
 : Parse FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'any' :)
      let $state := p:shift(77, $input, $state)             (: 'any' :)
      let $state := p:lookahead1W(195, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'word' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 253) then                  (: 'word' :)
          let $state := p:shift(253, $input, $state)        (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'all' :)
      let $state := p:shift(72, $input, $state)             (: 'all' :)
      let $state := p:lookahead1W(196, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 254) then                  (: 'words' :)
          let $state := p:shift(254, $input, $state)        (: 'words' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(195, $input, $state)            (: 'phrase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnyallOption", $count, $begin, $end)
};

(:~
 : Try parsing FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'any' :)
      let $state := p:shiftT(77, $input, $state)            (: 'any' :)
      let $state := p:lookahead1W(195, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'word' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 253) then                  (: 'word' :)
          let $state := p:shiftT(253, $input, $state)       (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'all' :)
      let $state := p:shiftT(72, $input, $state)            (: 'all' :)
      let $state := p:lookahead1W(196, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 254) then                  (: 'words' :)
          let $state := p:shiftT(254, $input, $state)       (: 'words' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(195, $input, $state)           (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Parse FTWordsValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12) then                       (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWordsValue", $count, $begin, $end)
};

(:~
 : Try parsing FTWordsValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12) then                       (: StringLiteral :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
  return $state
};

(:~
 : Parse FTWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTWordsValue($input, $state)
  let $state := p:lookahead1W(199, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'all' | 'and' | 'any' | 'as' | 'ascending' | 'at' |
                                                               'before' | 'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'end' | 'entire' | 'eq' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'occurs' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'phrase' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'start' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72                             (: 'all' :)
          or $state[$p:l1] = 77                             (: 'any' :)
          or $state[$p:l1] = 195) then                      (: 'phrase' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTAnyallOption($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWords", $count, $begin, $end)
};

(:~
 : Try parsing FTWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTWordsValue($input, $state)
  let $state := p:lookahead1W(199, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'all' | 'and' | 'any' | 'as' | 'ascending' | 'at' |
                                                               'before' | 'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'else' |
                                                               'empty' | 'end' | 'entire' | 'eq' | 'for' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'occurs' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'phrase' |
                                                               'return' | 'same' | 'satisfies' | 'stable' | 'start' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72                             (: 'all' :)
          or $state[$p:l1] = 77                             (: 'any' :)
          or $state[$p:l1] = 195) then                      (: 'phrase' :)
      let $state := p:try-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state := p:parse-FTExtensionSelection($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTWords($input, $state)
      let $state := p:lookahead1W(191, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 181) then                  (: 'occurs' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimary", $count, $begin, $end)
};

(:~
 : Try parsing FTPrimary.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTSelection($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state := p:try-FTExtensionSelection($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTWords($input, $state)
      let $state := p:lookahead1W(191, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'occurs' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 181) then                  (: 'occurs' :)
          let $state := p:try-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTPrimary($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 241) then                      (: 'using' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 246) then                      (: 'weight' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTWeight($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTPrimaryWithOptions", $count, $begin, $end)
};

(:~
 : Try parsing FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTPrimary($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 241) then                      (: 'using' :)
      let $state := p:try-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 246) then                      (: 'weight' :)
      let $state := p:try-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'ftnot' :)
      let $state := p:shift(135, $input, $state)            (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTPrimaryWithOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTUnaryNot", $count, $begin, $end)
};

(:~
 : Try parsing FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'ftnot' :)
      let $state := p:shiftT(135, $input, $state)           (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state := p:try-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMildNot-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 180) then                        (: 'not' :)
        $state
      else
        let $state := p:shift(180, $input, $state)          (: 'not' :)
        let $state := p:lookahead1W(50, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(147, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(156, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTUnaryNot($input, $state)
        return p:parse-FTMildNot-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMildNot-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 180) then                        (: 'not' :)
        $state
      else
        let $state := p:shiftT(180, $input, $state)         (: 'not' :)
        let $state := p:lookahead1W(50, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shiftT(147, $input, $state)         (: 'in' :)
        let $state := p:lookahead1W(156, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state := p:try-FTUnaryNot($input, $state)
        return p:try-FTMildNot-1($input, $state)
};

(:~
 : Parse FTMildNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTUnaryNot($input, $state)
  let $state := p:parse-FTMildNot-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMildNot", $count, $begin, $end)
};

(:~
 : Try parsing FTMildNot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTUnaryNot($input, $state)
  let $state := p:try-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnd-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 134) then                          (: 'ftand' :)
      $state
    else
      let $state := p:shift(134, $input, $state)            (: 'ftand' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTMildNot($input, $state)
      return p:parse-FTAnd-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnd-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 134) then                          (: 'ftand' :)
      $state
    else
      let $state := p:shiftT(134, $input, $state)           (: 'ftand' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTMildNot($input, $state)
      return p:try-FTAnd-1($input, $state)
};

(:~
 : Parse FTAnd.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTMildNot($input, $state)
  let $state := p:parse-FTAnd-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTAnd", $count, $begin, $end)
};

(:~
 : Try parsing FTAnd.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMildNot($input, $state)
  let $state := p:try-FTAnd-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 136) then                          (: 'ftor' :)
      $state
    else
      let $state := p:shift(136, $input, $state)            (: 'ftor' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTAnd($input, $state)
      return p:parse-FTOr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 136) then                          (: 'ftor' :)
      $state
    else
      let $state := p:shiftT(136, $input, $state)           (: 'ftor' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTAnd($input, $state)
      return p:try-FTOr-1($input, $state)
};

(:~
 : Parse FTOr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTAnd($input, $state)
  let $state := p:parse-FTOr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOr", $count, $begin, $end)
};

(:~
 : Try parsing FTOr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTAnd($input, $state)
  let $state := p:try-FTOr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 80                               (: 'at' :)
      and $state[$p:l1] != 110                              (: 'different' :)
      and $state[$p:l1] != 112                              (: 'distance' :)
      and $state[$p:l1] != 122                              (: 'entire' :)
      and $state[$p:l1] != 187                              (: 'ordered' :)
      and $state[$p:l1] != 208                              (: 'same' :)
      and $state[$p:l1] != 250) then                        (: 'window' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTPosFilter($input, $state)
        return p:parse-FTSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTSelection-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 80                               (: 'at' :)
      and $state[$p:l1] != 110                              (: 'different' :)
      and $state[$p:l1] != 112                              (: 'distance' :)
      and $state[$p:l1] != 122                              (: 'entire' :)
      and $state[$p:l1] != 187                              (: 'ordered' :)
      and $state[$p:l1] != 208                              (: 'same' :)
      and $state[$p:l1] != 250) then                        (: 'window' :)
        $state
      else
        let $state := p:try-FTPosFilter($input, $state)
        return p:try-FTSelection-1($input, $state)
};

(:~
 : Parse FTSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTOr($input, $state)
  let $state := p:parse-FTSelection-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTSelection", $count, $begin, $end)
};

(:~
 : Try parsing FTSelection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTOr($input, $state)
  let $state := p:try-FTSelection-1($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(204, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:shift(64, $input, $state)         (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(39, $input, $state)         (: '*' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Try parsing SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(204, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'union' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:shiftT(64, $input, $state)        (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(39, $input, $state)        (: '*' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(35, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(228, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shift(2, $input, $state)              (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shift(30, $input, $state)                 (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Try parsing Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(35, $input, $state)                (: '(#' :)
  let $state := p:lookahead1(228, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      return $state
    else
      $state
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shiftT(2, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shiftT(30, $input, $state)                (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:try-Pragma($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Try parsing ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExtensionExpr-1($input, $state)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:try-Predicate($input, $state)
        return p:try-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Try parsing PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(231, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Try parsing AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shiftT(66, $input, $state)            (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(231, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shift(91, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shift(106, $input, $state)            (: 'descendant' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shift(81, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shift(213, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shift(202, $input, $state)            (: 'property' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shift(107, $input, $state)            (: 'descendant-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shift(130, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(129, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Try parsing ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shiftT(91, $input, $state)            (: 'child' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shiftT(106, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shiftT(81, $input, $state)            (: 'attribute' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shiftT(171, $input, $state)           (: 'namespace' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shiftT(213, $input, $state)           (: 'self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shiftT(202, $input, $state)           (: 'property' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shiftT(107, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shiftT(130, $input, $state)           (: 'following-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(129, $input, $state)           (: 'following' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 81) then                           (: 'attribute' :)
      let $state := p:lookahead2W(218, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (91,                           (: 'child' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              171,                          (: 'namespace' :)
                              202,                          (: 'property' :)
                              213)) then                    (: 'self' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25681                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25691                          (: 'child' '::' :)
          or $state[$p:lk] = 25706                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25707                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25729                          (: 'following' '::' :)
          or $state[$p:lk] = 25730                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25771                          (: 'namespace' '::' :)
          or $state[$p:lk] = 25802                          (: 'property' '::' :)
          or $state[$p:lk] = 25813) then                    (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Try parsing ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 81) then                           (: 'attribute' :)
      let $state := p:lookahead2W(218, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (91,                           (: 'child' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              171,                          (: 'namespace' :)
                              202,                          (: 'property' :)
                              213)) then                    (: 'self' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25681                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25691                          (: 'child' '::' :)
          or $state[$p:lk] = 25706                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25707                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25729                          (: 'following' '::' :)
          or $state[$p:lk] = 25730                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25771                          (: 'namespace' '::' :)
          or $state[$p:lk] = 25802                          (: 'property' '::' :)
          or $state[$p:lk] = 25813) then                    (: 'self' '::' :)
      let $state := p:try-ForwardAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Try parsing AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(45, $input, $state)                (: '..' :)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: Wildcard :)
      let $state := p:shift(6, $input, $state)              (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Try parsing NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: Wildcard :)
      let $state := p:shiftT(6, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (81,                                (: 'attribute' :)
                         84,                                (: 'binary' :)
                         93,                                (: 'comment' :)
                         115,                               (: 'document-node' :)
                         116,                               (: 'element' :)
                         172,                               (: 'namespace-node' :)
                         178,                               (: 'node' :)
                         201,                               (: 'processing-instruction' :)
                         211,                               (: 'schema-attribute' :)
                         212,                               (: 'schema-element' :)
                         228)) then                         (: 'text' :)
      let $state := p:lookahead2W(214, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17489                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17492                          (: 'binary' '(' :)
          or $state[$p:lk] = 17501                          (: 'comment' '(' :)
          or $state[$p:lk] = 17523                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17524                          (: 'element' '(' :)
          or $state[$p:lk] = 17580                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17586                          (: 'node' '(' :)
          or $state[$p:lk] = 17609                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17619                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17620                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17636) then                    (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Try parsing NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (81,                                (: 'attribute' :)
                         84,                                (: 'binary' :)
                         93,                                (: 'comment' :)
                         115,                               (: 'document-node' :)
                         116,                               (: 'element' :)
                         172,                               (: 'namespace-node' :)
                         178,                               (: 'node' :)
                         201,                               (: 'processing-instruction' :)
                         211,                               (: 'schema-attribute' :)
                         212,                               (: 'schema-element' :)
                         228)) then                         (: 'text' :)
      let $state := p:lookahead2W(214, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17489                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17492                          (: 'binary' '(' :)
          or $state[$p:lk] = 17501                          (: 'comment' '(' :)
          or $state[$p:lk] = 17523                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17524                          (: 'element' '(' :)
          or $state[$p:lk] = 17580                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17586                          (: 'node' '(' :)
          or $state[$p:lk] = 17609                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17619                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17620                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17636) then                    (: 'text' '(' :)
      let $state := p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shift(191, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shift(74, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shift(197, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shift(196, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(75, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Try parsing ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shiftT(191, $input, $state)           (: 'parent' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shiftT(74, $input, $state)            (: 'ancestor' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shiftT(197, $input, $state)           (: 'preceding-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shiftT(196, $input, $state)           (: 'preceding' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(75, $input, $state)            (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shiftT(50, $input, $state)            (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Try parsing ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '..' :)
      let $state := p:try-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ReverseAxis($input, $state)
      let $state := p:lookahead1W(231, $input, $state)      (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (74,                                (: 'ancestor' :)
                         75,                                (: 'ancestor-or-self' :)
                         191,                               (: 'parent' :)
                         196,                               (: 'preceding' :)
                         197)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45                             (: '..' :)
          or $state[$p:lk] = 25674                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25675                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25791                          (: 'parent' '::' :)
          or $state[$p:lk] = 25796                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25797) then                    (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(211, $input, $state)          (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Try parsing AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (74,                                (: 'ancestor' :)
                         75,                                (: 'ancestor-or-self' :)
                         191,                               (: 'parent' :)
                         196,                               (: 'preceding' :)
                         197)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45                             (: '..' :)
          or $state[$p:lk] = 25674                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25675                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25791                          (: 'parent' '::' :)
          or $state[$p:lk] = 25796                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25797) then                    (: 'preceding-sibling' '::' :)
      let $state := p:try-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(211, $input, $state)          (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state := p:try-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(68, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(69, $input, $state)                 (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Try parsing Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(68, $input, $state)                (: '[' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(69, $input, $state)                (: ']' :)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Try parsing Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:try-Param($input, $state)
        return p:try-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Try parsing ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Param($input, $state)
  let $state := p:try-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunction", $count, $begin, $end)
};

(:~
 : Try parsing InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:try-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(29, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(9, $input, $state)                  (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "LiteralFunctionItem", $count, $begin, $end)
};

(:~
 : Try parsing LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shiftT(29, $input, $state)                (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(9, $input, $state)                 (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 138) then                          (: 'function' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17546) then                    (: 'function' '(' :)
      let $state := p:parse-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-LiteralFunctionItem($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Try parsing FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 138) then                          (: 'function' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17546) then                    (: 'function' '(' :)
      let $state := p:try-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-LiteralFunctionItem($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrefixExpr", $count, $begin, $end)
};

(:~
 : Try parsing PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NCName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prefix", $count, $begin, $end)
};

(:~
 : Try parsing Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompNamespaceConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(171, $input, $state)               (: 'namespace' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-PrefixExpr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(84, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompBinaryConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(84, $input, $state)                (: 'binary' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(201, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(201, $input, $state)               (: 'processing-instruction' :)
  let $state := p:lookahead1W(182, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(93, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(93, $input, $state)                (: 'comment' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExprExtended", $count, $begin, $end)
};

(:~
 : Try parsing EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(228, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(228, $input, $state)               (: 'text' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:try-EnclosedExprExtended($input, $state)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(81, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(81, $input, $state)                (: 'attribute' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Try parsing ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(116, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shift(257, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(261, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(116, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(232, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 257) then                      (: '{' :)
      let $state := p:shiftT(257, $input, $state)           (: '{' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-Expr($input, $state)
      let $state := p:shiftT(261, $input, $state)           (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(246, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 261) then                     (: '}' :)
      let $state := p:try-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(114, $input, $state)                (: 'document' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Try parsing CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(114, $input, $state)               (: 'document' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:parse-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Try parsing ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:try-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:try-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:try-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:try-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:try-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:try-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:try-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CompNamespaceConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(59, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shift(4, $input, $state)              (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:shift(65, $input, $state)                 (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(59, $input, $state)                (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shiftT(19, $input, $state)                (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shiftT(23, $input, $state)            (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shiftT(4, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:shiftT(65, $input, $state)                (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(3, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(54, $input, $state)                (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shiftT(3, $input, $state)                 (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:shiftT(43, $input, $state)                (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(55, $input, $state)                 (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shift(5, $input, $state)                  (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:shift(70, $input, $state)                 (: ']]>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CDataSection", $count, $begin, $end)
};

(:~
 : Try parsing CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(55, $input, $state)                (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shiftT(5, $input, $state)                 (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:shiftT(70, $input, $state)                (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shift(16, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Try parsing DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:try-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shiftT(16, $input, $state)            (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: AposAttrContentChar :)
      let $state := p:shift(18, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Try parsing AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: AposAttrContentChar :)
      let $state := p:shiftT(18, $input, $state)            (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Try parsing EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: PredefinedEntityRef :)
      let $state := p:shift(13, $input, $state)             (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shift(20, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: '{{' :)
      let $state := p:shift(258, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 262) then                      (: '}}' :)
      let $state := p:shift(262, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Try parsing CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: PredefinedEntityRef :)
      let $state := p:shiftT(13, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shiftT(20, $input, $state)            (: CharRef :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: '{{' :)
      let $state := p:shiftT(258, $input, $state)           (: '{{' :)
      return $state
    else if ($state[$p:l1] = 262) then                      (: '}}' :)
      let $state := p:shiftT(262, $input, $state)           (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: QuotAttrContentChar :)
      let $state := p:shift(17, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Try parsing QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: QuotAttrContentChar :)
      let $state := p:shiftT(17, $input, $state)            (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(161, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 14) then                 (: EscapeQuot :)
            let $state := p:shift(14, $input, $state)       (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(161, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 14) then                 (: EscapeQuot :)
            let $state := p:shiftT(14, $input, $state)      (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-QuotAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(162, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 15) then                 (: EscapeApos :)
            let $state := p:shift(15, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(162, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 15) then                 (: EscapeApos :)
            let $state := p:shiftT(15, $input, $state)      (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-AposAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(33, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(33, $input, $state)             (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Try parsing DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:shiftT(28, $input, $state)            (: '"' :)
      let $state := p:try-DirAttributeValue-1($input, $state)
      let $state := p:shiftT(28, $input, $state)            (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(33, $input, $state)            (: "'" :)
      let $state := p:try-DirAttributeValue-2($input, $state)
      let $state := p:shiftT(33, $input, $state)            (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shift(23, $input, $state)           (: S :)
        let $state := p:lookahead1(230, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 23                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shiftT(23, $input, $state)          (: S :)
        let $state := p:lookahead1(230, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 23                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:try-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shiftT(23, $input, $state)  (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:shiftT(60, $input, $state)      (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shiftT(23, $input, $state)  (: S :)
                return $state
              else
                $state
            let $state := p:try-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:try-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Try parsing DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(168, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(168, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:try-DirElemContent($input, $state)
        return p:try-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(56, $input, $state)             (: '</' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shift(23, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(53, $input, $state)                (: '<' :)
  let $state := p:try-QName($input, $state)
  let $state := p:try-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: '/>' :)
      let $state := p:shiftT(48, $input, $state)            (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      let $state := p:try-DirElemConstructor-1($input, $state)
      let $state := p:shiftT(56, $input, $state)            (: '</' :)
      let $state := p:try-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shiftT(23, $input, $state)        (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:shiftT(61, $input, $state)            (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Try parsing DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:try-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:try-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Constructor", $count, $begin, $end)
};

(:~
 : Try parsing Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(239, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(239, $input, $state)               (: 'unordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(187, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Try parsing OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(187, $input, $state)               (: 'ordered' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(64, $input, $state)                 (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentPlaceholder", $count, $begin, $end)
};

(:~
 : Try parsing ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(64, $input, $state)                (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Argument", $count, $begin, $end)
};

(:~
 : Try parsing Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:try-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(244, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(244, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-Argument($input, $state)
        return p:try-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(248, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Try parsing ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(248, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-Argument($input, $state)
      let $state := p:try-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Try parsing FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: URIQualifiedName :)
      let $state := p:shiftT(7, $input, $state)             (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FunctionQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Try parsing FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:try-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Try parsing ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(44, $input, $state)                (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(243, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Try parsing ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(243, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Try parsing VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'namespace' :)
      let $state := p:lookahead2W(185, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 201) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(184, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (81,                           (: 'attribute' :)
                              116)) then                    (: 'element' :)
      let $state := p:lookahead2W(234, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              228)) then                    (: 'text' :)
      let $state := p:lookahead2W(86, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (114,                          (: 'document' :)
                              187,                          (: 'ordered' :)
                              239)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(132, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (7,                            (: URIQualifiedName :)
                              22,                           (: QName^Token :)
                              71,                           (: 'after' :)
                              74,                           (: 'ancestor' :)
                              75,                           (: 'ancestor-or-self' :)
                              76,                           (: 'and' :)
                              78,                           (: 'as' :)
                              79,                           (: 'ascending' :)
                              83,                           (: 'before' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              90,                           (: 'catch' :)
                              91,                           (: 'child' :)
                              92,                           (: 'collation' :)
                              95,                           (: 'contains' :)
                              98,                           (: 'copy' :)
                              100,                          (: 'count' :)
                              103,                          (: 'declare' :)
                              104,                          (: 'default' :)
                              105,                          (: 'delete' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              108,                          (: 'descending' :)
                              113,                          (: 'div' :)
                              117,                          (: 'else' :)
                              118,                          (: 'empty' :)
                              121,                          (: 'end' :)
                              123,                          (: 'eq' :)
                              124,                          (: 'every' :)
                              126,                          (: 'except' :)
                              128,                          (: 'first' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              131,                          (: 'for' :)
                              139,                          (: 'ge' :)
                              141,                          (: 'group' :)
                              143,                          (: 'gt' :)
                              144,                          (: 'idiv' :)
                              146,                          (: 'import' :)
                              151,                          (: 'insert' :)
                              152,                          (: 'instance' :)
                              153,                          (: 'intersect' :)
                              154,                          (: 'into' :)
                              155,                          (: 'is' :)
                              158,                          (: 'last' :)
                              160,                          (: 'le' :)
                              162,                          (: 'let' :)
                              165,                          (: 'lt' :)
                              167,                          (: 'mod' :)
                              168,                          (: 'modify' :)
                              169,                          (: 'module' :)
                              173,                          (: 'ne' :)
                              183,                          (: 'only' :)
                              185,                          (: 'or' :)
                              186,                          (: 'order' :)
                              190,                          (: 'paragraphs' :)
                              191,                          (: 'parent' :)
                              196,                          (: 'preceding' :)
                              197,                          (: 'preceding-sibling' :)
                              200,                          (: 'private' :)
                              202,                          (: 'property' :)
                              204,                          (: 'rename' :)
                              205,                          (: 'replace' :)
                              206,                          (: 'return' :)
                              209,                          (: 'satisfies' :)
                              213,                          (: 'self' :)
                              216,                          (: 'sentences' :)
                              219,                          (: 'some' :)
                              220,                          (: 'stable' :)
                              221,                          (: 'start' :)
                              231,                          (: 'times' :)
                              232,                          (: 'to' :)
                              233,                          (: 'treat' :)
                              234,                          (: 'try' :)
                              238,                          (: 'union' :)
                              242,                          (: 'validate' :)
                              248,                          (: 'where' :)
                              251,                          (: 'with' :)
                              254,                          (: 'words' :)
                              255)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9                              (: IntegerLiteral :)
          or $state[$p:lk] = 10                             (: DecimalLiteral :)
          or $state[$p:lk] = 11                             (: DoubleLiteral :)
          or $state[$p:lk] = 12) then                       (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663) then                    (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 131771) then                   (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131823) then                   (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 115                            (: 'document-node' :)
          or $state[$p:lk] = 119                            (: 'empty-sequence' :)
          or $state[$p:lk] = 138                            (: 'function' :)
          or $state[$p:lk] = 145                            (: 'if' :)
          or $state[$p:lk] = 156                            (: 'item' :)
          or $state[$p:lk] = 172                            (: 'namespace-node' :)
          or $state[$p:lk] = 178                            (: 'node' :)
          or $state[$p:lk] = 211                            (: 'schema-attribute' :)
          or $state[$p:lk] = 212                            (: 'schema-element' :)
          or $state[$p:lk] = 227                            (: 'switch' :)
          or $state[$p:lk] = 237                            (: 'typeswitch' :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103) then                    (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Constructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'namespace' :)
      let $state := p:lookahead2W(185, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 201) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(184, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (81,                           (: 'attribute' :)
                              116)) then                    (: 'element' :)
      let $state := p:lookahead2W(234, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              228)) then                    (: 'text' :)
      let $state := p:lookahead2W(86, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (114,                          (: 'document' :)
                              187,                          (: 'ordered' :)
                              239)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(132, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (7,                            (: URIQualifiedName :)
                              22,                           (: QName^Token :)
                              71,                           (: 'after' :)
                              74,                           (: 'ancestor' :)
                              75,                           (: 'ancestor-or-self' :)
                              76,                           (: 'and' :)
                              78,                           (: 'as' :)
                              79,                           (: 'ascending' :)
                              83,                           (: 'before' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              90,                           (: 'catch' :)
                              91,                           (: 'child' :)
                              92,                           (: 'collation' :)
                              95,                           (: 'contains' :)
                              98,                           (: 'copy' :)
                              100,                          (: 'count' :)
                              103,                          (: 'declare' :)
                              104,                          (: 'default' :)
                              105,                          (: 'delete' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              108,                          (: 'descending' :)
                              113,                          (: 'div' :)
                              117,                          (: 'else' :)
                              118,                          (: 'empty' :)
                              121,                          (: 'end' :)
                              123,                          (: 'eq' :)
                              124,                          (: 'every' :)
                              126,                          (: 'except' :)
                              128,                          (: 'first' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              131,                          (: 'for' :)
                              139,                          (: 'ge' :)
                              141,                          (: 'group' :)
                              143,                          (: 'gt' :)
                              144,                          (: 'idiv' :)
                              146,                          (: 'import' :)
                              151,                          (: 'insert' :)
                              152,                          (: 'instance' :)
                              153,                          (: 'intersect' :)
                              154,                          (: 'into' :)
                              155,                          (: 'is' :)
                              158,                          (: 'last' :)
                              160,                          (: 'le' :)
                              162,                          (: 'let' :)
                              165,                          (: 'lt' :)
                              167,                          (: 'mod' :)
                              168,                          (: 'modify' :)
                              169,                          (: 'module' :)
                              173,                          (: 'ne' :)
                              183,                          (: 'only' :)
                              185,                          (: 'or' :)
                              186,                          (: 'order' :)
                              190,                          (: 'paragraphs' :)
                              191,                          (: 'parent' :)
                              196,                          (: 'preceding' :)
                              197,                          (: 'preceding-sibling' :)
                              200,                          (: 'private' :)
                              202,                          (: 'property' :)
                              204,                          (: 'rename' :)
                              205,                          (: 'replace' :)
                              206,                          (: 'return' :)
                              209,                          (: 'satisfies' :)
                              213,                          (: 'self' :)
                              216,                          (: 'sentences' :)
                              219,                          (: 'some' :)
                              220,                          (: 'stable' :)
                              221,                          (: 'start' :)
                              231,                          (: 'times' :)
                              232,                          (: 'to' :)
                              233,                          (: 'treat' :)
                              234,                          (: 'try' :)
                              238,                          (: 'union' :)
                              242,                          (: 'validate' :)
                              248,                          (: 'where' :)
                              251,                          (: 'with' :)
                              254,                          (: 'words' :)
                              255)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9                              (: IntegerLiteral :)
          or $state[$p:lk] = 10                             (: DecimalLiteral :)
          or $state[$p:lk] = 11                             (: DoubleLiteral :)
          or $state[$p:lk] = 12) then                       (: StringLiteral :)
      let $state := p:try-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:try-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663) then                    (: 'xquery' '(' :)
      let $state := p:try-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 131771) then                   (: 'ordered' '{' :)
      let $state := p:try-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131823) then                   (: 'unordered' '{' :)
      let $state := p:try-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 115                            (: 'document-node' :)
          or $state[$p:lk] = 119                            (: 'empty-sequence' :)
          or $state[$p:lk] = 138                            (: 'function' :)
          or $state[$p:lk] = 145                            (: 'if' :)
          or $state[$p:lk] = 156                            (: 'item' :)
          or $state[$p:lk] = 172                            (: 'namespace-node' :)
          or $state[$p:lk] = 178                            (: 'node' :)
          or $state[$p:lk] = 211                            (: 'schema-attribute' :)
          or $state[$p:lk] = 212                            (: 'schema-element' :)
          or $state[$p:lk] = 227                            (: 'switch' :)
          or $state[$p:lk] = 237                            (: 'typeswitch' :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103) then                    (: 'xquery' '#' :)
      let $state := p:try-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(214, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(214, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: '[' :)
            let $state := p:try-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-ArgumentList($input, $state)
            return $state
        return p:try-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpr", $count, $begin, $end)
};

(:~
 : Try parsing PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PrimaryExpr($input, $state)
  let $state := p:try-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 81) then                           (: 'attribute' :)
      let $state := p:lookahead2W(250, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44625) then                    (: 'attribute' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47185) then               (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48721) then               (: 'attribute' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53329) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60497) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67153) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77905) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93777) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112721) then              (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118353) then              (: 'attribute' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40529,                    (: 'attribute' 'ascending' :)
                                  55377)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51281,                    (: 'attribute' 'count' :)
                                  83025)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62033,                    (: 'attribute' 'end' :)
                                  113233)) then             (: 'attribute' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72273,                    (: 'attribute' 'group' :)
                                  95313)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45137,                    (: 'attribute' 'cast' :)
                                  45649,                    (: 'attribute' 'castable' :)
                                  119377)) then             (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97361,                    (: 'attribute' 'paragraphs' :)
                                  110673,                   (: 'attribute' 'sentences' :)
                                  130129)) then             (: 'attribute' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36433,                    (: 'attribute' 'after' :)
                                  38993,                    (: 'attribute' 'and' :)
                                  40017,                    (: 'attribute' 'as' :)
                                  42577,                    (: 'attribute' 'before' :)
                                  57937,                    (: 'attribute' 'div' :)
                                  59985,                    (: 'attribute' 'else' :)
                                  63057,                    (: 'attribute' 'eq' :)
                                  64593,                    (: 'attribute' 'except' :)
                                  71249,                    (: 'attribute' 'ge' :)
                                  73297,                    (: 'attribute' 'gt' :)
                                  73809,                    (: 'attribute' 'idiv' :)
                                  78417,                    (: 'attribute' 'intersect' :)
                                  78929,                    (: 'attribute' 'into' :)
                                  79441,                    (: 'attribute' 'is' :)
                                  82001,                    (: 'attribute' 'le' :)
                                  84561,                    (: 'attribute' 'lt' :)
                                  85585,                    (: 'attribute' 'mod' :)
                                  86097,                    (: 'attribute' 'modify' :)
                                  88657,                    (: 'attribute' 'ne' :)
                                  94801,                    (: 'attribute' 'or' :)
                                  105553,                   (: 'attribute' 'return' :)
                                  107089,                   (: 'attribute' 'satisfies' :)
                                  118865,                   (: 'attribute' 'to' :)
                                  121937,                   (: 'attribute' 'union' :)
                                  127057,                   (: 'attribute' 'where' :)
                                  128593)) then             (: 'attribute' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 116) then                     (: 'element' :)
      let $state := p:lookahead2W(249, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44660) then                    (: 'element' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47220) then               (: 'element' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48756) then               (: 'element' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53364) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60532) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67188) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77940) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93812) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112756) then              (: 'element' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118388) then              (: 'element' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40564,                    (: 'element' 'ascending' :)
                                  55412)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51316,                    (: 'element' 'count' :)
                                  83060)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62068,                    (: 'element' 'end' :)
                                  113268)) then             (: 'element' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72308,                    (: 'element' 'group' :)
                                  95348)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45172,                    (: 'element' 'cast' :)
                                  45684,                    (: 'element' 'castable' :)
                                  119412)) then             (: 'element' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97396,                    (: 'element' 'paragraphs' :)
                                  110708,                   (: 'element' 'sentences' :)
                                  130164)) then             (: 'element' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36468,                    (: 'element' 'after' :)
                                  39028,                    (: 'element' 'and' :)
                                  40052,                    (: 'element' 'as' :)
                                  42612,                    (: 'element' 'before' :)
                                  57972,                    (: 'element' 'div' :)
                                  60020,                    (: 'element' 'else' :)
                                  63092,                    (: 'element' 'eq' :)
                                  64628,                    (: 'element' 'except' :)
                                  71284,                    (: 'element' 'ge' :)
                                  73332,                    (: 'element' 'gt' :)
                                  73844,                    (: 'element' 'idiv' :)
                                  78452,                    (: 'element' 'intersect' :)
                                  78964,                    (: 'element' 'into' :)
                                  79476,                    (: 'element' 'is' :)
                                  82036,                    (: 'element' 'le' :)
                                  84596,                    (: 'element' 'lt' :)
                                  85620,                    (: 'element' 'mod' :)
                                  86132,                    (: 'element' 'modify' :)
                                  88692,                    (: 'element' 'ne' :)
                                  94836,                    (: 'element' 'or' :)
                                  105588,                   (: 'element' 'return' :)
                                  107124,                   (: 'element' 'satisfies' :)
                                  118900,                   (: 'element' 'to' :)
                                  121972,                   (: 'element' 'union' :)
                                  127092,                   (: 'element' 'where' :)
                                  128628)) then             (: 'element' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 171) then                     (: 'namespace' :)
      let $state := p:lookahead2W(224, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'try' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] eq 44715) then                    (: 'namespace' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47275) then               (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48811) then               (: 'namespace' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53419) then               (: 'namespace' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60587) then               (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67243) then               (: 'namespace' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77995) then               (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93867) then               (: 'namespace' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112811) then              (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118443) then              (: 'namespace' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40619,                    (: 'namespace' 'ascending' :)
                                  55467)) then              (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51371,                    (: 'namespace' 'count' :)
                                  83115)) then              (: 'namespace' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62123,                    (: 'namespace' 'end' :)
                                  113323)) then             (: 'namespace' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72363,                    (: 'namespace' 'group' :)
                                  95403)) then              (: 'namespace' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45227,                    (: 'namespace' 'cast' :)
                                  45739,                    (: 'namespace' 'castable' :)
                                  119467)) then             (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97451,                    (: 'namespace' 'paragraphs' :)
                                  110763,                   (: 'namespace' 'sentences' :)
                                  130219)) then             (: 'namespace' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36523,                    (: 'namespace' 'after' :)
                                  39083,                    (: 'namespace' 'and' :)
                                  40107,                    (: 'namespace' 'as' :)
                                  42667,                    (: 'namespace' 'before' :)
                                  58027,                    (: 'namespace' 'div' :)
                                  60075,                    (: 'namespace' 'else' :)
                                  63147,                    (: 'namespace' 'eq' :)
                                  64683,                    (: 'namespace' 'except' :)
                                  71339,                    (: 'namespace' 'ge' :)
                                  73387,                    (: 'namespace' 'gt' :)
                                  73899,                    (: 'namespace' 'idiv' :)
                                  78507,                    (: 'namespace' 'intersect' :)
                                  79019,                    (: 'namespace' 'into' :)
                                  79531,                    (: 'namespace' 'is' :)
                                  82091,                    (: 'namespace' 'le' :)
                                  84651,                    (: 'namespace' 'lt' :)
                                  85675,                    (: 'namespace' 'mod' :)
                                  86187,                    (: 'namespace' 'modify' :)
                                  88747,                    (: 'namespace' 'ne' :)
                                  94891,                    (: 'namespace' 'or' :)
                                  105643,                   (: 'namespace' 'return' :)
                                  107179,                   (: 'namespace' 'satisfies' :)
                                  118955,                   (: 'namespace' 'to' :)
                                  122027,                   (: 'namespace' 'union' :)
                                  127147,                   (: 'namespace' 'where' :)
                                  128683)) then             (: 'namespace' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 201) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(223, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44745) then                    (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47305) then               (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48841) then               (: 'processing-instruction' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53449) then               (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60617) then               (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67273) then               (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 78025) then               (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93897) then               (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112841) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118473) then              (: 'processing-instruction' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40649,                    (: 'processing-instruction' 'ascending' :)
                                  55497)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51401,                    (: 'processing-instruction' 'count' :)
                                  83145)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62153,                    (: 'processing-instruction' 'end' :)
                                  113353)) then             (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72393,                    (: 'processing-instruction' 'group' :)
                                  95433)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45257,                    (: 'processing-instruction' 'cast' :)
                                  45769,                    (: 'processing-instruction' 'castable' :)
                                  119497)) then             (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97481,                    (: 'processing-instruction' 'paragraphs' :)
                                  110793,                   (: 'processing-instruction' 'sentences' :)
                                  130249)) then             (: 'processing-instruction' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36553,                    (: 'processing-instruction' 'after' :)
                                  39113,                    (: 'processing-instruction' 'and' :)
                                  40137,                    (: 'processing-instruction' 'as' :)
                                  42697,                    (: 'processing-instruction' 'before' :)
                                  58057,                    (: 'processing-instruction' 'div' :)
                                  60105,                    (: 'processing-instruction' 'else' :)
                                  63177,                    (: 'processing-instruction' 'eq' :)
                                  64713,                    (: 'processing-instruction' 'except' :)
                                  71369,                    (: 'processing-instruction' 'ge' :)
                                  73417,                    (: 'processing-instruction' 'gt' :)
                                  73929,                    (: 'processing-instruction' 'idiv' :)
                                  78537,                    (: 'processing-instruction' 'intersect' :)
                                  79049,                    (: 'processing-instruction' 'into' :)
                                  79561,                    (: 'processing-instruction' 'is' :)
                                  82121,                    (: 'processing-instruction' 'le' :)
                                  84681,                    (: 'processing-instruction' 'lt' :)
                                  85705,                    (: 'processing-instruction' 'mod' :)
                                  86217,                    (: 'processing-instruction' 'modify' :)
                                  88777,                    (: 'processing-instruction' 'ne' :)
                                  94921,                    (: 'processing-instruction' 'or' :)
                                  105673,                   (: 'processing-instruction' 'return' :)
                                  107209,                   (: 'processing-instruction' 'satisfies' :)
                                  118985,                   (: 'processing-instruction' 'to' :)
                                  122057,                   (: 'processing-instruction' 'union' :)
                                  127177,                   (: 'processing-instruction' 'where' :)
                                  128713)) then             (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (119,                          (: 'empty-sequence' :)
                              145,                          (: 'if' :)
                              156,                          (: 'item' :)
                              227,                          (: 'switch' :)
                              237)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(213, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              114,                          (: 'document' :)
                              187,                          (: 'ordered' :)
                              228,                          (: 'text' :)
                              239)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(221, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (74,                           (: 'ancestor' :)
                              75,                           (: 'ancestor-or-self' :)
                              91,                           (: 'child' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              191,                          (: 'parent' :)
                              196,                          (: 'preceding' :)
                              197,                          (: 'preceding-sibling' :)
                              202,                          (: 'property' :)
                              213)) then                    (: 'self' :)
      let $state := p:lookahead2W(220, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (7,                            (: URIQualifiedName :)
                              22,                           (: QName^Token :)
                              71,                           (: 'after' :)
                              76,                           (: 'and' :)
                              78,                           (: 'as' :)
                              79,                           (: 'ascending' :)
                              83,                           (: 'before' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              90,                           (: 'catch' :)
                              92,                           (: 'collation' :)
                              95,                           (: 'contains' :)
                              98,                           (: 'copy' :)
                              100,                          (: 'count' :)
                              103,                          (: 'declare' :)
                              104,                          (: 'default' :)
                              105,                          (: 'delete' :)
                              108,                          (: 'descending' :)
                              113,                          (: 'div' :)
                              115,                          (: 'document-node' :)
                              117,                          (: 'else' :)
                              118,                          (: 'empty' :)
                              121,                          (: 'end' :)
                              123,                          (: 'eq' :)
                              124,                          (: 'every' :)
                              126,                          (: 'except' :)
                              128,                          (: 'first' :)
                              131,                          (: 'for' :)
                              138,                          (: 'function' :)
                              139,                          (: 'ge' :)
                              141,                          (: 'group' :)
                              143,                          (: 'gt' :)
                              144,                          (: 'idiv' :)
                              146,                          (: 'import' :)
                              151,                          (: 'insert' :)
                              152,                          (: 'instance' :)
                              153,                          (: 'intersect' :)
                              154,                          (: 'into' :)
                              155,                          (: 'is' :)
                              158,                          (: 'last' :)
                              160,                          (: 'le' :)
                              162,                          (: 'let' :)
                              165,                          (: 'lt' :)
                              167,                          (: 'mod' :)
                              168,                          (: 'modify' :)
                              169,                          (: 'module' :)
                              172,                          (: 'namespace-node' :)
                              173,                          (: 'ne' :)
                              178,                          (: 'node' :)
                              183,                          (: 'only' :)
                              185,                          (: 'or' :)
                              186,                          (: 'order' :)
                              190,                          (: 'paragraphs' :)
                              200,                          (: 'private' :)
                              204,                          (: 'rename' :)
                              205,                          (: 'replace' :)
                              206,                          (: 'return' :)
                              209,                          (: 'satisfies' :)
                              211,                          (: 'schema-attribute' :)
                              212,                          (: 'schema-element' :)
                              216,                          (: 'sentences' :)
                              219,                          (: 'some' :)
                              220,                          (: 'stable' :)
                              221,                          (: 'start' :)
                              231,                          (: 'times' :)
                              232,                          (: 'to' :)
                              233,                          (: 'treat' :)
                              234,                          (: 'try' :)
                              238,                          (: 'union' :)
                              242,                          (: 'validate' :)
                              248,                          (: 'where' :)
                              251,                          (: 'with' :)
                              254,                          (: 'words' :)
                              255)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(217, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9                              (: IntegerLiteral :)
          or $state[$p:lk] = 10                             (: DecimalLiteral :)
          or $state[$p:lk] = 11                             (: DoubleLiteral :)
          or $state[$p:lk] = 12                             (: StringLiteral :)
          or $state[$p:lk] = 31                             (: '$' :)
          or $state[$p:lk] = 34                             (: '(' :)
          or $state[$p:lk] = 44                             (: '.' :)
          or $state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 59                             (: '<?' :)
          or $state[$p:lk] = 3665                           (: 'attribute' URIQualifiedName :)
          or $state[$p:lk] = 3700                           (: 'element' URIQualifiedName :)
          or $state[$p:lk] = 10923                          (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 10953                          (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 11345                          (: 'attribute' QName^Token :)
          or $state[$p:lk] = 11380                          (: 'element' QName^Token :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14963                          (: 'document-node' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14967                          (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14986                          (: 'function' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14993                          (: 'if' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15004                          (: 'item' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15020                          (: 'namespace-node' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15026                          (: 'node' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15059                          (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 15060                          (: 'schema-element' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15075                          (: 'switch' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15085                          (: 'typeswitch' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103                          (: 'xquery' '#' :)
          or $state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663                          (: 'xquery' '(' :)
          or $state[$p:lk] = 37969                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 38004                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 38481                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 38516                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 41553                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 41588                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 43089                          (: 'attribute' 'binary' :)
          or $state[$p:lk] = 43124                          (: 'element' 'binary' :)
          or $state[$p:lk] = 46161                          (: 'attribute' 'catch' :)
          or $state[$p:lk] = 46196                          (: 'element' 'catch' :)
          or $state[$p:lk] = 46673                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 46708                          (: 'element' 'child' :)
          or $state[$p:lk] = 47697                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 47732                          (: 'element' 'comment' :)
          or $state[$p:lk] = 50257                          (: 'attribute' 'copy' :)
          or $state[$p:lk] = 50292                          (: 'element' 'copy' :)
          or $state[$p:lk] = 52817                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 52852                          (: 'element' 'declare' :)
          or $state[$p:lk] = 53841                          (: 'attribute' 'delete' :)
          or $state[$p:lk] = 53876                          (: 'element' 'delete' :)
          or $state[$p:lk] = 54353                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 54388                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 54865                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 54900                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 58449                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 58484                          (: 'element' 'document' :)
          or $state[$p:lk] = 58961                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 58996                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 59473                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 59508                          (: 'element' 'element' :)
          or $state[$p:lk] = 61009                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 61044                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 63569                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 63604                          (: 'element' 'every' :)
          or $state[$p:lk] = 65617                          (: 'attribute' 'first' :)
          or $state[$p:lk] = 65652                          (: 'element' 'first' :)
          or $state[$p:lk] = 66129                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 66164                          (: 'element' 'following' :)
          or $state[$p:lk] = 66641                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 66676                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 70737                          (: 'attribute' 'function' :)
          or $state[$p:lk] = 70772                          (: 'element' 'function' :)
          or $state[$p:lk] = 74321                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 74356                          (: 'element' 'if' :)
          or $state[$p:lk] = 74833                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 74868                          (: 'element' 'import' :)
          or $state[$p:lk] = 77393                          (: 'attribute' 'insert' :)
          or $state[$p:lk] = 77428                          (: 'element' 'insert' :)
          or $state[$p:lk] = 79953                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 79988                          (: 'element' 'item' :)
          or $state[$p:lk] = 80977                          (: 'attribute' 'last' :)
          or $state[$p:lk] = 81012                          (: 'element' 'last' :)
          or $state[$p:lk] = 86609                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 86644                          (: 'element' 'module' :)
          or $state[$p:lk] = 87633                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 87668                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 88145                          (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 88180                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 91217                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 91252                          (: 'element' 'node' :)
          or $state[$p:lk] = 95825                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 95860                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 97873                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 97908                          (: 'element' 'parent' :)
          or $state[$p:lk] = 100433                         (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 100468                         (: 'element' 'preceding' :)
          or $state[$p:lk] = 100945                         (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 100980                         (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 102481                         (: 'attribute' 'private' :)
          or $state[$p:lk] = 102516                         (: 'element' 'private' :)
          or $state[$p:lk] = 102993                         (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 103028                         (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 103505                         (: 'attribute' 'property' :)
          or $state[$p:lk] = 103540                         (: 'element' 'property' :)
          or $state[$p:lk] = 104529                         (: 'attribute' 'rename' :)
          or $state[$p:lk] = 104564                         (: 'element' 'rename' :)
          or $state[$p:lk] = 105041                         (: 'attribute' 'replace' :)
          or $state[$p:lk] = 105076                         (: 'element' 'replace' :)
          or $state[$p:lk] = 108113                         (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 108148                         (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 108625                         (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 108660                         (: 'element' 'schema-element' :)
          or $state[$p:lk] = 109137                         (: 'attribute' 'self' :)
          or $state[$p:lk] = 109172                         (: 'element' 'self' :)
          or $state[$p:lk] = 112209                         (: 'attribute' 'some' :)
          or $state[$p:lk] = 112244                         (: 'element' 'some' :)
          or $state[$p:lk] = 116305                         (: 'attribute' 'switch' :)
          or $state[$p:lk] = 116340                         (: 'element' 'switch' :)
          or $state[$p:lk] = 116817                         (: 'attribute' 'text' :)
          or $state[$p:lk] = 116852                         (: 'element' 'text' :)
          or $state[$p:lk] = 119889                         (: 'attribute' 'try' :)
          or $state[$p:lk] = 119924                         (: 'element' 'try' :)
          or $state[$p:lk] = 119979                         (: 'namespace' 'try' :)
          or $state[$p:lk] = 120009                         (: 'processing-instruction' 'try' :)
          or $state[$p:lk] = 121425                         (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 121460                         (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 122449                         (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 122484                         (: 'element' 'unordered' :)
          or $state[$p:lk] = 123985                         (: 'attribute' 'validate' :)
          or $state[$p:lk] = 124020                         (: 'element' 'validate' :)
          or $state[$p:lk] = 130641                         (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 130676                         (: 'element' 'xquery' :)
          or $state[$p:lk] = 131665                         (: 'attribute' '{' :)
          or $state[$p:lk] = 131668                         (: 'binary' '{' :)
          or $state[$p:lk] = 131677                         (: 'comment' '{' :)
          or $state[$p:lk] = 131698                         (: 'document' '{' :)
          or $state[$p:lk] = 131700                         (: 'element' '{' :)
          or $state[$p:lk] = 131755                         (: 'namespace' '{' :)
          or $state[$p:lk] = 131771                         (: 'ordered' '{' :)
          or $state[$p:lk] = 131785                         (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 131812                         (: 'text' '{' :)
          or $state[$p:lk] = 131823                         (: 'unordered' '{' :)
          or $state[$p:lk] = 67407441                       (: 'attribute' 'after' '{' :)
          or $state[$p:lk] = 67407476                       (: 'element' 'after' '{' :)
          or $state[$p:lk] = 67407531                       (: 'namespace' 'after' '{' :)
          or $state[$p:lk] = 67407561                       (: 'processing-instruction' 'after' '{' :)
          or $state[$p:lk] = 67410001                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 67410036                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 67410091                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 67410121                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 67411025                       (: 'attribute' 'as' '{' :)
          or $state[$p:lk] = 67411060                       (: 'element' 'as' '{' :)
          or $state[$p:lk] = 67411115                       (: 'namespace' 'as' '{' :)
          or $state[$p:lk] = 67411145                       (: 'processing-instruction' 'as' '{' :)
          or $state[$p:lk] = 67411537                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 67411572                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 67411627                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 67411657                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 67413585                       (: 'attribute' 'before' '{' :)
          or $state[$p:lk] = 67413620                       (: 'element' 'before' '{' :)
          or $state[$p:lk] = 67413675                       (: 'namespace' 'before' '{' :)
          or $state[$p:lk] = 67413705                       (: 'processing-instruction' 'before' '{' :)
          or $state[$p:lk] = 67415633                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 67415668                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 67415723                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 67415753                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 67416145                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 67416180                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 67416235                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 67416265                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 67416657                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 67416692                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 67416747                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 67416777                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 67418193                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 67418228                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 67418283                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 67418313                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 67419729                       (: 'attribute' 'contains' '{' :)
          or $state[$p:lk] = 67419764                       (: 'element' 'contains' '{' :)
          or $state[$p:lk] = 67419819                       (: 'namespace' 'contains' '{' :)
          or $state[$p:lk] = 67419849                       (: 'processing-instruction' 'contains' '{' :)
          or $state[$p:lk] = 67422289                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 67422324                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 67422379                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 67422409                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 67424337                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 67424372                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 67424427                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 67424457                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 67426385                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 67426420                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 67426475                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 67426505                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 67428945                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 67428980                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 67429035                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 67429065                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 67430993                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 67431028                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 67431083                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 67431113                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 67431505                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 67431540                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 67431595                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 67431625                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 67433041                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 67433076                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 67433131                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 67433161                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 67434065                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 67434100                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 67434155                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 67434185                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 67435601                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 67435636                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 67435691                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 67435721                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 67438161                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 67438196                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 67438251                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 67438281                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 67442257                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 67442292                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 67442347                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 67442377                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 67443281                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 67443316                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 67443371                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 67443401                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 67444305                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 67444340                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 67444395                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 67444425                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 67444817                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 67444852                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 67444907                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 67444937                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 67448913                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 67448948                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 67449003                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 67449033                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 67449425                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 67449460                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 67449515                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 67449545                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 67449937                       (: 'attribute' 'into' '{' :)
          or $state[$p:lk] = 67449972                       (: 'element' 'into' '{' :)
          or $state[$p:lk] = 67450027                       (: 'namespace' 'into' '{' :)
          or $state[$p:lk] = 67450057                       (: 'processing-instruction' 'into' '{' :)
          or $state[$p:lk] = 67450449                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 67450484                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 67450539                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 67450569                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 67453009                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 67453044                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 67453099                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 67453129                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 67454033                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 67454068                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 67454123                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 67454153                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 67455569                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 67455604                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 67455659                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 67455689                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 67456593                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 67456628                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 67456683                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 67456713                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 67457105                       (: 'attribute' 'modify' '{' :)
          or $state[$p:lk] = 67457140                       (: 'element' 'modify' '{' :)
          or $state[$p:lk] = 67457195                       (: 'namespace' 'modify' '{' :)
          or $state[$p:lk] = 67457225                       (: 'processing-instruction' 'modify' '{' :)
          or $state[$p:lk] = 67459665                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 67459700                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 67459755                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 67459785                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 67464785                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 67464820                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 67464875                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 67464905                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 67465809                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 67465844                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 67465899                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 67465929                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 67466321                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 67466356                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 67466411                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 67466441                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 67468369                       (: 'attribute' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468404                       (: 'element' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468459                       (: 'namespace' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468489                       (: 'processing-instruction' 'paragraphs' '{' :)
          or $state[$p:lk] = 67476561                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 67476596                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 67476651                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 67476681                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 67478097                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 67478132                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 67478187                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 67478217                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 67481681                       (: 'attribute' 'sentences' '{' :)
          or $state[$p:lk] = 67481716                       (: 'element' 'sentences' '{' :)
          or $state[$p:lk] = 67481771                       (: 'namespace' 'sentences' '{' :)
          or $state[$p:lk] = 67481801                       (: 'processing-instruction' 'sentences' '{' :)
          or $state[$p:lk] = 67483729                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 67483764                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 67483819                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 67483849                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 67484241                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 67484276                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 67484331                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 67484361                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 67489361                       (: 'attribute' 'times' '{' :)
          or $state[$p:lk] = 67489396                       (: 'element' 'times' '{' :)
          or $state[$p:lk] = 67489451                       (: 'namespace' 'times' '{' :)
          or $state[$p:lk] = 67489481                       (: 'processing-instruction' 'times' '{' :)
          or $state[$p:lk] = 67489873                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 67489908                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 67489963                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 67489993                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 67490385                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 67490420                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 67490475                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 67490505                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 67492945                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 67492980                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 67493035                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 67493065                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 67498065                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 67498100                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 67498155                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 67498185                       (: 'processing-instruction' 'where' '{' :)
          or $state[$p:lk] = 67499601                       (: 'attribute' 'with' '{' :)
          or $state[$p:lk] = 67499636                       (: 'element' 'with' '{' :)
          or $state[$p:lk] = 67499691                       (: 'namespace' 'with' '{' :)
          or $state[$p:lk] = 67499721                       (: 'processing-instruction' 'with' '{' :)
          or $state[$p:lk] = 67501137                       (: 'attribute' 'words' '{' :)
          or $state[$p:lk] = 67501172                       (: 'element' 'words' '{' :)
          or $state[$p:lk] = 67501227                       (: 'namespace' 'words' '{' :)
          or $state[$p:lk] = 67501257) then                 (: 'processing-instruction' 'words' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Try parsing StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 81) then                           (: 'attribute' :)
      let $state := p:lookahead2W(250, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44625) then                    (: 'attribute' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47185) then               (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48721) then               (: 'attribute' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53329) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60497) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67153) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77905) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93777) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112721) then              (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118353) then              (: 'attribute' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40529,                    (: 'attribute' 'ascending' :)
                                  55377)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51281,                    (: 'attribute' 'count' :)
                                  83025)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62033,                    (: 'attribute' 'end' :)
                                  113233)) then             (: 'attribute' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72273,                    (: 'attribute' 'group' :)
                                  95313)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45137,                    (: 'attribute' 'cast' :)
                                  45649,                    (: 'attribute' 'castable' :)
                                  119377)) then             (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97361,                    (: 'attribute' 'paragraphs' :)
                                  110673,                   (: 'attribute' 'sentences' :)
                                  130129)) then             (: 'attribute' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36433,                    (: 'attribute' 'after' :)
                                  38993,                    (: 'attribute' 'and' :)
                                  40017,                    (: 'attribute' 'as' :)
                                  42577,                    (: 'attribute' 'before' :)
                                  57937,                    (: 'attribute' 'div' :)
                                  59985,                    (: 'attribute' 'else' :)
                                  63057,                    (: 'attribute' 'eq' :)
                                  64593,                    (: 'attribute' 'except' :)
                                  71249,                    (: 'attribute' 'ge' :)
                                  73297,                    (: 'attribute' 'gt' :)
                                  73809,                    (: 'attribute' 'idiv' :)
                                  78417,                    (: 'attribute' 'intersect' :)
                                  78929,                    (: 'attribute' 'into' :)
                                  79441,                    (: 'attribute' 'is' :)
                                  82001,                    (: 'attribute' 'le' :)
                                  84561,                    (: 'attribute' 'lt' :)
                                  85585,                    (: 'attribute' 'mod' :)
                                  86097,                    (: 'attribute' 'modify' :)
                                  88657,                    (: 'attribute' 'ne' :)
                                  94801,                    (: 'attribute' 'or' :)
                                  105553,                   (: 'attribute' 'return' :)
                                  107089,                   (: 'attribute' 'satisfies' :)
                                  118865,                   (: 'attribute' 'to' :)
                                  121937,                   (: 'attribute' 'union' :)
                                  127057,                   (: 'attribute' 'where' :)
                                  128593)) then             (: 'attribute' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 116) then                     (: 'element' :)
      let $state := p:lookahead2W(249, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44660) then                    (: 'element' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47220) then               (: 'element' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48756) then               (: 'element' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53364) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60532) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67188) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77940) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93812) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112756) then              (: 'element' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118388) then              (: 'element' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40564,                    (: 'element' 'ascending' :)
                                  55412)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51316,                    (: 'element' 'count' :)
                                  83060)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62068,                    (: 'element' 'end' :)
                                  113268)) then             (: 'element' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72308,                    (: 'element' 'group' :)
                                  95348)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45172,                    (: 'element' 'cast' :)
                                  45684,                    (: 'element' 'castable' :)
                                  119412)) then             (: 'element' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97396,                    (: 'element' 'paragraphs' :)
                                  110708,                   (: 'element' 'sentences' :)
                                  130164)) then             (: 'element' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36468,                    (: 'element' 'after' :)
                                  39028,                    (: 'element' 'and' :)
                                  40052,                    (: 'element' 'as' :)
                                  42612,                    (: 'element' 'before' :)
                                  57972,                    (: 'element' 'div' :)
                                  60020,                    (: 'element' 'else' :)
                                  63092,                    (: 'element' 'eq' :)
                                  64628,                    (: 'element' 'except' :)
                                  71284,                    (: 'element' 'ge' :)
                                  73332,                    (: 'element' 'gt' :)
                                  73844,                    (: 'element' 'idiv' :)
                                  78452,                    (: 'element' 'intersect' :)
                                  78964,                    (: 'element' 'into' :)
                                  79476,                    (: 'element' 'is' :)
                                  82036,                    (: 'element' 'le' :)
                                  84596,                    (: 'element' 'lt' :)
                                  85620,                    (: 'element' 'mod' :)
                                  86132,                    (: 'element' 'modify' :)
                                  88692,                    (: 'element' 'ne' :)
                                  94836,                    (: 'element' 'or' :)
                                  105588,                   (: 'element' 'return' :)
                                  107124,                   (: 'element' 'satisfies' :)
                                  118900,                   (: 'element' 'to' :)
                                  121972,                   (: 'element' 'union' :)
                                  127092,                   (: 'element' 'where' :)
                                  128628)) then             (: 'element' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 171) then                     (: 'namespace' :)
      let $state := p:lookahead2W(224, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'treat' | 'try' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      let $state :=
        if ($state[$p:lk] eq 44715) then                    (: 'namespace' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47275) then               (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48811) then               (: 'namespace' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53419) then               (: 'namespace' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60587) then               (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67243) then               (: 'namespace' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 77995) then               (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93867) then               (: 'namespace' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112811) then              (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118443) then              (: 'namespace' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40619,                    (: 'namespace' 'ascending' :)
                                  55467)) then              (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51371,                    (: 'namespace' 'count' :)
                                  83115)) then              (: 'namespace' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62123,                    (: 'namespace' 'end' :)
                                  113323)) then             (: 'namespace' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72363,                    (: 'namespace' 'group' :)
                                  95403)) then              (: 'namespace' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45227,                    (: 'namespace' 'cast' :)
                                  45739,                    (: 'namespace' 'castable' :)
                                  119467)) then             (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97451,                    (: 'namespace' 'paragraphs' :)
                                  110763,                   (: 'namespace' 'sentences' :)
                                  130219)) then             (: 'namespace' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36523,                    (: 'namespace' 'after' :)
                                  39083,                    (: 'namespace' 'and' :)
                                  40107,                    (: 'namespace' 'as' :)
                                  42667,                    (: 'namespace' 'before' :)
                                  58027,                    (: 'namespace' 'div' :)
                                  60075,                    (: 'namespace' 'else' :)
                                  63147,                    (: 'namespace' 'eq' :)
                                  64683,                    (: 'namespace' 'except' :)
                                  71339,                    (: 'namespace' 'ge' :)
                                  73387,                    (: 'namespace' 'gt' :)
                                  73899,                    (: 'namespace' 'idiv' :)
                                  78507,                    (: 'namespace' 'intersect' :)
                                  79019,                    (: 'namespace' 'into' :)
                                  79531,                    (: 'namespace' 'is' :)
                                  82091,                    (: 'namespace' 'le' :)
                                  84651,                    (: 'namespace' 'lt' :)
                                  85675,                    (: 'namespace' 'mod' :)
                                  86187,                    (: 'namespace' 'modify' :)
                                  88747,                    (: 'namespace' 'ne' :)
                                  94891,                    (: 'namespace' 'or' :)
                                  105643,                   (: 'namespace' 'return' :)
                                  107179,                   (: 'namespace' 'satisfies' :)
                                  118955,                   (: 'namespace' 'to' :)
                                  122027,                   (: 'namespace' 'union' :)
                                  127147,                   (: 'namespace' 'where' :)
                                  128683)) then             (: 'namespace' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 201) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(223, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 44745) then                    (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(247, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47305) then               (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 48841) then               (: 'processing-instruction' 'contains' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | ('(' ':') | 'text' | '{' :)
          return $state
        else if ($state[$p:lk] eq 53449) then               (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(133, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 60617) then               (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(144, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 67273) then               (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(150, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 78025) then               (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(121, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 93897) then               (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 112841) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(122, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 118473) then              (: 'processing-instruction' 'times' :)
          let $state := p:lookahead3W(192, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (40649,                    (: 'processing-instruction' 'ascending' :)
                                  55497)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(175, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (51401,                    (: 'processing-instruction' 'count' :)
                                  83145)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (62153,                    (: 'processing-instruction' 'end' :)
                                  113353)) then             (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (72393,                    (: 'processing-instruction' 'group' :)
                                  95433)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (45257,                    (: 'processing-instruction' 'cast' :)
                                  45769,                    (: 'processing-instruction' 'castable' :)
                                  119497)) then             (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (97481,                    (: 'processing-instruction' 'paragraphs' :)
                                  110793,                   (: 'processing-instruction' 'sentences' :)
                                  130249)) then             (: 'processing-instruction' 'words' :)
          let $state := p:lookahead3W(187, $input, $state)  (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'return' | 'same' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | 'window' |
                                                               'with' | 'without' | '{' | '}' :)
          return $state
        else if ($state[$p:lk] = (36553,                    (: 'processing-instruction' 'after' :)
                                  39113,                    (: 'processing-instruction' 'and' :)
                                  40137,                    (: 'processing-instruction' 'as' :)
                                  42697,                    (: 'processing-instruction' 'before' :)
                                  58057,                    (: 'processing-instruction' 'div' :)
                                  60105,                    (: 'processing-instruction' 'else' :)
                                  63177,                    (: 'processing-instruction' 'eq' :)
                                  64713,                    (: 'processing-instruction' 'except' :)
                                  71369,                    (: 'processing-instruction' 'ge' :)
                                  73417,                    (: 'processing-instruction' 'gt' :)
                                  73929,                    (: 'processing-instruction' 'idiv' :)
                                  78537,                    (: 'processing-instruction' 'intersect' :)
                                  79049,                    (: 'processing-instruction' 'into' :)
                                  79561,                    (: 'processing-instruction' 'is' :)
                                  82121,                    (: 'processing-instruction' 'le' :)
                                  84681,                    (: 'processing-instruction' 'lt' :)
                                  85705,                    (: 'processing-instruction' 'mod' :)
                                  86217,                    (: 'processing-instruction' 'modify' :)
                                  88777,                    (: 'processing-instruction' 'ne' :)
                                  94921,                    (: 'processing-instruction' 'or' :)
                                  105673,                   (: 'processing-instruction' 'return' :)
                                  107209,                   (: 'processing-instruction' 'satisfies' :)
                                  118985,                   (: 'processing-instruction' 'to' :)
                                  122057,                   (: 'processing-instruction' 'union' :)
                                  127177,                   (: 'processing-instruction' 'where' :)
                                  128713)) then             (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(245, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (119,                          (: 'empty-sequence' :)
                              145,                          (: 'if' :)
                              156,                          (: 'item' :)
                              227,                          (: 'switch' :)
                              237)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(213, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              114,                          (: 'document' :)
                              187,                          (: 'ordered' :)
                              228,                          (: 'text' :)
                              239)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(221, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (74,                           (: 'ancestor' :)
                              75,                           (: 'ancestor-or-self' :)
                              91,                           (: 'child' :)
                              106,                          (: 'descendant' :)
                              107,                          (: 'descendant-or-self' :)
                              129,                          (: 'following' :)
                              130,                          (: 'following-sibling' :)
                              191,                          (: 'parent' :)
                              196,                          (: 'preceding' :)
                              197,                          (: 'preceding-sibling' :)
                              202,                          (: 'property' :)
                              213)) then                    (: 'self' :)
      let $state := p:lookahead2W(220, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (7,                            (: URIQualifiedName :)
                              22,                           (: QName^Token :)
                              71,                           (: 'after' :)
                              76,                           (: 'and' :)
                              78,                           (: 'as' :)
                              79,                           (: 'ascending' :)
                              83,                           (: 'before' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              90,                           (: 'catch' :)
                              92,                           (: 'collation' :)
                              95,                           (: 'contains' :)
                              98,                           (: 'copy' :)
                              100,                          (: 'count' :)
                              103,                          (: 'declare' :)
                              104,                          (: 'default' :)
                              105,                          (: 'delete' :)
                              108,                          (: 'descending' :)
                              113,                          (: 'div' :)
                              115,                          (: 'document-node' :)
                              117,                          (: 'else' :)
                              118,                          (: 'empty' :)
                              121,                          (: 'end' :)
                              123,                          (: 'eq' :)
                              124,                          (: 'every' :)
                              126,                          (: 'except' :)
                              128,                          (: 'first' :)
                              131,                          (: 'for' :)
                              138,                          (: 'function' :)
                              139,                          (: 'ge' :)
                              141,                          (: 'group' :)
                              143,                          (: 'gt' :)
                              144,                          (: 'idiv' :)
                              146,                          (: 'import' :)
                              151,                          (: 'insert' :)
                              152,                          (: 'instance' :)
                              153,                          (: 'intersect' :)
                              154,                          (: 'into' :)
                              155,                          (: 'is' :)
                              158,                          (: 'last' :)
                              160,                          (: 'le' :)
                              162,                          (: 'let' :)
                              165,                          (: 'lt' :)
                              167,                          (: 'mod' :)
                              168,                          (: 'modify' :)
                              169,                          (: 'module' :)
                              172,                          (: 'namespace-node' :)
                              173,                          (: 'ne' :)
                              178,                          (: 'node' :)
                              183,                          (: 'only' :)
                              185,                          (: 'or' :)
                              186,                          (: 'order' :)
                              190,                          (: 'paragraphs' :)
                              200,                          (: 'private' :)
                              204,                          (: 'rename' :)
                              205,                          (: 'replace' :)
                              206,                          (: 'return' :)
                              209,                          (: 'satisfies' :)
                              211,                          (: 'schema-attribute' :)
                              212,                          (: 'schema-element' :)
                              216,                          (: 'sentences' :)
                              219,                          (: 'some' :)
                              220,                          (: 'stable' :)
                              221,                          (: 'start' :)
                              231,                          (: 'times' :)
                              232,                          (: 'to' :)
                              233,                          (: 'treat' :)
                              234,                          (: 'try' :)
                              238,                          (: 'union' :)
                              242,                          (: 'validate' :)
                              248,                          (: 'where' :)
                              251,                          (: 'with' :)
                              254,                          (: 'words' :)
                              255)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(217, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9                              (: IntegerLiteral :)
          or $state[$p:lk] = 10                             (: DecimalLiteral :)
          or $state[$p:lk] = 11                             (: DoubleLiteral :)
          or $state[$p:lk] = 12                             (: StringLiteral :)
          or $state[$p:lk] = 31                             (: '$' :)
          or $state[$p:lk] = 34                             (: '(' :)
          or $state[$p:lk] = 44                             (: '.' :)
          or $state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 59                             (: '<?' :)
          or $state[$p:lk] = 3665                           (: 'attribute' URIQualifiedName :)
          or $state[$p:lk] = 3700                           (: 'element' URIQualifiedName :)
          or $state[$p:lk] = 10923                          (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 10953                          (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 11345                          (: 'attribute' QName^Token :)
          or $state[$p:lk] = 11380                          (: 'element' QName^Token :)
          or $state[$p:lk] = 14855                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14870                          (: QName^Token '#' :)
          or $state[$p:lk] = 14919                          (: 'after' '#' :)
          or $state[$p:lk] = 14922                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14923                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14924                          (: 'and' '#' :)
          or $state[$p:lk] = 14926                          (: 'as' '#' :)
          or $state[$p:lk] = 14927                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14929                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14931                          (: 'before' '#' :)
          or $state[$p:lk] = 14932                          (: 'binary' '#' :)
          or $state[$p:lk] = 14935                          (: 'case' '#' :)
          or $state[$p:lk] = 14936                          (: 'cast' '#' :)
          or $state[$p:lk] = 14937                          (: 'castable' '#' :)
          or $state[$p:lk] = 14938                          (: 'catch' '#' :)
          or $state[$p:lk] = 14939                          (: 'child' '#' :)
          or $state[$p:lk] = 14940                          (: 'collation' '#' :)
          or $state[$p:lk] = 14941                          (: 'comment' '#' :)
          or $state[$p:lk] = 14943                          (: 'contains' '#' :)
          or $state[$p:lk] = 14946                          (: 'copy' '#' :)
          or $state[$p:lk] = 14948                          (: 'count' '#' :)
          or $state[$p:lk] = 14951                          (: 'declare' '#' :)
          or $state[$p:lk] = 14952                          (: 'default' '#' :)
          or $state[$p:lk] = 14953                          (: 'delete' '#' :)
          or $state[$p:lk] = 14954                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14955                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14956                          (: 'descending' '#' :)
          or $state[$p:lk] = 14961                          (: 'div' '#' :)
          or $state[$p:lk] = 14962                          (: 'document' '#' :)
          or $state[$p:lk] = 14963                          (: 'document-node' '#' :)
          or $state[$p:lk] = 14964                          (: 'element' '#' :)
          or $state[$p:lk] = 14965                          (: 'else' '#' :)
          or $state[$p:lk] = 14966                          (: 'empty' '#' :)
          or $state[$p:lk] = 14967                          (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 14969                          (: 'end' '#' :)
          or $state[$p:lk] = 14971                          (: 'eq' '#' :)
          or $state[$p:lk] = 14972                          (: 'every' '#' :)
          or $state[$p:lk] = 14974                          (: 'except' '#' :)
          or $state[$p:lk] = 14976                          (: 'first' '#' :)
          or $state[$p:lk] = 14977                          (: 'following' '#' :)
          or $state[$p:lk] = 14978                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14979                          (: 'for' '#' :)
          or $state[$p:lk] = 14986                          (: 'function' '#' :)
          or $state[$p:lk] = 14987                          (: 'ge' '#' :)
          or $state[$p:lk] = 14989                          (: 'group' '#' :)
          or $state[$p:lk] = 14991                          (: 'gt' '#' :)
          or $state[$p:lk] = 14992                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14993                          (: 'if' '#' :)
          or $state[$p:lk] = 14994                          (: 'import' '#' :)
          or $state[$p:lk] = 14999                          (: 'insert' '#' :)
          or $state[$p:lk] = 15000                          (: 'instance' '#' :)
          or $state[$p:lk] = 15001                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15002                          (: 'into' '#' :)
          or $state[$p:lk] = 15003                          (: 'is' '#' :)
          or $state[$p:lk] = 15004                          (: 'item' '#' :)
          or $state[$p:lk] = 15006                          (: 'last' '#' :)
          or $state[$p:lk] = 15008                          (: 'le' '#' :)
          or $state[$p:lk] = 15010                          (: 'let' '#' :)
          or $state[$p:lk] = 15013                          (: 'lt' '#' :)
          or $state[$p:lk] = 15015                          (: 'mod' '#' :)
          or $state[$p:lk] = 15016                          (: 'modify' '#' :)
          or $state[$p:lk] = 15017                          (: 'module' '#' :)
          or $state[$p:lk] = 15019                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15020                          (: 'namespace-node' '#' :)
          or $state[$p:lk] = 15021                          (: 'ne' '#' :)
          or $state[$p:lk] = 15026                          (: 'node' '#' :)
          or $state[$p:lk] = 15031                          (: 'only' '#' :)
          or $state[$p:lk] = 15033                          (: 'or' '#' :)
          or $state[$p:lk] = 15034                          (: 'order' '#' :)
          or $state[$p:lk] = 15035                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15038                          (: 'paragraphs' '#' :)
          or $state[$p:lk] = 15039                          (: 'parent' '#' :)
          or $state[$p:lk] = 15044                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15045                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15048                          (: 'private' '#' :)
          or $state[$p:lk] = 15049                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15050                          (: 'property' '#' :)
          or $state[$p:lk] = 15052                          (: 'rename' '#' :)
          or $state[$p:lk] = 15053                          (: 'replace' '#' :)
          or $state[$p:lk] = 15054                          (: 'return' '#' :)
          or $state[$p:lk] = 15057                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15059                          (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 15060                          (: 'schema-element' '#' :)
          or $state[$p:lk] = 15061                          (: 'self' '#' :)
          or $state[$p:lk] = 15064                          (: 'sentences' '#' :)
          or $state[$p:lk] = 15067                          (: 'some' '#' :)
          or $state[$p:lk] = 15068                          (: 'stable' '#' :)
          or $state[$p:lk] = 15069                          (: 'start' '#' :)
          or $state[$p:lk] = 15075                          (: 'switch' '#' :)
          or $state[$p:lk] = 15076                          (: 'text' '#' :)
          or $state[$p:lk] = 15079                          (: 'times' '#' :)
          or $state[$p:lk] = 15080                          (: 'to' '#' :)
          or $state[$p:lk] = 15081                          (: 'treat' '#' :)
          or $state[$p:lk] = 15082                          (: 'try' '#' :)
          or $state[$p:lk] = 15085                          (: 'typeswitch' '#' :)
          or $state[$p:lk] = 15086                          (: 'union' '#' :)
          or $state[$p:lk] = 15087                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15090                          (: 'validate' '#' :)
          or $state[$p:lk] = 15096                          (: 'where' '#' :)
          or $state[$p:lk] = 15099                          (: 'with' '#' :)
          or $state[$p:lk] = 15102                          (: 'words' '#' :)
          or $state[$p:lk] = 15103                          (: 'xquery' '#' :)
          or $state[$p:lk] = 17415                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17430                          (: QName^Token '(' :)
          or $state[$p:lk] = 17479                          (: 'after' '(' :)
          or $state[$p:lk] = 17482                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17483                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17484                          (: 'and' '(' :)
          or $state[$p:lk] = 17486                          (: 'as' '(' :)
          or $state[$p:lk] = 17487                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17491                          (: 'before' '(' :)
          or $state[$p:lk] = 17495                          (: 'case' '(' :)
          or $state[$p:lk] = 17496                          (: 'cast' '(' :)
          or $state[$p:lk] = 17497                          (: 'castable' '(' :)
          or $state[$p:lk] = 17498                          (: 'catch' '(' :)
          or $state[$p:lk] = 17499                          (: 'child' '(' :)
          or $state[$p:lk] = 17500                          (: 'collation' '(' :)
          or $state[$p:lk] = 17503                          (: 'contains' '(' :)
          or $state[$p:lk] = 17506                          (: 'copy' '(' :)
          or $state[$p:lk] = 17508                          (: 'count' '(' :)
          or $state[$p:lk] = 17511                          (: 'declare' '(' :)
          or $state[$p:lk] = 17512                          (: 'default' '(' :)
          or $state[$p:lk] = 17513                          (: 'delete' '(' :)
          or $state[$p:lk] = 17514                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17515                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17516                          (: 'descending' '(' :)
          or $state[$p:lk] = 17521                          (: 'div' '(' :)
          or $state[$p:lk] = 17522                          (: 'document' '(' :)
          or $state[$p:lk] = 17525                          (: 'else' '(' :)
          or $state[$p:lk] = 17526                          (: 'empty' '(' :)
          or $state[$p:lk] = 17529                          (: 'end' '(' :)
          or $state[$p:lk] = 17531                          (: 'eq' '(' :)
          or $state[$p:lk] = 17532                          (: 'every' '(' :)
          or $state[$p:lk] = 17534                          (: 'except' '(' :)
          or $state[$p:lk] = 17536                          (: 'first' '(' :)
          or $state[$p:lk] = 17537                          (: 'following' '(' :)
          or $state[$p:lk] = 17538                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17539                          (: 'for' '(' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 17547                          (: 'ge' '(' :)
          or $state[$p:lk] = 17549                          (: 'group' '(' :)
          or $state[$p:lk] = 17551                          (: 'gt' '(' :)
          or $state[$p:lk] = 17552                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17554                          (: 'import' '(' :)
          or $state[$p:lk] = 17559                          (: 'insert' '(' :)
          or $state[$p:lk] = 17560                          (: 'instance' '(' :)
          or $state[$p:lk] = 17561                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17562                          (: 'into' '(' :)
          or $state[$p:lk] = 17563                          (: 'is' '(' :)
          or $state[$p:lk] = 17566                          (: 'last' '(' :)
          or $state[$p:lk] = 17568                          (: 'le' '(' :)
          or $state[$p:lk] = 17570                          (: 'let' '(' :)
          or $state[$p:lk] = 17573                          (: 'lt' '(' :)
          or $state[$p:lk] = 17575                          (: 'mod' '(' :)
          or $state[$p:lk] = 17576                          (: 'modify' '(' :)
          or $state[$p:lk] = 17577                          (: 'module' '(' :)
          or $state[$p:lk] = 17579                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17581                          (: 'ne' '(' :)
          or $state[$p:lk] = 17591                          (: 'only' '(' :)
          or $state[$p:lk] = 17593                          (: 'or' '(' :)
          or $state[$p:lk] = 17594                          (: 'order' '(' :)
          or $state[$p:lk] = 17595                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17598                          (: 'paragraphs' '(' :)
          or $state[$p:lk] = 17599                          (: 'parent' '(' :)
          or $state[$p:lk] = 17604                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17605                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17608                          (: 'private' '(' :)
          or $state[$p:lk] = 17610                          (: 'property' '(' :)
          or $state[$p:lk] = 17612                          (: 'rename' '(' :)
          or $state[$p:lk] = 17613                          (: 'replace' '(' :)
          or $state[$p:lk] = 17614                          (: 'return' '(' :)
          or $state[$p:lk] = 17617                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17621                          (: 'self' '(' :)
          or $state[$p:lk] = 17624                          (: 'sentences' '(' :)
          or $state[$p:lk] = 17627                          (: 'some' '(' :)
          or $state[$p:lk] = 17628                          (: 'stable' '(' :)
          or $state[$p:lk] = 17629                          (: 'start' '(' :)
          or $state[$p:lk] = 17639                          (: 'times' '(' :)
          or $state[$p:lk] = 17640                          (: 'to' '(' :)
          or $state[$p:lk] = 17641                          (: 'treat' '(' :)
          or $state[$p:lk] = 17642                          (: 'try' '(' :)
          or $state[$p:lk] = 17646                          (: 'union' '(' :)
          or $state[$p:lk] = 17647                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17650                          (: 'validate' '(' :)
          or $state[$p:lk] = 17656                          (: 'where' '(' :)
          or $state[$p:lk] = 17659                          (: 'with' '(' :)
          or $state[$p:lk] = 17662                          (: 'words' '(' :)
          or $state[$p:lk] = 17663                          (: 'xquery' '(' :)
          or $state[$p:lk] = 37969                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 38004                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 38481                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 38516                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 41553                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 41588                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 43089                          (: 'attribute' 'binary' :)
          or $state[$p:lk] = 43124                          (: 'element' 'binary' :)
          or $state[$p:lk] = 46161                          (: 'attribute' 'catch' :)
          or $state[$p:lk] = 46196                          (: 'element' 'catch' :)
          or $state[$p:lk] = 46673                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 46708                          (: 'element' 'child' :)
          or $state[$p:lk] = 47697                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 47732                          (: 'element' 'comment' :)
          or $state[$p:lk] = 50257                          (: 'attribute' 'copy' :)
          or $state[$p:lk] = 50292                          (: 'element' 'copy' :)
          or $state[$p:lk] = 52817                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 52852                          (: 'element' 'declare' :)
          or $state[$p:lk] = 53841                          (: 'attribute' 'delete' :)
          or $state[$p:lk] = 53876                          (: 'element' 'delete' :)
          or $state[$p:lk] = 54353                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 54388                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 54865                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 54900                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 58449                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 58484                          (: 'element' 'document' :)
          or $state[$p:lk] = 58961                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 58996                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 59473                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 59508                          (: 'element' 'element' :)
          or $state[$p:lk] = 61009                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 61044                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 63569                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 63604                          (: 'element' 'every' :)
          or $state[$p:lk] = 65617                          (: 'attribute' 'first' :)
          or $state[$p:lk] = 65652                          (: 'element' 'first' :)
          or $state[$p:lk] = 66129                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 66164                          (: 'element' 'following' :)
          or $state[$p:lk] = 66641                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 66676                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 70737                          (: 'attribute' 'function' :)
          or $state[$p:lk] = 70772                          (: 'element' 'function' :)
          or $state[$p:lk] = 74321                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 74356                          (: 'element' 'if' :)
          or $state[$p:lk] = 74833                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 74868                          (: 'element' 'import' :)
          or $state[$p:lk] = 77393                          (: 'attribute' 'insert' :)
          or $state[$p:lk] = 77428                          (: 'element' 'insert' :)
          or $state[$p:lk] = 79953                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 79988                          (: 'element' 'item' :)
          or $state[$p:lk] = 80977                          (: 'attribute' 'last' :)
          or $state[$p:lk] = 81012                          (: 'element' 'last' :)
          or $state[$p:lk] = 86609                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 86644                          (: 'element' 'module' :)
          or $state[$p:lk] = 87633                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 87668                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 88145                          (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 88180                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 91217                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 91252                          (: 'element' 'node' :)
          or $state[$p:lk] = 95825                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 95860                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 97873                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 97908                          (: 'element' 'parent' :)
          or $state[$p:lk] = 100433                         (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 100468                         (: 'element' 'preceding' :)
          or $state[$p:lk] = 100945                         (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 100980                         (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 102481                         (: 'attribute' 'private' :)
          or $state[$p:lk] = 102516                         (: 'element' 'private' :)
          or $state[$p:lk] = 102993                         (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 103028                         (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 103505                         (: 'attribute' 'property' :)
          or $state[$p:lk] = 103540                         (: 'element' 'property' :)
          or $state[$p:lk] = 104529                         (: 'attribute' 'rename' :)
          or $state[$p:lk] = 104564                         (: 'element' 'rename' :)
          or $state[$p:lk] = 105041                         (: 'attribute' 'replace' :)
          or $state[$p:lk] = 105076                         (: 'element' 'replace' :)
          or $state[$p:lk] = 108113                         (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 108148                         (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 108625                         (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 108660                         (: 'element' 'schema-element' :)
          or $state[$p:lk] = 109137                         (: 'attribute' 'self' :)
          or $state[$p:lk] = 109172                         (: 'element' 'self' :)
          or $state[$p:lk] = 112209                         (: 'attribute' 'some' :)
          or $state[$p:lk] = 112244                         (: 'element' 'some' :)
          or $state[$p:lk] = 116305                         (: 'attribute' 'switch' :)
          or $state[$p:lk] = 116340                         (: 'element' 'switch' :)
          or $state[$p:lk] = 116817                         (: 'attribute' 'text' :)
          or $state[$p:lk] = 116852                         (: 'element' 'text' :)
          or $state[$p:lk] = 119889                         (: 'attribute' 'try' :)
          or $state[$p:lk] = 119924                         (: 'element' 'try' :)
          or $state[$p:lk] = 119979                         (: 'namespace' 'try' :)
          or $state[$p:lk] = 120009                         (: 'processing-instruction' 'try' :)
          or $state[$p:lk] = 121425                         (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 121460                         (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 122449                         (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 122484                         (: 'element' 'unordered' :)
          or $state[$p:lk] = 123985                         (: 'attribute' 'validate' :)
          or $state[$p:lk] = 124020                         (: 'element' 'validate' :)
          or $state[$p:lk] = 130641                         (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 130676                         (: 'element' 'xquery' :)
          or $state[$p:lk] = 131665                         (: 'attribute' '{' :)
          or $state[$p:lk] = 131668                         (: 'binary' '{' :)
          or $state[$p:lk] = 131677                         (: 'comment' '{' :)
          or $state[$p:lk] = 131698                         (: 'document' '{' :)
          or $state[$p:lk] = 131700                         (: 'element' '{' :)
          or $state[$p:lk] = 131755                         (: 'namespace' '{' :)
          or $state[$p:lk] = 131771                         (: 'ordered' '{' :)
          or $state[$p:lk] = 131785                         (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 131812                         (: 'text' '{' :)
          or $state[$p:lk] = 131823                         (: 'unordered' '{' :)
          or $state[$p:lk] = 67407441                       (: 'attribute' 'after' '{' :)
          or $state[$p:lk] = 67407476                       (: 'element' 'after' '{' :)
          or $state[$p:lk] = 67407531                       (: 'namespace' 'after' '{' :)
          or $state[$p:lk] = 67407561                       (: 'processing-instruction' 'after' '{' :)
          or $state[$p:lk] = 67410001                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 67410036                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 67410091                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 67410121                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 67411025                       (: 'attribute' 'as' '{' :)
          or $state[$p:lk] = 67411060                       (: 'element' 'as' '{' :)
          or $state[$p:lk] = 67411115                       (: 'namespace' 'as' '{' :)
          or $state[$p:lk] = 67411145                       (: 'processing-instruction' 'as' '{' :)
          or $state[$p:lk] = 67411537                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 67411572                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 67411627                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 67411657                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 67413585                       (: 'attribute' 'before' '{' :)
          or $state[$p:lk] = 67413620                       (: 'element' 'before' '{' :)
          or $state[$p:lk] = 67413675                       (: 'namespace' 'before' '{' :)
          or $state[$p:lk] = 67413705                       (: 'processing-instruction' 'before' '{' :)
          or $state[$p:lk] = 67415633                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 67415668                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 67415723                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 67415753                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 67416145                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 67416180                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 67416235                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 67416265                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 67416657                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 67416692                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 67416747                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 67416777                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 67418193                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 67418228                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 67418283                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 67418313                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 67419729                       (: 'attribute' 'contains' '{' :)
          or $state[$p:lk] = 67419764                       (: 'element' 'contains' '{' :)
          or $state[$p:lk] = 67419819                       (: 'namespace' 'contains' '{' :)
          or $state[$p:lk] = 67419849                       (: 'processing-instruction' 'contains' '{' :)
          or $state[$p:lk] = 67422289                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 67422324                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 67422379                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 67422409                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 67424337                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 67424372                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 67424427                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 67424457                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 67426385                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 67426420                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 67426475                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 67426505                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 67428945                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 67428980                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 67429035                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 67429065                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 67430993                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 67431028                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 67431083                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 67431113                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 67431505                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 67431540                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 67431595                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 67431625                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 67433041                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 67433076                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 67433131                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 67433161                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 67434065                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 67434100                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 67434155                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 67434185                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 67435601                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 67435636                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 67435691                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 67435721                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 67438161                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 67438196                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 67438251                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 67438281                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 67442257                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 67442292                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 67442347                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 67442377                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 67443281                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 67443316                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 67443371                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 67443401                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 67444305                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 67444340                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 67444395                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 67444425                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 67444817                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 67444852                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 67444907                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 67444937                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 67448913                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 67448948                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 67449003                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 67449033                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 67449425                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 67449460                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 67449515                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 67449545                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 67449937                       (: 'attribute' 'into' '{' :)
          or $state[$p:lk] = 67449972                       (: 'element' 'into' '{' :)
          or $state[$p:lk] = 67450027                       (: 'namespace' 'into' '{' :)
          or $state[$p:lk] = 67450057                       (: 'processing-instruction' 'into' '{' :)
          or $state[$p:lk] = 67450449                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 67450484                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 67450539                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 67450569                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 67453009                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 67453044                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 67453099                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 67453129                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 67454033                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 67454068                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 67454123                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 67454153                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 67455569                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 67455604                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 67455659                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 67455689                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 67456593                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 67456628                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 67456683                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 67456713                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 67457105                       (: 'attribute' 'modify' '{' :)
          or $state[$p:lk] = 67457140                       (: 'element' 'modify' '{' :)
          or $state[$p:lk] = 67457195                       (: 'namespace' 'modify' '{' :)
          or $state[$p:lk] = 67457225                       (: 'processing-instruction' 'modify' '{' :)
          or $state[$p:lk] = 67459665                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 67459700                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 67459755                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 67459785                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 67464785                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 67464820                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 67464875                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 67464905                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 67465809                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 67465844                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 67465899                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 67465929                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 67466321                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 67466356                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 67466411                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 67466441                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 67468369                       (: 'attribute' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468404                       (: 'element' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468459                       (: 'namespace' 'paragraphs' '{' :)
          or $state[$p:lk] = 67468489                       (: 'processing-instruction' 'paragraphs' '{' :)
          or $state[$p:lk] = 67476561                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 67476596                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 67476651                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 67476681                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 67478097                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 67478132                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 67478187                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 67478217                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 67481681                       (: 'attribute' 'sentences' '{' :)
          or $state[$p:lk] = 67481716                       (: 'element' 'sentences' '{' :)
          or $state[$p:lk] = 67481771                       (: 'namespace' 'sentences' '{' :)
          or $state[$p:lk] = 67481801                       (: 'processing-instruction' 'sentences' '{' :)
          or $state[$p:lk] = 67483729                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 67483764                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 67483819                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 67483849                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 67484241                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 67484276                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 67484331                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 67484361                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 67489361                       (: 'attribute' 'times' '{' :)
          or $state[$p:lk] = 67489396                       (: 'element' 'times' '{' :)
          or $state[$p:lk] = 67489451                       (: 'namespace' 'times' '{' :)
          or $state[$p:lk] = 67489481                       (: 'processing-instruction' 'times' '{' :)
          or $state[$p:lk] = 67489873                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 67489908                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 67489963                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 67489993                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 67490385                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 67490420                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 67490475                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 67490505                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 67492945                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 67492980                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 67493035                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 67493065                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 67498065                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 67498100                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 67498155                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 67498185                       (: 'processing-instruction' 'where' '{' :)
          or $state[$p:lk] = 67499601                       (: 'attribute' 'with' '{' :)
          or $state[$p:lk] = 67499636                       (: 'element' 'with' '{' :)
          or $state[$p:lk] = 67499691                       (: 'namespace' 'with' '{' :)
          or $state[$p:lk] = 67499721                       (: 'processing-instruction' 'with' '{' :)
          or $state[$p:lk] = 67501137                       (: 'attribute' 'words' '{' :)
          or $state[$p:lk] = 67501172                       (: 'element' 'words' '{' :)
          or $state[$p:lk] = 67501227                       (: 'namespace' 'words' '{' :)
          or $state[$p:lk] = 67501257) then                 (: 'processing-instruction' 'words' '{' :)
      let $state := p:try-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26                                 (: '!' :)
    and $state[$p:l1] != 46                                 (: '/' :)
    and $state[$p:l1] != 47) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46) then                   (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '//' :)
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(26, $input, $state)         (: '!' :)
          return $state
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26                                 (: '!' :)
    and $state[$p:l1] != 46                                 (: '/' :)
    and $state[$p:l1] != 47) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46) then                   (: '/' :)
          let $state := p:shiftT(46, $input, $state)        (: '/' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: '//' :)
          let $state := p:shiftT(47, $input, $state)        (: '//' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(26, $input, $state)        (: '!' :)
          return $state
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-StepExpr($input, $state)
      return p:try-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Try parsing RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-StepExpr($input, $state)
  let $state := p:try-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(251, $input, $state)      (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1                          (: EOF :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 41                         (: ',' :)
              or $state[$p:l1] = 42                         (: '-' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '>' :)
              or $state[$p:l1] = 62                         (: '>=' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 69                         (: ']' :)
              or $state[$p:l1] = 259                        (: '|' :)
              or $state[$p:l1] = 260                        (: '||' :)
              or $state[$p:l1] = 261) then                  (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Try parsing PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '/' :)
      let $state := p:shiftT(46, $input, $state)            (: '/' :)
      let $state := p:lookahead1W(251, $input, $state)      (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 1                          (: EOF :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 41                         (: ',' :)
              or $state[$p:l1] = 42                         (: '-' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '>' :)
              or $state[$p:l1] = 62                         (: '>=' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 69                         (: ']' :)
              or $state[$p:l1] = 259                        (: '|' :)
              or $state[$p:l1] = 260                        (: '||' :)
              or $state[$p:l1] = 261) then                  (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shiftT(47, $input, $state)            (: '//' :)
      let $state := p:lookahead1W(240, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'lax' :)
      let $state := p:shift(159, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(224, $input, $state)            (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Try parsing ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'lax' :)
      let $state := p:shiftT(159, $input, $state)           (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(224, $input, $state)           (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(242, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 137                           (: 'full' :)
         and $state[$p:l1] != 257) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 159                        (: 'lax' :)
              or $state[$p:l1] = 224) then                  (: 'strict' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 78) then               (: 'as' :)
              let $state := p:shift(78, $input, $state)     (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(236, $input, $state)    (: 'type' :)
              return $state
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'full' :)
      let $state := p:shift(137, $input, $state)            (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(257, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(261, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Try parsing ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(242, $input, $state)               (: 'validate' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 137                           (: 'full' :)
         and $state[$p:l1] != 257) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 159                        (: 'lax' :)
              or $state[$p:l1] = 224) then                  (: 'strict' :)
          let $state := p:try-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 78) then               (: 'as' :)
              let $state := p:shiftT(78, $input, $state)    (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(236, $input, $state)   (: 'type' :)
              return $state
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'full' :)
      let $state := p:shiftT(137, $input, $state)           (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shiftT(257, $input, $state)               (: '{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(261, $input, $state)               (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 242) then                          (: 'validate' :)
      let $state := p:lookahead2W(225, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'full' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'treat' | 'type' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 40178) then                    (: 'validate' 'as' :)
          let $state := p:lookahead3W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1875186                        (: 'validate' 'as' URIQualifiedName :)
          or $state[$p:lk] = 5807346                        (: 'validate' 'as' QName^Token :)
          or $state[$p:lk] = 18652402                       (: 'validate' 'as' 'after' :)
          or $state[$p:lk] = 19438834                       (: 'validate' 'as' 'ancestor' :)
          or $state[$p:lk] = 19700978                       (: 'validate' 'as' 'ancestor-or-self' :)
          or $state[$p:lk] = 19963122                       (: 'validate' 'as' 'and' :)
          or $state[$p:lk] = 20487410                       (: 'validate' 'as' 'as' :)
          or $state[$p:lk] = 20749554                       (: 'validate' 'as' 'ascending' :)
          or $state[$p:lk] = 21273842                       (: 'validate' 'as' 'attribute' :)
          or $state[$p:lk] = 21798130                       (: 'validate' 'as' 'before' :)
          or $state[$p:lk] = 22060274                       (: 'validate' 'as' 'binary' :)
          or $state[$p:lk] = 22846706                       (: 'validate' 'as' 'case' :)
          or $state[$p:lk] = 23108850                       (: 'validate' 'as' 'cast' :)
          or $state[$p:lk] = 23370994                       (: 'validate' 'as' 'castable' :)
          or $state[$p:lk] = 23633138                       (: 'validate' 'as' 'catch' :)
          or $state[$p:lk] = 23895282                       (: 'validate' 'as' 'child' :)
          or $state[$p:lk] = 24157426                       (: 'validate' 'as' 'collation' :)
          or $state[$p:lk] = 24419570                       (: 'validate' 'as' 'comment' :)
          or $state[$p:lk] = 24943858                       (: 'validate' 'as' 'contains' :)
          or $state[$p:lk] = 25730290                       (: 'validate' 'as' 'copy' :)
          or $state[$p:lk] = 26254578                       (: 'validate' 'as' 'count' :)
          or $state[$p:lk] = 27041010                       (: 'validate' 'as' 'declare' :)
          or $state[$p:lk] = 27303154                       (: 'validate' 'as' 'default' :)
          or $state[$p:lk] = 27565298                       (: 'validate' 'as' 'delete' :)
          or $state[$p:lk] = 27827442                       (: 'validate' 'as' 'descendant' :)
          or $state[$p:lk] = 28089586                       (: 'validate' 'as' 'descendant-or-self' :)
          or $state[$p:lk] = 28351730                       (: 'validate' 'as' 'descending' :)
          or $state[$p:lk] = 29662450                       (: 'validate' 'as' 'div' :)
          or $state[$p:lk] = 29924594                       (: 'validate' 'as' 'document' :)
          or $state[$p:lk] = 30186738                       (: 'validate' 'as' 'document-node' :)
          or $state[$p:lk] = 30448882                       (: 'validate' 'as' 'element' :)
          or $state[$p:lk] = 30711026                       (: 'validate' 'as' 'else' :)
          or $state[$p:lk] = 30973170                       (: 'validate' 'as' 'empty' :)
          or $state[$p:lk] = 31235314                       (: 'validate' 'as' 'empty-sequence' :)
          or $state[$p:lk] = 31759602                       (: 'validate' 'as' 'end' :)
          or $state[$p:lk] = 32283890                       (: 'validate' 'as' 'eq' :)
          or $state[$p:lk] = 32546034                       (: 'validate' 'as' 'every' :)
          or $state[$p:lk] = 33070322                       (: 'validate' 'as' 'except' :)
          or $state[$p:lk] = 33594610                       (: 'validate' 'as' 'first' :)
          or $state[$p:lk] = 33856754                       (: 'validate' 'as' 'following' :)
          or $state[$p:lk] = 34118898                       (: 'validate' 'as' 'following-sibling' :)
          or $state[$p:lk] = 34381042                       (: 'validate' 'as' 'for' :)
          or $state[$p:lk] = 36216050                       (: 'validate' 'as' 'function' :)
          or $state[$p:lk] = 36478194                       (: 'validate' 'as' 'ge' :)
          or $state[$p:lk] = 37002482                       (: 'validate' 'as' 'group' :)
          or $state[$p:lk] = 37526770                       (: 'validate' 'as' 'gt' :)
          or $state[$p:lk] = 37788914                       (: 'validate' 'as' 'idiv' :)
          or $state[$p:lk] = 38051058                       (: 'validate' 'as' 'if' :)
          or $state[$p:lk] = 38313202                       (: 'validate' 'as' 'import' :)
          or $state[$p:lk] = 39623922                       (: 'validate' 'as' 'insert' :)
          or $state[$p:lk] = 39886066                       (: 'validate' 'as' 'instance' :)
          or $state[$p:lk] = 40148210                       (: 'validate' 'as' 'intersect' :)
          or $state[$p:lk] = 40410354                       (: 'validate' 'as' 'into' :)
          or $state[$p:lk] = 40672498                       (: 'validate' 'as' 'is' :)
          or $state[$p:lk] = 40934642                       (: 'validate' 'as' 'item' :)
          or $state[$p:lk] = 41458930                       (: 'validate' 'as' 'last' :)
          or $state[$p:lk] = 41983218                       (: 'validate' 'as' 'le' :)
          or $state[$p:lk] = 42507506                       (: 'validate' 'as' 'let' :)
          or $state[$p:lk] = 43293938                       (: 'validate' 'as' 'lt' :)
          or $state[$p:lk] = 43818226                       (: 'validate' 'as' 'mod' :)
          or $state[$p:lk] = 44080370                       (: 'validate' 'as' 'modify' :)
          or $state[$p:lk] = 44342514                       (: 'validate' 'as' 'module' :)
          or $state[$p:lk] = 44866802                       (: 'validate' 'as' 'namespace' :)
          or $state[$p:lk] = 45128946                       (: 'validate' 'as' 'namespace-node' :)
          or $state[$p:lk] = 45391090                       (: 'validate' 'as' 'ne' :)
          or $state[$p:lk] = 46701810                       (: 'validate' 'as' 'node' :)
          or $state[$p:lk] = 48012530                       (: 'validate' 'as' 'only' :)
          or $state[$p:lk] = 48536818                       (: 'validate' 'as' 'or' :)
          or $state[$p:lk] = 48798962                       (: 'validate' 'as' 'order' :)
          or $state[$p:lk] = 49061106                       (: 'validate' 'as' 'ordered' :)
          or $state[$p:lk] = 49847538                       (: 'validate' 'as' 'paragraphs' :)
          or $state[$p:lk] = 50109682                       (: 'validate' 'as' 'parent' :)
          or $state[$p:lk] = 51420402                       (: 'validate' 'as' 'preceding' :)
          or $state[$p:lk] = 51682546                       (: 'validate' 'as' 'preceding-sibling' :)
          or $state[$p:lk] = 52468978                       (: 'validate' 'as' 'private' :)
          or $state[$p:lk] = 52731122                       (: 'validate' 'as' 'processing-instruction' :)
          or $state[$p:lk] = 52993266                       (: 'validate' 'as' 'property' :)
          or $state[$p:lk] = 53517554                       (: 'validate' 'as' 'rename' :)
          or $state[$p:lk] = 53779698                       (: 'validate' 'as' 'replace' :)
          or $state[$p:lk] = 54041842                       (: 'validate' 'as' 'return' :)
          or $state[$p:lk] = 54828274                       (: 'validate' 'as' 'satisfies' :)
          or $state[$p:lk] = 55352562                       (: 'validate' 'as' 'schema-attribute' :)
          or $state[$p:lk] = 55614706                       (: 'validate' 'as' 'schema-element' :)
          or $state[$p:lk] = 55876850                       (: 'validate' 'as' 'self' :)
          or $state[$p:lk] = 56663282                       (: 'validate' 'as' 'sentences' :)
          or $state[$p:lk] = 57449714                       (: 'validate' 'as' 'some' :)
          or $state[$p:lk] = 57711858                       (: 'validate' 'as' 'stable' :)
          or $state[$p:lk] = 57974002                       (: 'validate' 'as' 'start' :)
          or $state[$p:lk] = 59546866                       (: 'validate' 'as' 'switch' :)
          or $state[$p:lk] = 59809010                       (: 'validate' 'as' 'text' :)
          or $state[$p:lk] = 60595442                       (: 'validate' 'as' 'times' :)
          or $state[$p:lk] = 60857586                       (: 'validate' 'as' 'to' :)
          or $state[$p:lk] = 61119730                       (: 'validate' 'as' 'treat' :)
          or $state[$p:lk] = 61381874                       (: 'validate' 'as' 'try' :)
          or $state[$p:lk] = 62168306                       (: 'validate' 'as' 'typeswitch' :)
          or $state[$p:lk] = 62430450                       (: 'validate' 'as' 'union' :)
          or $state[$p:lk] = 62692594                       (: 'validate' 'as' 'unordered' :)
          or $state[$p:lk] = 63479026                       (: 'validate' 'as' 'validate' :)
          or $state[$p:lk] = 65051890                       (: 'validate' 'as' 'where' :)
          or $state[$p:lk] = 65838322                       (: 'validate' 'as' 'with' :)
          or $state[$p:lk] = 66624754                       (: 'validate' 'as' 'words' :)
          or $state[$p:lk] = 66886898) then                 (: 'validate' 'as' 'xquery' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-ValidateExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 70386                               (: 'validate' 'full' :)
     or $state[$p:lk] = 81650                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 114930                              (: 'validate' 'strict' :)
     or $state[$p:lk] = 121074                              (: 'validate' 'type' :)
     or $state[$p:lk] = 131826) then                        (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Try parsing ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 242) then                          (: 'validate' :)
      let $state := p:lookahead2W(225, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'full' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'treat' | 'type' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 40178) then                    (: 'validate' 'as' :)
          let $state := p:lookahead3W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1875186                        (: 'validate' 'as' URIQualifiedName :)
          or $state[$p:lk] = 5807346                        (: 'validate' 'as' QName^Token :)
          or $state[$p:lk] = 18652402                       (: 'validate' 'as' 'after' :)
          or $state[$p:lk] = 19438834                       (: 'validate' 'as' 'ancestor' :)
          or $state[$p:lk] = 19700978                       (: 'validate' 'as' 'ancestor-or-self' :)
          or $state[$p:lk] = 19963122                       (: 'validate' 'as' 'and' :)
          or $state[$p:lk] = 20487410                       (: 'validate' 'as' 'as' :)
          or $state[$p:lk] = 20749554                       (: 'validate' 'as' 'ascending' :)
          or $state[$p:lk] = 21273842                       (: 'validate' 'as' 'attribute' :)
          or $state[$p:lk] = 21798130                       (: 'validate' 'as' 'before' :)
          or $state[$p:lk] = 22060274                       (: 'validate' 'as' 'binary' :)
          or $state[$p:lk] = 22846706                       (: 'validate' 'as' 'case' :)
          or $state[$p:lk] = 23108850                       (: 'validate' 'as' 'cast' :)
          or $state[$p:lk] = 23370994                       (: 'validate' 'as' 'castable' :)
          or $state[$p:lk] = 23633138                       (: 'validate' 'as' 'catch' :)
          or $state[$p:lk] = 23895282                       (: 'validate' 'as' 'child' :)
          or $state[$p:lk] = 24157426                       (: 'validate' 'as' 'collation' :)
          or $state[$p:lk] = 24419570                       (: 'validate' 'as' 'comment' :)
          or $state[$p:lk] = 24943858                       (: 'validate' 'as' 'contains' :)
          or $state[$p:lk] = 25730290                       (: 'validate' 'as' 'copy' :)
          or $state[$p:lk] = 26254578                       (: 'validate' 'as' 'count' :)
          or $state[$p:lk] = 27041010                       (: 'validate' 'as' 'declare' :)
          or $state[$p:lk] = 27303154                       (: 'validate' 'as' 'default' :)
          or $state[$p:lk] = 27565298                       (: 'validate' 'as' 'delete' :)
          or $state[$p:lk] = 27827442                       (: 'validate' 'as' 'descendant' :)
          or $state[$p:lk] = 28089586                       (: 'validate' 'as' 'descendant-or-self' :)
          or $state[$p:lk] = 28351730                       (: 'validate' 'as' 'descending' :)
          or $state[$p:lk] = 29662450                       (: 'validate' 'as' 'div' :)
          or $state[$p:lk] = 29924594                       (: 'validate' 'as' 'document' :)
          or $state[$p:lk] = 30186738                       (: 'validate' 'as' 'document-node' :)
          or $state[$p:lk] = 30448882                       (: 'validate' 'as' 'element' :)
          or $state[$p:lk] = 30711026                       (: 'validate' 'as' 'else' :)
          or $state[$p:lk] = 30973170                       (: 'validate' 'as' 'empty' :)
          or $state[$p:lk] = 31235314                       (: 'validate' 'as' 'empty-sequence' :)
          or $state[$p:lk] = 31759602                       (: 'validate' 'as' 'end' :)
          or $state[$p:lk] = 32283890                       (: 'validate' 'as' 'eq' :)
          or $state[$p:lk] = 32546034                       (: 'validate' 'as' 'every' :)
          or $state[$p:lk] = 33070322                       (: 'validate' 'as' 'except' :)
          or $state[$p:lk] = 33594610                       (: 'validate' 'as' 'first' :)
          or $state[$p:lk] = 33856754                       (: 'validate' 'as' 'following' :)
          or $state[$p:lk] = 34118898                       (: 'validate' 'as' 'following-sibling' :)
          or $state[$p:lk] = 34381042                       (: 'validate' 'as' 'for' :)
          or $state[$p:lk] = 36216050                       (: 'validate' 'as' 'function' :)
          or $state[$p:lk] = 36478194                       (: 'validate' 'as' 'ge' :)
          or $state[$p:lk] = 37002482                       (: 'validate' 'as' 'group' :)
          or $state[$p:lk] = 37526770                       (: 'validate' 'as' 'gt' :)
          or $state[$p:lk] = 37788914                       (: 'validate' 'as' 'idiv' :)
          or $state[$p:lk] = 38051058                       (: 'validate' 'as' 'if' :)
          or $state[$p:lk] = 38313202                       (: 'validate' 'as' 'import' :)
          or $state[$p:lk] = 39623922                       (: 'validate' 'as' 'insert' :)
          or $state[$p:lk] = 39886066                       (: 'validate' 'as' 'instance' :)
          or $state[$p:lk] = 40148210                       (: 'validate' 'as' 'intersect' :)
          or $state[$p:lk] = 40410354                       (: 'validate' 'as' 'into' :)
          or $state[$p:lk] = 40672498                       (: 'validate' 'as' 'is' :)
          or $state[$p:lk] = 40934642                       (: 'validate' 'as' 'item' :)
          or $state[$p:lk] = 41458930                       (: 'validate' 'as' 'last' :)
          or $state[$p:lk] = 41983218                       (: 'validate' 'as' 'le' :)
          or $state[$p:lk] = 42507506                       (: 'validate' 'as' 'let' :)
          or $state[$p:lk] = 43293938                       (: 'validate' 'as' 'lt' :)
          or $state[$p:lk] = 43818226                       (: 'validate' 'as' 'mod' :)
          or $state[$p:lk] = 44080370                       (: 'validate' 'as' 'modify' :)
          or $state[$p:lk] = 44342514                       (: 'validate' 'as' 'module' :)
          or $state[$p:lk] = 44866802                       (: 'validate' 'as' 'namespace' :)
          or $state[$p:lk] = 45128946                       (: 'validate' 'as' 'namespace-node' :)
          or $state[$p:lk] = 45391090                       (: 'validate' 'as' 'ne' :)
          or $state[$p:lk] = 46701810                       (: 'validate' 'as' 'node' :)
          or $state[$p:lk] = 48012530                       (: 'validate' 'as' 'only' :)
          or $state[$p:lk] = 48536818                       (: 'validate' 'as' 'or' :)
          or $state[$p:lk] = 48798962                       (: 'validate' 'as' 'order' :)
          or $state[$p:lk] = 49061106                       (: 'validate' 'as' 'ordered' :)
          or $state[$p:lk] = 49847538                       (: 'validate' 'as' 'paragraphs' :)
          or $state[$p:lk] = 50109682                       (: 'validate' 'as' 'parent' :)
          or $state[$p:lk] = 51420402                       (: 'validate' 'as' 'preceding' :)
          or $state[$p:lk] = 51682546                       (: 'validate' 'as' 'preceding-sibling' :)
          or $state[$p:lk] = 52468978                       (: 'validate' 'as' 'private' :)
          or $state[$p:lk] = 52731122                       (: 'validate' 'as' 'processing-instruction' :)
          or $state[$p:lk] = 52993266                       (: 'validate' 'as' 'property' :)
          or $state[$p:lk] = 53517554                       (: 'validate' 'as' 'rename' :)
          or $state[$p:lk] = 53779698                       (: 'validate' 'as' 'replace' :)
          or $state[$p:lk] = 54041842                       (: 'validate' 'as' 'return' :)
          or $state[$p:lk] = 54828274                       (: 'validate' 'as' 'satisfies' :)
          or $state[$p:lk] = 55352562                       (: 'validate' 'as' 'schema-attribute' :)
          or $state[$p:lk] = 55614706                       (: 'validate' 'as' 'schema-element' :)
          or $state[$p:lk] = 55876850                       (: 'validate' 'as' 'self' :)
          or $state[$p:lk] = 56663282                       (: 'validate' 'as' 'sentences' :)
          or $state[$p:lk] = 57449714                       (: 'validate' 'as' 'some' :)
          or $state[$p:lk] = 57711858                       (: 'validate' 'as' 'stable' :)
          or $state[$p:lk] = 57974002                       (: 'validate' 'as' 'start' :)
          or $state[$p:lk] = 59546866                       (: 'validate' 'as' 'switch' :)
          or $state[$p:lk] = 59809010                       (: 'validate' 'as' 'text' :)
          or $state[$p:lk] = 60595442                       (: 'validate' 'as' 'times' :)
          or $state[$p:lk] = 60857586                       (: 'validate' 'as' 'to' :)
          or $state[$p:lk] = 61119730                       (: 'validate' 'as' 'treat' :)
          or $state[$p:lk] = 61381874                       (: 'validate' 'as' 'try' :)
          or $state[$p:lk] = 62168306                       (: 'validate' 'as' 'typeswitch' :)
          or $state[$p:lk] = 62430450                       (: 'validate' 'as' 'union' :)
          or $state[$p:lk] = 62692594                       (: 'validate' 'as' 'unordered' :)
          or $state[$p:lk] = 63479026                       (: 'validate' 'as' 'validate' :)
          or $state[$p:lk] = 65051890                       (: 'validate' 'as' 'where' :)
          or $state[$p:lk] = 65838322                       (: 'validate' 'as' 'with' :)
          or $state[$p:lk] = 66624754                       (: 'validate' 'as' 'words' :)
          or $state[$p:lk] = 66886898) then                 (: 'validate' 'as' 'xquery' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-ValidateExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 70386                               (: 'validate' 'full' :)
     or $state[$p:lk] = 81650                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 114930                              (: 'validate' 'strict' :)
     or $state[$p:lk] = 121074                              (: 'validate' 'type' :)
     or $state[$p:lk] = 131826) then                        (: 'validate' '{' :)
      let $state := p:try-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:try-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 42) then                 (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 42) then                 (: '-' :)
            let $state := p:shiftT(42, $input, $state)      (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(40, $input, $state)      (: '+' :)
            return $state
        return p:try-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr-1($input, $state)
  let $state := p:try-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(203, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Try parsing CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr($input, $state)
  let $state := p:lookahead1W(203, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(202, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Try parsing CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-CastExpr($input, $state)
  let $state := p:lookahead1W(202, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(201, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Try parsing TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-CastableExpr($input, $state)
  let $state := p:lookahead1W(201, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(200, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(182, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Try parsing InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-TreatExpr($input, $state)
  let $state := p:lookahead1W(200, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shiftT(182, $input, $state)           (: 'of' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(198, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 153) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 153) then                (: 'intersect' :)
            let $state := p:shift(153, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(126, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(198, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'union' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 153) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 153) then                (: 'intersect' :)
            let $state := p:shiftT(153, $input, $state)     (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(126, $input, $state)     (: 'except' :)
            return $state
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-InstanceofExpr($input, $state)
        return p:try-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Try parsing IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InstanceofExpr($input, $state)
  let $state := p:try-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 238                                (: 'union' :)
    and $state[$p:l1] != 259) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 238) then                  (: 'union' :)
          let $state := p:shift(238, $input, $state)        (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(259, $input, $state)        (: '|' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 238                                (: 'union' :)
    and $state[$p:l1] != 259) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 238) then                  (: 'union' :)
          let $state := p:shiftT(238, $input, $state)       (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(259, $input, $state)       (: '|' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-IntersectExceptExpr($input, $state)
      return p:try-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Try parsing UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-IntersectExceptExpr($input, $state)
  let $state := p:try-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '*' :)
    and $state[$p:l1] != 113                                (: 'div' :)
    and $state[$p:l1] != 144                                (: 'idiv' :)
    and $state[$p:l1] != 167) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '*' :)
          let $state := p:shift(38, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 113) then                  (: 'div' :)
          let $state := p:shift(113, $input, $state)        (: 'div' :)
          return $state
        else if ($state[$p:l1] = 144) then                  (: 'idiv' :)
          let $state := p:shift(144, $input, $state)        (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(167, $input, $state)        (: 'mod' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '*' :)
    and $state[$p:l1] != 113                                (: 'div' :)
    and $state[$p:l1] != 144                                (: 'idiv' :)
    and $state[$p:l1] != 167) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '*' :)
          let $state := p:shiftT(38, $input, $state)        (: '*' :)
          return $state
        else if ($state[$p:l1] = 113) then                  (: 'div' :)
          let $state := p:shiftT(113, $input, $state)       (: 'div' :)
          return $state
        else if ($state[$p:l1] = 144) then                  (: 'idiv' :)
          let $state := p:shiftT(144, $input, $state)       (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(167, $input, $state)       (: 'mod' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-UnionExpr($input, $state)
      return p:try-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Try parsing MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnionExpr($input, $state)
  let $state := p:try-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '+' :)
    and $state[$p:l1] != 42) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '+' :)
          let $state := p:shift(40, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(42, $input, $state)         (: '-' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40                                 (: '+' :)
    and $state[$p:l1] != 42) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: '+' :)
          let $state := p:shiftT(40, $input, $state)        (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(42, $input, $state)        (: '-' :)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-MultiplicativeExpr($input, $state)
      return p:try-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Try parsing AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MultiplicativeExpr($input, $state)
  let $state := p:try-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Try parsing RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 260) then                          (: '||' :)
      $state
    else
      let $state := p:shift(260, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 260) then                          (: '||' :)
      $state
    else
      let $state := p:shiftT(260, $input, $state)           (: '||' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-RangeExpr($input, $state)
      return p:try-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConcatExpr", $count, $begin, $end)
};

(:~
 : Try parsing StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RangeExpr($input, $state)
  let $state := p:try-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:shift(228, $input, $state)            (: 'text' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 252) then                  (: 'without' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTContainsExpr", $count, $begin, $end)
};

(:~
 : Try parsing FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:shiftT(228, $input, $state)           (: 'text' :)
      let $state := p:lookahead1W(156, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state := p:try-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 252) then                  (: 'without' :)
          let $state := p:try-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 123                            (: 'eq' :)
          or $state[$p:l1] = 139                            (: 'ge' :)
          or $state[$p:l1] = 143                            (: 'gt' :)
          or $state[$p:l1] = 155                            (: 'is' :)
          or $state[$p:l1] = 160                            (: 'le' :)
          or $state[$p:l1] = 165                            (: 'lt' :)
          or $state[$p:l1] = 173) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 123                        (: 'eq' :)
              or $state[$p:l1] = 139                        (: 'ge' :)
              or $state[$p:l1] = 143                        (: 'gt' :)
              or $state[$p:l1] = 160                        (: 'le' :)
              or $state[$p:l1] = 165                        (: 'lt' :)
              or $state[$p:l1] = 173) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 155) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTContainsExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Try parsing ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 123                            (: 'eq' :)
          or $state[$p:l1] = 139                            (: 'ge' :)
          or $state[$p:l1] = 143                            (: 'gt' :)
          or $state[$p:l1] = 155                            (: 'is' :)
          or $state[$p:l1] = 160                            (: 'le' :)
          or $state[$p:l1] = 165                            (: 'lt' :)
          or $state[$p:l1] = 173) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 123                        (: 'eq' :)
              or $state[$p:l1] = 139                        (: 'ge' :)
              or $state[$p:l1] = 143                        (: 'gt' :)
              or $state[$p:l1] = 160                        (: 'le' :)
              or $state[$p:l1] = 165                        (: 'lt' :)
              or $state[$p:l1] = 173) then                  (: 'ne' :)
          let $state := p:try-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 155) then                  (: 'is' :)
          let $state := p:try-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 76) then                           (: 'and' :)
      $state
    else
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 76) then                           (: 'and' :)
      $state
    else
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ComparisonExpr($input, $state)
      return p:try-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Try parsing AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ComparisonExpr($input, $state)
  let $state := p:try-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 185) then                          (: 'or' :)
      $state
    else
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 185) then                          (: 'or' :)
      $state
    else
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-AndExpr($input, $state)
      return p:try-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Try parsing OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AndExpr($input, $state)
  let $state := p:try-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(145, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(229, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(117, $input, $state)                (: 'else' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Try parsing IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(145, $input, $state)               (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shiftT(229, $input, $state)               (: 'then' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:shiftT(117, $input, $state)               (: 'else' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shift(259, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 259) then                        (: '|' :)
        $state
      else
        let $state := p:shiftT(259, $input, $state)         (: '|' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-SequenceType($input, $state)
        return p:try-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceTypeUnion", $count, $begin, $end)
};

(:~
 : Try parsing SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SequenceType($input, $state)
  let $state := p:try-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(87, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(237, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(87, $input, $state)                (: 'case' :)
  let $state := p:lookahead1W(237, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceTypeUnion($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:try-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(237, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Try parsing TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(237, $input, $state)               (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:try-TypeswitchExpr-1($input, $state)
  let $state := p:shiftT(104, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseOperand", $count, $begin, $end)
};

(:~
 : Try parsing SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shift(87, $input, $state)               (: 'case' :)
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shiftT(87, $input, $state)              (: 'case' :)
    let $state := p:lookahead1W(241, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state := p:try-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseClause", $count, $begin, $end)
};

(:~
 : Try parsing SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SwitchCaseClause-1($input, $state)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Try parsing Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:try-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:try-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(227, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchExpr", $count, $begin, $end)
};

(:~
 : Try parsing SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(227, $input, $state)               (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-Expr($input, $state)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:try-SwitchExpr-1($input, $state)
  let $state := p:shiftT(104, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(100, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shift(147, $input, $state)            (: 'in' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-VarName($input, $state)
      let $state := p:lookahead1W(100, $input, $state)      (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 78) then                   (: 'as' :)
          let $state := p:try-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shiftT(147, $input, $state)           (: 'in' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-ExprSingle($input, $state)
      return p:try-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shift(219, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(124, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(209, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Try parsing QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shiftT(219, $input, $state)           (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(124, $input, $state)           (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-QuantifiedExpr-1($input, $state)
  let $state := p:shiftT(209, $input, $state)               (: 'satisfies' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(206, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnClause", $count, $begin, $end)
};

(:~
 : Try parsing ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(206, $input, $state)               (: 'return' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(100, $input, $state)                (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CountClause", $count, $begin, $end)
};

(:~
 : Try parsing CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(100, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79                             (: 'ascending' :)
          or $state[$p:l1] = 108) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 79) then                   (: 'ascending' :)
          let $state := p:shift(79, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(108, $input, $state)        (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 140) then                  (: 'greatest' :)
          let $state := p:shift(140, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(161, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Try parsing OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79                             (: 'ascending' :)
          or $state[$p:l1] = 108) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 79) then                   (: 'ascending' :)
          let $state := p:shiftT(79, $input, $state)        (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(108, $input, $state)       (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 140) then                  (: 'greatest' :)
          let $state := p:shiftT(140, $input, $state)       (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(161, $input, $state)       (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Try parsing OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(241, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-OrderSpec($input, $state)
        return p:try-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Try parsing OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-OrderSpec($input, $state)
  let $state := p:try-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(86, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(86, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Try parsing OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shiftT(86, $input, $state)            (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shiftT(86, $input, $state)            (: 'by' :)
      return $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpec", $count, $begin, $end)
};

(:~
 : Try parsing GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:try-GroupingSpec($input, $state)
        return p:try-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpecList", $count, $begin, $end)
};

(:~
 : Try parsing GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-GroupingSpec($input, $state)
  let $state := p:try-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(141, $input, $state)                (: 'group' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shift(86, $input, $state)                 (: 'by' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-GroupingSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupByClause", $count, $begin, $end)
};

(:~
 : Try parsing GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(141, $input, $state)               (: 'group' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shiftT(86, $input, $state)                (: 'by' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(248, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Try parsing WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(248, $input, $state)               (: 'where' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131                            (: 'for' :)
          or $state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IntermediateClause", $count, $begin, $end)
};

(:~
 : Try parsing IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131                            (: 'for' :)
          or $state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:try-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:try-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:try-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:try-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(218, $input, $state)                (: 'sliding' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowEndCondition($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SlidingWindowClause", $count, $begin, $end)
};

(:~
 : Try parsing SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(218, $input, $state)               (: 'sliding' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-WindowStartCondition($input, $state)
  let $state := p:try-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shift(121, $input, $state)                (: 'end' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(247, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowEndCondition", $count, $begin, $end)
};

(:~
 : Try parsing WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shiftT(121, $input, $state)               (: 'end' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shiftT(247, $input, $state)               (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NextItem", $count, $begin, $end)
};

(:~
 : Try parsing NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreviousItem", $count, $begin, $end)
};

(:~
 : Try parsing PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurrentItem", $count, $begin, $end)
};

(:~
 : Try parsing CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 199) then                      (: 'previous' :)
      let $state := p:shift(199, $input, $state)            (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'next' :)
      let $state := p:shift(174, $input, $state)            (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowVars", $count, $begin, $end)
};

(:~
 : Try parsing WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 199) then                      (: 'previous' :)
      let $state := p:shiftT(199, $input, $state)           (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'next' :)
      let $state := p:shiftT(174, $input, $state)           (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shiftT(31, $input, $state)            (: '$' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(221, $input, $state)                (: 'start' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(247, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowStartCondition", $count, $begin, $end)
};

(:~
 : Try parsing WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(221, $input, $state)               (: 'start' :)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shiftT(247, $input, $state)               (: 'when' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(235, $input, $state)                (: 'tumbling' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(250, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121                            (: 'end' :)
          or $state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TumblingWindowClause", $count, $begin, $end)
};

(:~
 : Try parsing TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(235, $input, $state)               (: 'tumbling' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shiftT(250, $input, $state)               (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  let $state := p:try-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121                            (: 'end' :)
          or $state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:try-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(131, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 235) then                      (: 'tumbling' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowClause", $count, $begin, $end)
};

(:~
 : Try parsing WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(131, $input, $state)               (: 'for' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 235) then                      (: 'tumbling' :)
      let $state := p:try-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetBinding", $count, $begin, $end)
};

(:~
 : Try parsing LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shiftT(51, $input, $state)                (: ':=' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:try-LetBinding($input, $state)
      return p:try-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(162, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Try parsing LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(162, $input, $state)               (: 'let' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-LetBinding($input, $state)
  let $state := p:try-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Try parsing PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(80, $input, $state)                (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(73, $input, $state)                 (: 'allowing' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(118, $input, $state)                (: 'empty' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AllowingEmpty", $count, $begin, $end)
};

(:~
 : Try parsing AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(73, $input, $state)                (: 'allowing' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shiftT(118, $input, $state)               (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Try parsing VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'allowing' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(147, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForBinding", $count, $begin, $end)
};

(:~
 : Try parsing ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(31, $input, $state)                (: '$' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-VarName($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'allowing' :)
      let $state := p:try-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shiftT(147, $input, $state)               (: 'in' :)
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 41) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(41, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:try-ForBinding($input, $state)
      return p:try-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(131, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Try parsing ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(131, $input, $state)               (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:try-ForBinding($input, $state)
  let $state := p:try-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 131) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16003) then                    (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 162) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialClause", $count, $begin, $end)
};

(:~
 : Try parsing InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 131) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16003) then                    (: 'for' '$' :)
      let $state := p:try-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 162) then                      (: 'let' :)
      let $state := p:try-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(167, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 206) then                         (: 'return' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(167, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 206) then                         (: 'return' :)
        $state
      else
        let $state := p:try-IntermediateClause($input, $state)
        return p:try-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Try parsing FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InitialClause($input, $state)
  let $state := p:try-FLWORExpr-1($input, $state)
  let $state := p:try-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 131) then                          (: 'for' :)
      let $state := p:lookahead2W(212, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | 'with' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] eq 204) then                     (: 'rename' :)
      let $state := p:lookahead2W(207, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 205) then                     (: 'replace' :)
      let $state := p:lookahead2W(210, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'value' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 234) then                     (: 'try' :)
      let $state := p:lookahead2W(208, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (105,                          (: 'delete' :)
                              151)) then                    (: 'insert' :)
      let $state := p:lookahead2W(209, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'nodes' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (145,                          (: 'if' :)
                              227,                          (: 'switch' :)
                              237)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (98,                           (: 'copy' :)
                              124,                          (: 'every' :)
                              162,                          (: 'let' :)
                              219)) then                    (: 'some' :)
      let $state := p:lookahead2W(206, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16003                          (: 'for' '$' :)
          or $state[$p:lk] = 16034                          (: 'let' '$' :)
          or $state[$p:lk] = 111747                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 120451) then                   (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15996                          (: 'every' '$' :)
          or $state[$p:lk] = 16091) then                    (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17635) then                    (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17645) then                    (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17553) then                    (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131818) then                   (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91287                          (: 'insert' 'node' :)
          or $state[$p:lk] = 91799) then                    (: 'insert' 'nodes' :)
      let $state := p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91241                          (: 'delete' 'node' :)
          or $state[$p:lk] = 91753) then                    (: 'delete' 'nodes' :)
      let $state := p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91340) then                    (: 'rename' 'node' :)
      let $state := p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91341                          (: 'replace' 'node' :)
          or $state[$p:lk] = 124621) then                   (: 'replace' 'value' :)
      let $state := p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15970) then                    (: 'copy' '$' :)
      let $state := p:parse-TransformExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Try parsing ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 131) then                          (: 'for' :)
      let $state := p:lookahead2W(212, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | 'with' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] eq 204) then                     (: 'rename' :)
      let $state := p:lookahead2W(207, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 205) then                     (: 'replace' :)
      let $state := p:lookahead2W(210, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'value' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 234) then                     (: 'try' :)
      let $state := p:lookahead2W(208, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (105,                          (: 'delete' :)
                              151)) then                    (: 'insert' :)
      let $state := p:lookahead2W(209, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'node' |
                                                               'nodes' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (145,                          (: 'if' :)
                              227,                          (: 'switch' :)
                              237)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (98,                           (: 'copy' :)
                              124,                          (: 'every' :)
                              162,                          (: 'let' :)
                              219)) then                    (: 'some' :)
      let $state := p:lookahead2W(206, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16003                          (: 'for' '$' :)
          or $state[$p:lk] = 16034                          (: 'let' '$' :)
          or $state[$p:lk] = 111747                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 120451) then                   (: 'for' 'tumbling' :)
      let $state := p:try-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15996                          (: 'every' '$' :)
          or $state[$p:lk] = 16091) then                    (: 'some' '$' :)
      let $state := p:try-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17635) then                    (: 'switch' '(' :)
      let $state := p:try-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17645) then                    (: 'typeswitch' '(' :)
      let $state := p:try-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17553) then                    (: 'if' '(' :)
      let $state := p:try-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 131818) then                   (: 'try' '{' :)
      let $state := p:try-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91287                          (: 'insert' 'node' :)
          or $state[$p:lk] = 91799) then                    (: 'insert' 'nodes' :)
      let $state := p:try-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91241                          (: 'delete' 'node' :)
          or $state[$p:lk] = 91753) then                    (: 'delete' 'nodes' :)
      let $state := p:try-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91340) then                    (: 'rename' 'node' :)
      let $state := p:try-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 91341                          (: 'replace' 'node' :)
          or $state[$p:lk] = 124621) then                   (: 'replace' 'value' :)
      let $state := p:try-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 15970) then                    (: 'copy' '$' :)
      let $state := p:try-TransformExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarValue", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Try parsing ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicOrUnionType", $count, $begin, $end)
};

(:~
 : Try parsing AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shift(39, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Try parsing OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:shiftT(64, $input, $state)            (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shiftT(39, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(40, $input, $state)            (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17527) then                    (: 'empty-sequence' '(' :)
      let $state := p:shift(119, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(216, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Try parsing SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17527) then                    (: 'empty-sequence' '(' :)
      let $state := p:shiftT(119, $input, $state)           (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ItemType($input, $state)
      let $state := p:lookahead1W(216, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:try-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
        let $state := p:try-SequenceType($input, $state)
        return p:try-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(238, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(78, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(238, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-SequenceType($input, $state)
      let $state := p:try-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shiftT(78, $input, $state)                (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(138, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(38, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(138, $input, $state)               (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shiftT(38, $input, $state)                (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: IntegerLiteral :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shift(10, $input, $state)             (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(11, $input, $state)             (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 9) then                        (: IntegerLiteral :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shiftT(10, $input, $state)            (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(11, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12) then                       (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 12) then                       (: StringLiteral :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(148, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(148, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:try-Literal($input, $state)
        return p:try-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 32) then                       (: '%' :)
      let $state := p:shift(32, $input, $state)             (: '%' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      let $state := p:lookahead1W(158, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shift(34, $input, $state)         (: '(' :)
          let $state := p:lookahead1W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Literal($input, $state)
          let $state := p:parse-Annotation-1($input, $state)
          let $state := p:shift(37, $input, $state)         (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(200, $input, $state)            (: 'private' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Annotation", $count, $begin, $end)
};

(:~
 : Try parsing Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 32) then                       (: '%' :)
      let $state := p:shiftT(32, $input, $state)            (: '%' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:try-EQName($input, $state)
      let $state := p:lookahead1W(158, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shiftT(34, $input, $state)        (: '(' :)
          let $state := p:lookahead1W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:try-Literal($input, $state)
          let $state := p:try-Annotation-1($input, $state)
          let $state := p:shiftT(37, $input, $state)        (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(200, $input, $state)           (: 'private' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 138) then                         (: 'function' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 138) then                         (: 'function' :)
        $state
      else
        let $state := p:try-Annotation($input, $state)
        return p:try-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 138) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 17546) then                    (: 'function' '(' :)
          let $state := p:lookahead3W(239, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9979018) then                  (: 'function' '(' '*' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Try parsing FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 138) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 17546) then                    (: 'function' '(' :)
          let $state := p:lookahead3W(239, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9979018) then                  (: 'function' '(' '*' :)
      let $state := p:try-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(84, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "BinaryTest", $count, $begin, $end)
};

(:~
 : Try parsing BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(84, $input, $state)                (: 'binary' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(178, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Try parsing AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(178, $input, $state)               (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(172, $input, $state)                (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Try parsing NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(172, $input, $state)               (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(228, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Try parsing TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(228, $input, $state)               (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(93, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Try parsing CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(93, $input, $state)                (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(201, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(183, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 12) then                   (: StringLiteral :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Try parsing PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(201, $input, $state)               (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(183, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | 'with' | 'words' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 12) then                   (: StringLiteral :)
          let $state := p:shiftT(12, $input, $state)        (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(211, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Try parsing SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(211, $input, $state)               (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Try parsing AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Try parsing AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shiftT(38, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(81, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Try parsing AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(81, $input, $state)                (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shiftT(41, $input, $state)        (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(212, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Try parsing SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(212, $input, $state)               (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Try parsing TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Try parsing ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Try parsing ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shiftT(38, $input, $state)            (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(116, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(93, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shift(64, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Try parsing ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(116, $input, $state)               (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(236, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:try-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(92, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shiftT(41, $input, $state)        (: ',' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:try-TypeName($input, $state)
          let $state := p:lookahead1W(93, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shiftT(64, $input, $state)    (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(115, $input, $state)                (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 116) then                  (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Try parsing DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(115, $input, $state)               (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shiftT(34, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 116) then                  (: 'element' :)
          let $state := p:try-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:try-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shiftT(37, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-BinaryTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Try parsing KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:try-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:try-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:try-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:try-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:try-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:try-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:try-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:try-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:try-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:try-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-BinaryTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 200) then                          (: 'private' :)
      let $state := p:lookahead2W(222, $input, $state)      (: EOF | S^WS | '!=' | '%' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'private' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = (81,                           (: 'attribute' :)
                              84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              115,                          (: 'document-node' :)
                              116,                          (: 'element' :)
                              138,                          (: 'function' :)
                              156,                          (: 'item' :)
                              172,                          (: 'namespace-node' :)
                              178,                          (: 'node' :)
                              201,                          (: 'processing-instruction' :)
                              211,                          (: 'schema-attribute' :)
                              212,                          (: 'schema-element' :)
                              228)) then                    (: 'text' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17489                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17492                          (: 'binary' '(' :)
          or $state[$p:lk] = 17501                          (: 'comment' '(' :)
          or $state[$p:lk] = 17523                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17524                          (: 'element' '(' :)
          or $state[$p:lk] = 17580                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17586                          (: 'node' '(' :)
          or $state[$p:lk] = 17609                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17619                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17620                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17636) then                    (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17564) then                    (: 'item' '(' :)
      let $state := p:shift(156, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 16584                          (: 'private' '%' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 70856                          (: 'private' 'function' :)
          or $state[$p:lk] = 102600) then                   (: 'private' 'private' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Try parsing ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 200) then                          (: 'private' :)
      let $state := p:lookahead2W(222, $input, $state)      (: EOF | S^WS | '!=' | '%' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'private' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'union' | 'where' | 'with' | 'words' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] = (81,                           (: 'attribute' :)
                              84,                           (: 'binary' :)
                              93,                           (: 'comment' :)
                              115,                          (: 'document-node' :)
                              116,                          (: 'element' :)
                              138,                          (: 'function' :)
                              156,                          (: 'item' :)
                              172,                          (: 'namespace-node' :)
                              178,                          (: 'node' :)
                              201,                          (: 'processing-instruction' :)
                              211,                          (: 'schema-attribute' :)
                              212,                          (: 'schema-element' :)
                              228)) then                    (: 'text' :)
      let $state := p:lookahead2W(219, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'external' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'only' | 'or' | 'order' | 'paragraphs' | 'return' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'union' | 'where' | 'with' | 'words' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17489                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17492                          (: 'binary' '(' :)
          or $state[$p:lk] = 17501                          (: 'comment' '(' :)
          or $state[$p:lk] = 17523                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17524                          (: 'element' '(' :)
          or $state[$p:lk] = 17580                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17586                          (: 'node' '(' :)
          or $state[$p:lk] = 17609                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17619                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17620                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17636) then                    (: 'text' '(' :)
      let $state := p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17564) then                    (: 'item' '(' :)
      let $state := p:shiftT(156, $input, $state)           (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 16584                          (: 'private' '%' :)
          or $state[$p:lk] = 17546                          (: 'function' '(' :)
          or $state[$p:lk] = 70856                          (: 'private' 'function' :)
          or $state[$p:lk] = 102600) then                   (: 'private' 'private' :)
      let $state := p:try-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:try-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:shift(97, $input, $state)                 (: 'context' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:shift(156, $input, $state)                (: 'item' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(235, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(241, $input, $state)      (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(127, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(241, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemDecl", $count, $begin, $end)
};

(:~
 : Parse FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(184, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTExtensionOption", $count, $begin, $end)
};

(:~
 : Try parsing FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(184, $input, $state)               (: 'option' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:try-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(12, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTStopWords($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordsInclExcl", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state := p:try-FTStopWords($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWords-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-FTStopWords-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWords-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shiftT(12, $input, $state)          (: StringLiteral :)
        return p:try-FTStopWords-1($input, $state)
};

(:~
 : Parse FTStopWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:parse-FTStopWords-1($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWords", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWords.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(8, $input, $state)             (: URILiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      let $state := p:try-FTStopWords-1($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-1($input, $state)
};

(:~
 : Parse the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'except' | 'for' | 'ftand' | 'ftor' |
                                                               'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 126                              (: 'except' :)
      and $state[$p:l1] != 238) then                        (: 'union' :)
        $state
      else
        let $state := p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-2($input, $state)
};

(:~
 : Parse FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 223) then                          (: 'stop' :)
      let $state := p:lookahead2W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state :=
        if ($state[$p:lk] eq 130271) then                   (: 'stop' 'words' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 27393247) then                 (: 'stop' 'words' 'default' :)
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:parse-FTStopWordOption-2($input, $state)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(223, $input, $state)            (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | '(' | ('(' ':') | 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTStopWords($input, $state)
      let $state := p:parse-FTStopWordOption-1($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStopWordOption", $count, $begin, $end)
};

(:~
 : Try parsing FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 223) then                          (: 'stop' :)
      let $state := p:lookahead2W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state :=
        if ($state[$p:lk] eq 130271) then                   (: 'stop' 'words' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 27393247) then                 (: 'stop' 'words' 'default' :)
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      let $state := p:try-FTStopWordOption-2($input, $state)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(223, $input, $state)           (: 'stop' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | '(' | ('(' ':') | 'at' :)
      let $state := p:try-FTStopWords($input, $state)
      let $state := p:try-FTStopWordOption-1($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 109) then                          (: 'diacritics' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 76909) then                    (: 'diacritics' 'insensitive' :)
      let $state := p:shift(109, $input, $state)            (: 'diacritics' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shift(150, $input, $state)            (: 'insensitive' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(109, $input, $state)            (: 'diacritics' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shift(214, $input, $state)            (: 'sensitive' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTDiacriticsOption", $count, $begin, $end)
};

(:~
 : Try parsing FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 109) then                          (: 'diacritics' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 76909) then                    (: 'diacritics' 'insensitive' :)
      let $state := p:shiftT(109, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shiftT(150, $input, $state)           (: 'insensitive' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(109, $input, $state)           (: 'diacritics' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shiftT(214, $input, $state)           (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Parse FTCaseOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 87) then                           (: 'case' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 76887) then                    (: 'case' 'insensitive' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shift(150, $input, $state)            (: 'insensitive' :)
      return $state
    else if ($state[$p:lk] = 109655) then                   (: 'case' 'sensitive' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shift(214, $input, $state)            (: 'sensitive' :)
      return $state
    else if ($state[$p:lk] = 164) then                      (: 'lowercase' :)
      let $state := p:shift(164, $input, $state)            (: 'lowercase' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(240, $input, $state)            (: 'uppercase' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTCaseOption", $count, $begin, $end)
};

(:~
 : Try parsing FTCaseOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 87) then                           (: 'case' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 76887) then                    (: 'case' 'insensitive' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'insensitive' :)
      let $state := p:shiftT(150, $input, $state)           (: 'insensitive' :)
      return $state
    else if ($state[$p:lk] = 109655) then                   (: 'case' 'sensitive' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'sensitive' :)
      let $state := p:shiftT(214, $input, $state)           (: 'sensitive' :)
      return $state
    else if ($state[$p:lk] = 164) then                      (: 'lowercase' :)
      let $state := p:shiftT(164, $input, $state)           (: 'lowercase' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(240, $input, $state)           (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Parse FTStemOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 222) then                      (: 'stemming' :)
      let $state := p:shift(222, $input, $state)            (: 'stemming' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:shift(222, $input, $state)            (: 'stemming' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTStemOption", $count, $begin, $end)
};

(:~
 : Try parsing FTStemOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 222) then                      (: 'stemming' :)
      let $state := p:shiftT(222, $input, $state)           (: 'stemming' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:shiftT(222, $input, $state)           (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Parse FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125) then                      (: 'exactly' :)
      let $state := p:shift(125, $input, $state)            (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shift(170, $input, $state)            (: 'most' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(132, $input, $state)            (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTLiteralRange", $count, $begin, $end)
};

(:~
 : Try parsing FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125) then                      (: 'exactly' :)
      let $state := p:shiftT(125, $input, $state)           (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 82512) then                    (: 'at' 'least' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'least' :)
      let $state := p:shiftT(161, $input, $state)           (: 'least' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:shiftT(80, $input, $state)            (: 'at' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'most' :)
      let $state := p:shiftT(170, $input, $state)           (: 'most' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(132, $input, $state)           (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(9, $input, $state)             (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(197, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'relationship' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'start' | 'using' |
                                                               'weight' | 'where' | 'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 203) then                      (: 'relationship' :)
      let $state := p:shift(203, $input, $state)            (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(193, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125                            (: 'exactly' :)
          or $state[$p:lk] = 132                            (: 'from' :)
          or $state[$p:lk] = 82512                          (: 'at' 'least' :)
          or $state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:shift(163, $input, $state)            (: 'levels' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusID", $count, $begin, $end)
};

(:~
 : Try parsing FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(80, $input, $state)                (: 'at' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(8, $input, $state)                 (: URILiteral :)
  let $state := p:lookahead1W(197, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'relationship' | 'return' |
                                                               'same' | 'satisfies' | 'stable' | 'start' | 'using' |
                                                               'weight' | 'where' | 'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 203) then                      (: 'relationship' :)
      let $state := p:shiftT(203, $input, $state)           (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shiftT(12, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(193, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'exactly' | 'for' | 'from' | 'ftand' |
                                                               'ftor' | 'ge' | 'group' | 'gt' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'modify' | 'ne' | 'not' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'return' | 'same' | 'satisfies' |
                                                               'stable' | 'start' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | '}' :)
  let $state :=
    if ($state[$p:l1] eq 80) then                           (: 'at' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 125                            (: 'exactly' :)
          or $state[$p:lk] = 132                            (: 'from' :)
          or $state[$p:lk] = 82512                          (: 'at' 'least' :)
          or $state[$p:lk] = 87120) then                    (: 'at' 'most' :)
      let $state := p:try-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:shiftT(163, $input, $state)           (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-FTThesaurusID($input, $state)
        return p:parse-FTThesaurusOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusOption-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(41, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state := p:try-FTThesaurusID($input, $state)
        return p:try-FTThesaurusOption-1($input, $state)
};

(:~
 : Parse FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 230) then                          (: 'thesaurus' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17638) then                    (: 'thesaurus' '(' :)
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(104, $input, $state)        (: 'default' :)
          return $state
      let $state := p:parse-FTThesaurusOption-1($input, $state)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(230, $input, $state)            (: 'thesaurus' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'at' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(104, $input, $state)        (: 'default' :)
          return $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTThesaurusOption", $count, $begin, $end)
};

(:~
 : Try parsing FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 230) then                          (: 'thesaurus' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17638) then                    (: 'thesaurus' '(' :)
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shiftT(34, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'at' :)
          let $state := p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(104, $input, $state)       (: 'default' :)
          return $state
      let $state := p:try-FTThesaurusOption-1($input, $state)
      let $state := p:shiftT(37, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:lk] = 175) then                      (: 'no' :)
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(230, $input, $state)           (: 'thesaurus' :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'at' :)
          let $state := p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(104, $input, $state)       (: 'default' :)
          return $state
      return $state
  return $state
};

(:~
 : Parse FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 249) then                      (: 'wildcards' :)
      let $state := p:shift(249, $input, $state)            (: 'wildcards' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(175, $input, $state)            (: 'no' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:shift(249, $input, $state)            (: 'wildcards' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTWildCardOption", $count, $begin, $end)
};

(:~
 : Try parsing FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 249) then                      (: 'wildcards' :)
      let $state := p:shiftT(249, $input, $state)           (: 'wildcards' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(175, $input, $state)           (: 'no' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:shiftT(249, $input, $state)           (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Parse FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(157, $input, $state)                (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTLanguageOption", $count, $begin, $end)
};

(:~
 : Try parsing FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(157, $input, $state)               (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shiftT(12, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTMatchOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 175) then                          (: 'no' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 157) then                      (: 'language' :)
      let $state := p:parse-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 249                            (: 'wildcards' :)
          or $state[$p:lk] = 127663) then                   (: 'no' 'wildcards' :)
      let $state := p:parse-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 230                            (: 'thesaurus' :)
          or $state[$p:lk] = 117935) then                   (: 'no' 'thesaurus' :)
      let $state := p:parse-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 222                            (: 'stemming' :)
          or $state[$p:lk] = 113839) then                   (: 'no' 'stemming' :)
      let $state := p:parse-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 109) then                      (: 'diacritics' :)
      let $state := p:parse-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 223                            (: 'stop' :)
          or $state[$p:lk] = 114351) then                   (: 'no' 'stop' :)
      let $state := p:parse-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 184) then                      (: 'option' :)
      let $state := p:parse-FTExtensionOption($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FTCaseOption($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOption", $count, $begin, $end)
};

(:~
 : Try parsing FTMatchOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 175) then                          (: 'no' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 157) then                      (: 'language' :)
      let $state := p:try-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 249                            (: 'wildcards' :)
          or $state[$p:lk] = 127663) then                   (: 'no' 'wildcards' :)
      let $state := p:try-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 230                            (: 'thesaurus' :)
          or $state[$p:lk] = 117935) then                   (: 'no' 'thesaurus' :)
      let $state := p:try-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 222                            (: 'stemming' :)
          or $state[$p:lk] = 113839) then                   (: 'no' 'stemming' :)
      let $state := p:try-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 109) then                      (: 'diacritics' :)
      let $state := p:try-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 223                            (: 'stop' :)
          or $state[$p:lk] = 114351) then                   (: 'no' 'stop' :)
      let $state := p:try-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 184) then                      (: 'option' :)
      let $state := p:try-FTExtensionOption($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOptions-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shift(241, $input, $state)              (: 'using' :)
    let $state := p:lookahead1W(174, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-FTMatchOption($input, $state)
    let $state := p:lookahead1W(190, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 241) then                        (: 'using' :)
        $state
      else
        p:parse-FTMatchOptions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOptions-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shiftT(241, $input, $state)             (: 'using' :)
    let $state := p:lookahead1W(174, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state := p:try-FTMatchOption($input, $state)
    let $state := p:lookahead1W(190, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'different' | 'distance' | 'else' | 'empty' | 'end' |
                                                               'entire' | 'eq' | 'for' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'modify' | 'ne' | 'not' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'return' | 'same' | 'satisfies' | 'stable' |
                                                               'start' | 'using' | 'weight' | 'where' | 'window' |
                                                               'with' | 'without' | '}' :)
    return
      if ($state[$p:l1] != 241) then                        (: 'using' :)
        $state
      else
        p:try-FTMatchOptions-1($input, $state)
};

(:~
 : Parse FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FTMatchOptions-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTMatchOptions", $count, $begin, $end)
};

(:~
 : Try parsing FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Parse FTOptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FTOptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'ft-option' :)
  let $state := p:shift(133, $input, $state)                (: 'ft-option' :)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'using' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FTMatchOptions($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FTOptionDecl", $count, $begin, $end)
};

(:~
 : Parse ImportStylesheetDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportStylesheetDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | 'stylesheet' :)
  let $state := p:shift(226, $input, $state)                (: 'stylesheet' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'at' :)
  let $state := p:shift(80, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ImportStylesheetDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:shift(169, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(83, $input, $state)           (: URILiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(181, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(181, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(146, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:shift(210, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(131, $input, $state)          (: URILiteral | S^WS | ('(' ':') | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 8) then                       (: URILiteral :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'at' :)
      let $state := p:shift(80, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 146) then                          (: 'import' :)
      let $state := p:lookahead2W(146, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' | 'stylesheet' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 107666) then                   (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:lk] = 86674) then                    (: 'import' 'module' :)
      let $state := p:parse-ModuleImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ImportStylesheetDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(181, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 102) then                      (: 'decimal-separator' :)
      let $state := p:shift(102, $input, $state)            (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'grouping-separator' :)
      let $state := p:shift(142, $input, $state)            (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'infinity' :)
      let $state := p:shift(148, $input, $state)            (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'minus-sign' :)
      let $state := p:shift(166, $input, $state)            (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'NaN' :)
      let $state := p:shift(67, $input, $state)             (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'percent' :)
      let $state := p:shift(194, $input, $state)            (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'per-mille' :)
      let $state := p:shift(193, $input, $state)            (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 256) then                      (: 'zero-digit' :)
      let $state := p:shift(256, $input, $state)            (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'digit' :)
      let $state := p:shift(111, $input, $state)            (: 'digit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(192, $input, $state)            (: 'pattern-separator' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DFPropertyName", $count, $begin, $end)
};

(:~
 : Parse FunctionQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: QName^Token :)
      let $state := p:shift(22, $input, $state)             (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shift(231, $input, $state)            (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'copy' :)
      let $state := p:shift(98, $input, $state)             (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'delete' :)
      let $state := p:shift(105, $input, $state)            (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'first' :)
      let $state := p:shift(128, $input, $state)            (: 'first' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:shift(151, $input, $state)            (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'last' :)
      let $state := p:shift(158, $input, $state)            (: 'last' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shift(168, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:shift(204, $input, $state)            (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:shift(205, $input, $state)            (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shift(251, $input, $state)            (: 'with' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'private' :)
      let $state := p:shift(200, $input, $state)            (: 'private' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shift(74, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(75, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shift(79, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'catch' :)
      let $state := p:shift(90, $input, $state)             (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shift(91, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shift(100, $input, $state)            (: 'count' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'declare' :)
      let $state := p:shift(103, $input, $state)            (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shift(106, $input, $state)            (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shift(107, $input, $state)            (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shift(108, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shift(113, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:shift(114, $input, $state)            (: 'document' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shift(117, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'every' :)
      let $state := p:shift(124, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'following' :)
      let $state := p:shift(129, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shift(130, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shift(131, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shift(141, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shift(144, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'import' :)
      let $state := p:shift(146, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shift(153, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shift(162, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shift(167, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'module' :)
      let $state := p:shift(169, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shift(171, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:shift(187, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shift(191, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shift(196, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shift(197, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shift(202, $input, $state)            (: 'property' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shift(206, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shift(209, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shift(213, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shift(219, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shift(234, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:shift(239, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'validate' :)
      let $state := p:shift(242, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:shift(248, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(255, $input, $state)            (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionQName", $count, $begin, $end)
};

(:~
 : Try parsing FunctionQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 22) then                       (: QName^Token :)
      let $state := p:shiftT(22, $input, $state)            (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shiftT(231, $input, $state)           (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'copy' :)
      let $state := p:shiftT(98, $input, $state)            (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'delete' :)
      let $state := p:shiftT(105, $input, $state)           (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'first' :)
      let $state := p:shiftT(128, $input, $state)           (: 'first' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'insert' :)
      let $state := p:shiftT(151, $input, $state)           (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'last' :)
      let $state := p:shiftT(158, $input, $state)           (: 'last' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shiftT(168, $input, $state)           (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 204) then                      (: 'rename' :)
      let $state := p:shiftT(204, $input, $state)           (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'replace' :)
      let $state := p:shiftT(205, $input, $state)           (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shiftT(251, $input, $state)           (: 'with' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'private' :)
      let $state := p:shiftT(200, $input, $state)           (: 'private' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ancestor' :)
      let $state := p:shiftT(74, $input, $state)            (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ancestor-or-self' :)
      let $state := p:shiftT(75, $input, $state)            (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shiftT(79, $input, $state)            (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'catch' :)
      let $state := p:shiftT(90, $input, $state)            (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:shiftT(91, $input, $state)            (: 'child' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shiftT(100, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'declare' :)
      let $state := p:shiftT(103, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'descendant' :)
      let $state := p:shiftT(106, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'descendant-or-self' :)
      let $state := p:shiftT(107, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shiftT(108, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shiftT(113, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'document' :)
      let $state := p:shiftT(114, $input, $state)           (: 'document' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shiftT(117, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'every' :)
      let $state := p:shiftT(124, $input, $state)           (: 'every' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'following' :)
      let $state := p:shiftT(129, $input, $state)           (: 'following' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'following-sibling' :)
      let $state := p:shiftT(130, $input, $state)           (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shiftT(131, $input, $state)           (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shiftT(141, $input, $state)           (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shiftT(144, $input, $state)           (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'import' :)
      let $state := p:shiftT(146, $input, $state)           (: 'import' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shiftT(153, $input, $state)           (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shiftT(162, $input, $state)           (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shiftT(167, $input, $state)           (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'module' :)
      let $state := p:shiftT(169, $input, $state)           (: 'module' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'namespace' :)
      let $state := p:shiftT(171, $input, $state)           (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:shiftT(187, $input, $state)           (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'parent' :)
      let $state := p:shiftT(191, $input, $state)           (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'preceding' :)
      let $state := p:shiftT(196, $input, $state)           (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'preceding-sibling' :)
      let $state := p:shiftT(197, $input, $state)           (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'property' :)
      let $state := p:shiftT(202, $input, $state)           (: 'property' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shiftT(206, $input, $state)           (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shiftT(209, $input, $state)           (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'self' :)
      let $state := p:shiftT(213, $input, $state)           (: 'self' :)
      return $state
    else if ($state[$p:l1] = 219) then                      (: 'some' :)
      let $state := p:shiftT(219, $input, $state)           (: 'some' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shiftT(234, $input, $state)           (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'unordered' :)
      let $state := p:shiftT(239, $input, $state)           (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'validate' :)
      let $state := p:shiftT(242, $input, $state)           (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 248) then                      (: 'where' :)
      let $state := p:shiftT(248, $input, $state)           (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(255, $input, $state)           (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(226, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shift(81, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:shift(84, $input, $state)             (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:shift(93, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:shift(115, $input, $state)            (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'empty-sequence' :)
      let $state := p:shift(119, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'function' :)
      let $state := p:shift(138, $input, $state)            (: 'function' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'if' :)
      let $state := p:shift(145, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'item' :)
      let $state := p:shift(156, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:shift(172, $input, $state)            (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shift(178, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:shift(201, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:shift(211, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:shift(212, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 227) then                      (: 'switch' :)
      let $state := p:shift(227, $input, $state)            (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:shift(228, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:shift(237, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Try parsing QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(226, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'attribute' :)
      let $state := p:shiftT(81, $input, $state)            (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'binary' :)
      let $state := p:shiftT(84, $input, $state)            (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:shiftT(93, $input, $state)            (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'document-node' :)
      let $state := p:shiftT(115, $input, $state)           (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:shiftT(116, $input, $state)           (: 'element' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'empty-sequence' :)
      let $state := p:shiftT(119, $input, $state)           (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'function' :)
      let $state := p:shiftT(138, $input, $state)           (: 'function' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'if' :)
      let $state := p:shiftT(145, $input, $state)           (: 'if' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'item' :)
      let $state := p:shiftT(156, $input, $state)           (: 'item' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'namespace-node' :)
      let $state := p:shiftT(172, $input, $state)           (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'node' :)
      let $state := p:shiftT(178, $input, $state)           (: 'node' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'processing-instruction' :)
      let $state := p:shiftT(201, $input, $state)           (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'schema-attribute' :)
      let $state := p:shiftT(211, $input, $state)           (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 212) then                      (: 'schema-element' :)
      let $state := p:shiftT(212, $input, $state)           (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 227) then                      (: 'switch' :)
      let $state := p:shiftT(227, $input, $state)           (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 228) then                      (: 'text' :)
      let $state := p:shiftT(228, $input, $state)           (: 'text' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'typeswitch' :)
      let $state := p:shiftT(237, $input, $state)           (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-FunctionQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(227, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EQName", $count, $begin, $end)
};

(:~
 : Try parsing EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(227, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'contains' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: URIQualifiedName :)
      let $state := p:shiftT(7, $input, $state)             (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:shift(60, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 101) then                      (: 'decimal-format' :)
      let $state := p:shift(101, $input, $state)            (: 'decimal-format' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:shift(101, $input, $state)            (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DecimalFormatDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'inherit' :)
      let $state := p:shift(149, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(176, $input, $state)            (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: 'preserve' :)
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(177, $input, $state)            (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:shift(99, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:shift(41, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:shift(207, $input, $state)                (: 'revalidation' :)
  let $state := p:lookahead1W(145, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 224) then                      (: 'strict' :)
      let $state := p:shift(224, $input, $state)            (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'lax' :)
      let $state := p:shift(159, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(217, $input, $state)            (: 'skip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RevalidationDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:shift(186, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(118, $input, $state)                (: 'empty' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'greatest' :)
      let $state := p:shift(140, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(161, $input, $state)            (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:shift(188, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 187) then                      (: 'ordered' :)
      let $state := p:shift(187, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(239, $input, $state)            (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:shift(94, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 225) then                      (: 'strip' :)
      let $state := p:shift(225, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:shift(82, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:shift(92, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:shift(85, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: 'preserve' :)
      let $state := p:shift(198, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(225, $input, $state)            (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 103) then                          (: 'declare' :)
      let $state := p:lookahead2W(166, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      let $state :=
        if ($state[$p:lk] eq 53351) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(143, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43623) then                    (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 24170599) then                 (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 42087) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 48231) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 96359) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 48812135) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 106087) then                   (: 'declare' 'revalidation' :)
      let $state := p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 50791) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(103, $input, $state)                (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(104, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 116) then                      (: 'element' :)
      let $state := p:shift(116, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(138, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(242, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 103) then                        (: 'declare' :)
        let $state := p:lookahead2W(188, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'contains' | 'context' |
                                                               'copy-namespaces' | 'decimal-format' | 'default' |
                                                               'div' | 'eq' | 'except' | 'ft-option' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'option' |
                                                               'or' | 'ordering' | 'private' | 'revalidation' | 'to' |
                                                               'treat' | 'union' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 146) then                   (: 'import' :)
        let $state := p:lookahead2W(179, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'stylesheet' | 'to' | 'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 42087                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 43623                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 48231                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 50791                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 51815                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 53351                            (: 'declare' 'default' :)
      and $state[$p:lk] != 68199                            (: 'declare' 'ft-option' :)
      and $state[$p:lk] != 86674                            (: 'import' 'module' :)
      and $state[$p:lk] != 87655                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 96359                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 106087                           (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 107666                           (: 'import' 'schema' :)
      and $state[$p:lk] != 115858) then                     (: 'import' 'stylesheet' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 103) then                    (: 'declare' :)
            let $state := p:lookahead2W(171, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'ft-option' | 'namespace' | 'ordering' |
                                                                'revalidation' :)
            let $state :=
              if ($state[$p:lk] eq 53351) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(159, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 30462055                 (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 36229223) then           (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 87655) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 146) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:lk] = 68199) then              (: 'declare' 'ft-option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-FTOptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(242, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 103) then                        (: 'declare' :)
        let $state := p:lookahead2W(180, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'context' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'private' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 16487                            (: 'declare' '%' :)
      and $state[$p:lk] != 49767                            (: 'declare' 'context' :)
      and $state[$p:lk] != 70759                            (: 'declare' 'function' :)
      and $state[$p:lk] != 94311                            (: 'declare' 'option' :)
      and $state[$p:lk] != 102503                           (: 'declare' 'private' :)
      and $state[$p:lk] != 125031) then                     (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 103) then                    (: 'declare' :)
            let $state := p:lookahead2W(164, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'private' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 49767) then              (: 'declare' 'context' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 94311) then              (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: NCName^Token :)
      let $state := p:shift(21, $input, $state)             (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shift(95, $input, $state)             (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shift(190, $input, $state)            (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shift(216, $input, $state)            (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shift(231, $input, $state)            (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shift(254, $input, $state)            (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shift(71, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shift(78, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shift(83, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shift(154, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shift(168, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shift(251, $input, $state)            (: 'with' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shift(76, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shift(79, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shift(87, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shift(88, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shift(89, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shift(92, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shift(100, $input, $state)            (: 'count' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shift(104, $input, $state)            (: 'default' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shift(108, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shift(113, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shift(117, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shift(118, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shift(121, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shift(123, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shift(126, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shift(131, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shift(139, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shift(141, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shift(143, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shift(144, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shift(152, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shift(153, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shift(155, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shift(160, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shift(162, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shift(165, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shift(167, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shift(173, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shift(183, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shift(185, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shift(186, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shift(206, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shift(209, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shift(220, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shift(221, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shift(232, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shift(233, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shift(234, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shift(238, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(248, $input, $state)            (: 'where' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Try parsing NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: NCName^Token :)
      let $state := p:shiftT(21, $input, $state)            (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'contains' :)
      let $state := p:shiftT(95, $input, $state)            (: 'contains' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'paragraphs' :)
      let $state := p:shiftT(190, $input, $state)           (: 'paragraphs' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'sentences' :)
      let $state := p:shiftT(216, $input, $state)           (: 'sentences' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'times' :)
      let $state := p:shiftT(231, $input, $state)           (: 'times' :)
      return $state
    else if ($state[$p:l1] = 254) then                      (: 'words' :)
      let $state := p:shiftT(254, $input, $state)           (: 'words' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'after' :)
      let $state := p:shiftT(71, $input, $state)            (: 'after' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'as' :)
      let $state := p:shiftT(78, $input, $state)            (: 'as' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'before' :)
      let $state := p:shiftT(83, $input, $state)            (: 'before' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'into' :)
      let $state := p:shiftT(154, $input, $state)           (: 'into' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'modify' :)
      let $state := p:shiftT(168, $input, $state)           (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 251) then                      (: 'with' :)
      let $state := p:shiftT(251, $input, $state)           (: 'with' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'and' :)
      let $state := p:shiftT(76, $input, $state)            (: 'and' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ascending' :)
      let $state := p:shiftT(79, $input, $state)            (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:shiftT(87, $input, $state)            (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:shiftT(88, $input, $state)            (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:shiftT(89, $input, $state)            (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:shiftT(92, $input, $state)            (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'count' :)
      let $state := p:shiftT(100, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'default' :)
      let $state := p:shiftT(104, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'descending' :)
      let $state := p:shiftT(108, $input, $state)           (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'div' :)
      let $state := p:shiftT(113, $input, $state)           (: 'div' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'else' :)
      let $state := p:shiftT(117, $input, $state)           (: 'else' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'empty' :)
      let $state := p:shiftT(118, $input, $state)           (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'end' :)
      let $state := p:shiftT(121, $input, $state)           (: 'end' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'eq' :)
      let $state := p:shiftT(123, $input, $state)           (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'except' :)
      let $state := p:shiftT(126, $input, $state)           (: 'except' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'for' :)
      let $state := p:shiftT(131, $input, $state)           (: 'for' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ge' :)
      let $state := p:shiftT(139, $input, $state)           (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'group' :)
      let $state := p:shiftT(141, $input, $state)           (: 'group' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'gt' :)
      let $state := p:shiftT(143, $input, $state)           (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'idiv' :)
      let $state := p:shiftT(144, $input, $state)           (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'instance' :)
      let $state := p:shiftT(152, $input, $state)           (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'intersect' :)
      let $state := p:shiftT(153, $input, $state)           (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'is' :)
      let $state := p:shiftT(155, $input, $state)           (: 'is' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'le' :)
      let $state := p:shiftT(160, $input, $state)           (: 'le' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'let' :)
      let $state := p:shiftT(162, $input, $state)           (: 'let' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'lt' :)
      let $state := p:shiftT(165, $input, $state)           (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'mod' :)
      let $state := p:shiftT(167, $input, $state)           (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'ne' :)
      let $state := p:shiftT(173, $input, $state)           (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'only' :)
      let $state := p:shiftT(183, $input, $state)           (: 'only' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'or' :)
      let $state := p:shiftT(185, $input, $state)           (: 'or' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'order' :)
      let $state := p:shiftT(186, $input, $state)           (: 'order' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'return' :)
      let $state := p:shiftT(206, $input, $state)           (: 'return' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'satisfies' :)
      let $state := p:shiftT(209, $input, $state)           (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 220) then                      (: 'stable' :)
      let $state := p:shiftT(220, $input, $state)           (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'start' :)
      let $state := p:shiftT(221, $input, $state)           (: 'start' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'to' :)
      let $state := p:shiftT(232, $input, $state)           (: 'to' :)
      return $state
    else if ($state[$p:l1] = 233) then                      (: 'treat' :)
      let $state := p:shiftT(233, $input, $state)           (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 234) then                      (: 'try' :)
      let $state := p:shiftT(234, $input, $state)           (: 'try' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'union' :)
      let $state := p:shiftT(238, $input, $state)           (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(248, $input, $state)           (: 'where' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(169, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(171, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(181, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | 'with' | 'words' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(130, $input, $state)          (: EOF | S^WS | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(255, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'encoding' :)
      let $state := p:shift(120, $input, $state)            (: 'encoding' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(245, $input, $state)            (: 'version' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'encoding' :)
          let $state := p:shift(120, $input, $state)        (: 'encoding' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 255) then                          (: 'xquery' :)
      let $state := p:lookahead2W(178, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'treat' | 'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 61695                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 125695) then                   (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 169) then                          (: 'module' :)
      let $state := p:lookahead2W(177, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'or' | 'to' |
                                                               'treat' | 'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 87721) then                    (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MainModuleSequence($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(241, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'binary' |
                                                               'case' | 'cast' | 'castable' | 'catch' | 'child' |
                                                               'collation' | 'comment' | 'contains' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'rename' |
                                                               'replace' | 'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(16, $input, $state)           (: EOF | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:shift, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shiftT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 24) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false(), <memo/>))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 512 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 262144 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 1 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 1 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
